"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/[locale]/[workspaceid]/layout",{

/***/ "(app-pages-browser)/./components/chat/chat-helpers/index.ts":
/*!***********************************************!*\
  !*** ./components/chat/chat-helpers/index.ts ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTempMessages: function() { return /* binding */ createTempMessages; },\n/* harmony export */   fetchChatResponse: function() { return /* binding */ fetchChatResponse; },\n/* harmony export */   handleCreateChat: function() { return /* binding */ handleCreateChat; },\n/* harmony export */   handleCreateMessages: function() { return /* binding */ handleCreateMessages; },\n/* harmony export */   handleHostedChat: function() { return /* binding */ handleHostedChat; },\n/* harmony export */   handleLocalChat: function() { return /* binding */ handleLocalChat; },\n/* harmony export */   handleRetrieval: function() { return /* binding */ handleRetrieval; },\n/* harmony export */   processResponse: function() { return /* binding */ processResponse; },\n/* harmony export */   validateChatSettings: function() { return /* binding */ validateChatSettings; }\n/* harmony export */ });\n/* harmony import */ var _db_chat_files__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/db/chat-files */ \"(app-pages-browser)/./db/chat-files.ts\");\n/* harmony import */ var _db_chats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/db/chats */ \"(app-pages-browser)/./db/chats.ts\");\n/* harmony import */ var _db_message_file_items__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/db/message-file-items */ \"(app-pages-browser)/./db/message-file-items.ts\");\n/* harmony import */ var _db_messages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/db/messages */ \"(app-pages-browser)/./db/messages.ts\");\n/* harmony import */ var _db_storage_message_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/db/storage/message-images */ \"(app-pages-browser)/./db/storage/message-images.ts\");\n/* harmony import */ var _lib_build_prompt__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/lib/build-prompt */ \"(app-pages-browser)/./lib/build-prompt.ts\");\n/* harmony import */ var _lib_consume_stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/lib/consume-stream */ \"(app-pages-browser)/./lib/consume-stream.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n// Only used in use-chat-handler.tsx to keep it clean\n\n\n\n\n\n\n\n\n\n\nconst validateChatSettings = (chatSettings, modelData, profile, selectedWorkspace, messageContent)=>{\n    if (!chatSettings) {\n        throw new Error(\"Chat settings not found\");\n    }\n    if (!modelData) {\n        throw new Error(\"Model not found\");\n    }\n    if (!profile) {\n        throw new Error(\"Profile not found\");\n    }\n    if (!selectedWorkspace) {\n        throw new Error(\"Workspace not found\");\n    }\n    if (!messageContent) {\n        throw new Error(\"Message content not found\");\n    }\n};\nconst handleRetrieval = async (userInput, newMessageFiles, chatFiles, embeddingsProvider, sourceCount)=>{\n    const response = await fetch(\"/api/retrieval/retrieve\", {\n        method: \"POST\",\n        body: JSON.stringify({\n            userInput,\n            fileIds: [\n                ...newMessageFiles,\n                ...chatFiles\n            ].map((file)=>file.id),\n            embeddingsProvider,\n            sourceCount\n        })\n    });\n    if (!response.ok) {\n        console.error(\"Error retrieving:\", response);\n    }\n    const { results } = await response.json();\n    return results;\n};\nconst createTempMessages = (messageContent, chatMessages, chatSettings, b64Images, isRegeneration, setChatMessages, selectedAssistant)=>{\n    let tempUserChatMessage = {\n        message: {\n            chat_id: \"\",\n            assistant_id: null,\n            content: messageContent,\n            created_at: \"\",\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(),\n            image_paths: b64Images,\n            model: chatSettings.model,\n            role: \"user\",\n            sequence_number: chatMessages.length,\n            updated_at: \"\",\n            user_id: \"\"\n        },\n        fileItems: []\n    };\n    let tempAssistantChatMessage = {\n        message: {\n            chat_id: \"\",\n            assistant_id: (selectedAssistant === null || selectedAssistant === void 0 ? void 0 : selectedAssistant.id) || null,\n            content: \"\",\n            created_at: \"\",\n            id: (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(),\n            image_paths: [],\n            model: chatSettings.model,\n            role: \"assistant\",\n            sequence_number: chatMessages.length + 1,\n            updated_at: \"\",\n            user_id: \"\"\n        },\n        fileItems: []\n    };\n    let newMessages = [];\n    if (isRegeneration) {\n        const lastMessageIndex = chatMessages.length - 1;\n        chatMessages[lastMessageIndex].message.content = \"\";\n        newMessages = [\n            ...chatMessages\n        ];\n    } else {\n        newMessages = [\n            ...chatMessages,\n            tempUserChatMessage,\n            tempAssistantChatMessage\n        ];\n    }\n    setChatMessages(newMessages);\n    return {\n        tempUserChatMessage,\n        tempAssistantChatMessage\n    };\n};\nconst handleLocalChat = async (payload, profile, chatSettings, tempAssistantMessage, isRegeneration, newAbortController, setIsGenerating, setFirstTokenReceived, setChatMessages, setToolInUse)=>{\n    const formattedMessages = await (0,_lib_build_prompt__WEBPACK_IMPORTED_MODULE_5__.buildFinalMessages)(payload, profile, []);\n    // Ollama API: https://github.com/jmorganca/ollama/blob/main/docs/api.md\n    const response = await fetchChatResponse(\"127.0.0.1:11434\" + \"/api/chat\", {\n        model: chatSettings.model,\n        messages: formattedMessages,\n        options: {\n            temperature: payload.chatSettings.temperature\n        }\n    }, false, newAbortController, setIsGenerating, setChatMessages);\n    return await processResponse(response, isRegeneration ? payload.chatMessages[payload.chatMessages.length - 1] : tempAssistantMessage, false, newAbortController, setFirstTokenReceived, setChatMessages, setToolInUse);\n};\nconst handleHostedChat = async (payload, profile, modelData, tempAssistantChatMessage, isRegeneration, newAbortController, newMessageImages, chatImages, setIsGenerating, setFirstTokenReceived, setChatMessages, setToolInUse)=>{\n    const provider = modelData.provider === \"openai\" && profile.use_azure_openai ? \"azure\" : modelData.provider;\n    let draftMessages = await (0,_lib_build_prompt__WEBPACK_IMPORTED_MODULE_5__.buildFinalMessages)(payload, profile, chatImages);\n    let formattedMessages = [];\n    if (provider === \"google\") {\n        formattedMessages = await (0,_lib_build_prompt__WEBPACK_IMPORTED_MODULE_5__.adaptMessagesForGoogleGemini)(payload, draftMessages);\n    } else {\n        formattedMessages = draftMessages;\n    }\n    const apiEndpoint = provider === \"custom\" ? \"/api/chat/custom\" : \"/api/chat/\".concat(provider);\n    const requestBody = {\n        chatSettings: payload.chatSettings,\n        messages: formattedMessages,\n        customModelId: provider === \"custom\" ? modelData.hostedId : \"\"\n    };\n    const response = await fetchChatResponse(apiEndpoint, requestBody, true, newAbortController, setIsGenerating, setChatMessages);\n    return await processResponse(response, isRegeneration ? payload.chatMessages[payload.chatMessages.length - 1] : tempAssistantChatMessage, true, newAbortController, setFirstTokenReceived, setChatMessages, setToolInUse);\n};\nconst fetchChatResponse = async (url, body, isHosted, controller, setIsGenerating, setChatMessages)=>{\n    const response = await fetch(url, {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        signal: controller.signal\n    });\n    if (!response.ok) {\n        if (response.status === 404 && !isHosted) {\n            sonner__WEBPACK_IMPORTED_MODULE_8__.toast.error(\"Model not found. Make sure you have it downloaded via Ollama.\");\n        }\n        const errorData = await response.json();\n        sonner__WEBPACK_IMPORTED_MODULE_8__.toast.error(errorData.message);\n        setIsGenerating(false);\n        setChatMessages((prevMessages)=>prevMessages.slice(0, -2));\n    }\n    return response;\n};\nconst processResponse = async (response, lastChatMessage, isHosted, controller, setFirstTokenReceived, setChatMessages, setToolInUse)=>{\n    let fullText = \"\";\n    let contentToAdd = \"\";\n    if (response.body) {\n        await (0,_lib_consume_stream__WEBPACK_IMPORTED_MODULE_6__.consumeReadableStream)(response.body, (chunk)=>{\n            setFirstTokenReceived(true);\n            setToolInUse(\"none\");\n            try {\n                contentToAdd = isHosted ? chunk : // objects. A chunk may have more than one of these objects, so we\n                // need to split the chunk by new-lines and handle each one\n                // separately.\n                chunk.trimEnd().split(\"\\n\").reduce((acc, line)=>acc + JSON.parse(line).message.content, \"\");\n                fullText += contentToAdd;\n            } catch (error) {\n                console.error(\"Error parsing JSON:\", error);\n            }\n            setChatMessages((prev)=>prev.map((chatMessage)=>{\n                    if (chatMessage.message.id === lastChatMessage.message.id) {\n                        const updatedChatMessage = {\n                            message: {\n                                ...chatMessage.message,\n                                content: fullText\n                            },\n                            fileItems: chatMessage.fileItems\n                        };\n                        return updatedChatMessage;\n                    }\n                    return chatMessage;\n                }));\n        }, controller.signal);\n        return fullText;\n    } else {\n        throw new Error(\"Response body is null\");\n    }\n};\nconst handleCreateChat = async (chatSettings, profile, selectedWorkspace, messageContent, selectedAssistant, newMessageFiles, setSelectedChat, setChats, setChatFiles)=>{\n    const createdChat = await (0,_db_chats__WEBPACK_IMPORTED_MODULE_1__.createChat)({\n        user_id: profile.user_id,\n        workspace_id: selectedWorkspace.id,\n        assistant_id: (selectedAssistant === null || selectedAssistant === void 0 ? void 0 : selectedAssistant.id) || null,\n        context_length: chatSettings.contextLength,\n        include_profile_context: chatSettings.includeProfileContext,\n        include_workspace_instructions: chatSettings.includeWorkspaceInstructions,\n        model: chatSettings.model,\n        name: messageContent.substring(0, 100),\n        prompt: chatSettings.prompt,\n        temperature: chatSettings.temperature,\n        embeddings_provider: chatSettings.embeddingsProvider\n    });\n    setSelectedChat(createdChat);\n    setChats((chats)=>[\n            createdChat,\n            ...chats\n        ]);\n    await (0,_db_chat_files__WEBPACK_IMPORTED_MODULE_0__.createChatFiles)(newMessageFiles.map((file)=>({\n            user_id: profile.user_id,\n            chat_id: createdChat.id,\n            file_id: file.id\n        })));\n    setChatFiles((prev)=>[\n            ...prev,\n            ...newMessageFiles\n        ]);\n    return createdChat;\n};\nconst handleCreateMessages = async (chatMessages, currentChat, profile, modelData, messageContent, generatedText, newMessageImages, isRegeneration, retrievedFileItems, setChatMessages, setChatFileItems, setChatImages, selectedAssistant)=>{\n    const finalUserMessage = {\n        chat_id: currentChat.id,\n        assistant_id: null,\n        user_id: profile.user_id,\n        content: messageContent,\n        model: modelData.modelId,\n        role: \"user\",\n        sequence_number: chatMessages.length,\n        image_paths: []\n    };\n    const finalAssistantMessage = {\n        chat_id: currentChat.id,\n        assistant_id: (selectedAssistant === null || selectedAssistant === void 0 ? void 0 : selectedAssistant.id) || null,\n        user_id: profile.user_id,\n        content: generatedText,\n        model: modelData.modelId,\n        role: \"assistant\",\n        sequence_number: chatMessages.length + 1,\n        image_paths: []\n    };\n    let finalChatMessages = [];\n    if (isRegeneration) {\n        const lastStartingMessage = chatMessages[chatMessages.length - 1].message;\n        const updatedMessage = await (0,_db_messages__WEBPACK_IMPORTED_MODULE_3__.updateMessage)(lastStartingMessage.id, {\n            ...lastStartingMessage,\n            content: generatedText\n        });\n        chatMessages[chatMessages.length - 1].message = updatedMessage;\n        finalChatMessages = [\n            ...chatMessages\n        ];\n        setChatMessages(finalChatMessages);\n    } else {\n        const createdMessages = await (0,_db_messages__WEBPACK_IMPORTED_MODULE_3__.createMessages)([\n            finalUserMessage,\n            finalAssistantMessage\n        ]);\n        // Upload each image (stored in newMessageImages) for the user message to message_images bucket\n        const uploadPromises = newMessageImages.filter((obj)=>obj.file !== null).map((obj)=>{\n            let filePath = \"\".concat(profile.user_id, \"/\").concat(currentChat.id, \"/\").concat(createdMessages[0].id, \"/\").concat((0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])());\n            return (0,_db_storage_message_images__WEBPACK_IMPORTED_MODULE_4__.uploadMessageImage)(filePath, obj.file).catch((error)=>{\n                console.error(\"Failed to upload image at \".concat(filePath, \":\"), error);\n                return null;\n            });\n        });\n        const paths = (await Promise.all(uploadPromises)).filter(Boolean);\n        setChatImages((prevImages)=>[\n                ...prevImages,\n                ...newMessageImages.map((obj, index)=>({\n                        ...obj,\n                        messageId: createdMessages[0].id,\n                        path: paths[index]\n                    }))\n            ]);\n        const updatedMessage = await (0,_db_messages__WEBPACK_IMPORTED_MODULE_3__.updateMessage)(createdMessages[0].id, {\n            ...createdMessages[0],\n            image_paths: paths\n        });\n        const createdMessageFileItems = await (0,_db_message_file_items__WEBPACK_IMPORTED_MODULE_2__.createMessageFileItems)(retrievedFileItems.map((fileItem)=>{\n            return {\n                user_id: profile.user_id,\n                message_id: createdMessages[1].id,\n                file_item_id: fileItem.id\n            };\n        }));\n        finalChatMessages = [\n            ...chatMessages,\n            {\n                message: updatedMessage,\n                fileItems: []\n            },\n            {\n                message: createdMessages[1],\n                fileItems: retrievedFileItems.map((fileItem)=>fileItem.id)\n            }\n        ];\n        setChatFileItems((prevFileItems)=>{\n            const newFileItems = retrievedFileItems.filter((fileItem)=>!prevFileItems.some((prevItem)=>prevItem.id === fileItem.id));\n            return [\n                ...prevFileItems,\n                ...newFileItems\n            ];\n        });\n        setChatMessages(finalChatMessages);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY2hhdC9jaGF0LWhlbHBlcnMvaW5kZXgudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxREFBcUQ7QUFFSjtBQUNWO0FBQ3lCO0FBQ0g7QUFDRztBQUlyQztBQUNpQztBQVVuQztBQUNLO0FBQ0s7QUFFNUIsTUFBTWEsdUJBQXVCLENBQ2xDQyxjQUNBQyxXQUNBQyxTQUNBQyxtQkFDQUM7SUFFQSxJQUFJLENBQUNKLGNBQWM7UUFDakIsTUFBTSxJQUFJSyxNQUFNO0lBQ2xCO0lBRUEsSUFBSSxDQUFDSixXQUFXO1FBQ2QsTUFBTSxJQUFJSSxNQUFNO0lBQ2xCO0lBRUEsSUFBSSxDQUFDSCxTQUFTO1FBQ1osTUFBTSxJQUFJRyxNQUFNO0lBQ2xCO0lBRUEsSUFBSSxDQUFDRixtQkFBbUI7UUFDdEIsTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBRUEsSUFBSSxDQUFDRCxnQkFBZ0I7UUFDbkIsTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0FBQ0YsRUFBQztBQUVNLE1BQU1DLGtCQUFrQixPQUM3QkMsV0FDQUMsaUJBQ0FDLFdBQ0FDLG9CQUNBQztJQUVBLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSwyQkFBMkI7UUFDdERDLFFBQVE7UUFDUkMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO1lBQ25CVjtZQUNBVyxTQUFTO21CQUFJVjttQkFBb0JDO2FBQVUsQ0FBQ1UsR0FBRyxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxFQUFFO1lBQy9EWDtZQUNBQztRQUNGO0lBQ0Y7SUFFQSxJQUFJLENBQUNDLFNBQVNVLEVBQUUsRUFBRTtRQUNoQkMsUUFBUUMsS0FBSyxDQUFDLHFCQUFxQlo7SUFDckM7SUFFQSxNQUFNLEVBQUVhLE9BQU8sRUFBRSxHQUFJLE1BQU1iLFNBQVNjLElBQUk7SUFJeEMsT0FBT0Q7QUFDVCxFQUFDO0FBRU0sTUFBTUUscUJBQXFCLENBQ2hDdkIsZ0JBQ0F3QixjQUNBNUIsY0FD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PzMwOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT25seSB1c2VkIGluIHVzZS1jaGF0LWhhbmRsZXIudHN4IHRvIGtlZXAgaXQgY2xlYW5cblxuaW1wb3J0IHsgY3JlYXRlQ2hhdEZpbGVzIH0gZnJvbSBcIkAvZGIvY2hhdC1maWxlc1wiXG5pbXBvcnQgeyBjcmVhdGVDaGF0IH0gZnJvbSBcIkAvZGIvY2hhdHNcIlxuaW1wb3J0IHsgY3JlYXRlTWVzc2FnZUZpbGVJdGVtcyB9IGZyb20gXCJAL2RiL21lc3NhZ2UtZmlsZS1pdGVtc1wiXG5pbXBvcnQgeyBjcmVhdGVNZXNzYWdlcywgdXBkYXRlTWVzc2FnZSB9IGZyb20gXCJAL2RiL21lc3NhZ2VzXCJcbmltcG9ydCB7IHVwbG9hZE1lc3NhZ2VJbWFnZSB9IGZyb20gXCJAL2RiL3N0b3JhZ2UvbWVzc2FnZS1pbWFnZXNcIlxuaW1wb3J0IHtcbiAgYnVpbGRGaW5hbE1lc3NhZ2VzLFxuICBhZGFwdE1lc3NhZ2VzRm9yR29vZ2xlR2VtaW5pXG59IGZyb20gXCJAL2xpYi9idWlsZC1wcm9tcHRcIlxuaW1wb3J0IHsgY29uc3VtZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIkAvbGliL2NvbnN1bWUtc3RyZWFtXCJcbmltcG9ydCB7IFRhYmxlcywgVGFibGVzSW5zZXJ0IH0gZnJvbSBcIkAvc3VwYWJhc2UvdHlwZXNcIlxuaW1wb3J0IHtcbiAgQ2hhdEZpbGUsXG4gIENoYXRNZXNzYWdlLFxuICBDaGF0UGF5bG9hZCxcbiAgQ2hhdFNldHRpbmdzLFxuICBMTE0sXG4gIE1lc3NhZ2VJbWFnZVxufSBmcm9tIFwiQC90eXBlc1wiXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IHRvYXN0IH0gZnJvbSBcInNvbm5lclwiXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tIFwidXVpZFwiXG5cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZUNoYXRTZXR0aW5ncyA9IChcbiAgY2hhdFNldHRpbmdzOiBDaGF0U2V0dGluZ3MgfCBudWxsLFxuICBtb2RlbERhdGE6IExMTSB8IHVuZGVmaW5lZCxcbiAgcHJvZmlsZTogVGFibGVzPFwicHJvZmlsZXNcIj4gfCBudWxsLFxuICBzZWxlY3RlZFdvcmtzcGFjZTogVGFibGVzPFwid29ya3NwYWNlc1wiPiB8IG51bGwsXG4gIG1lc3NhZ2VDb250ZW50OiBzdHJpbmdcbikgPT4ge1xuICBpZiAoIWNoYXRTZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYXQgc2V0dGluZ3Mgbm90IGZvdW5kXCIpXG4gIH1cblxuICBpZiAoIW1vZGVsRGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIG5vdCBmb3VuZFwiKVxuICB9XG5cbiAgaWYgKCFwcm9maWxlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvZmlsZSBub3QgZm91bmRcIilcbiAgfVxuXG4gIGlmICghc2VsZWN0ZWRXb3Jrc3BhY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3Jrc3BhY2Ugbm90IGZvdW5kXCIpXG4gIH1cblxuICBpZiAoIW1lc3NhZ2VDb250ZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzc2FnZSBjb250ZW50IG5vdCBmb3VuZFwiKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVSZXRyaWV2YWwgPSBhc3luYyAoXG4gIHVzZXJJbnB1dDogc3RyaW5nLFxuICBuZXdNZXNzYWdlRmlsZXM6IENoYXRGaWxlW10sXG4gIGNoYXRGaWxlczogQ2hhdEZpbGVbXSxcbiAgZW1iZWRkaW5nc1Byb3ZpZGVyOiBcIm9wZW5haVwiIHwgXCJsb2NhbFwiLFxuICBzb3VyY2VDb3VudDogbnVtYmVyXG4pID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkvcmV0cmlldmFsL3JldHJpZXZlXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHVzZXJJbnB1dCxcbiAgICAgIGZpbGVJZHM6IFsuLi5uZXdNZXNzYWdlRmlsZXMsIC4uLmNoYXRGaWxlc10ubWFwKGZpbGUgPT4gZmlsZS5pZCksXG4gICAgICBlbWJlZGRpbmdzUHJvdmlkZXIsXG4gICAgICBzb3VyY2VDb3VudFxuICAgIH0pXG4gIH0pXG5cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXRyaWV2aW5nOlwiLCByZXNwb25zZSlcbiAgfVxuXG4gIGNvbnN0IHsgcmVzdWx0cyB9ID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMge1xuICAgIHJlc3VsdHM6IFRhYmxlczxcImZpbGVfaXRlbXNcIj5bXVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVRlbXBNZXNzYWdlcyA9IChcbiAgbWVzc2FnZUNvbnRlbnQ6IHN0cmluZyxcbiAgY2hhdE1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLFxuICBjaGF0U2V0dGluZ3M6IENoYXRTZXR0aW5ncyxcbiAgYjY0SW1hZ2VzOiBzdHJpbmdbXSxcbiAgaXNSZWdlbmVyYXRpb246IGJvb2xlYW4sXG4gIHNldENoYXRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Q2hhdE1lc3NhZ2VbXT4+LFxuICBzZWxlY3RlZEFzc2lzdGFudDogVGFibGVzPFwiYXNzaXN0YW50c1wiPiB8IG51bGxcbikgPT4ge1xuICBsZXQgdGVtcFVzZXJDaGF0TWVzc2FnZTogQ2hhdE1lc3NhZ2UgPSB7XG4gICAgbWVzc2FnZToge1xuICAgICAgY2hhdF9pZDogXCJcIixcbiAgICAgIGFzc2lzdGFudF9pZDogbnVsbCxcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VDb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogXCJcIixcbiAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgIGltYWdlX3BhdGhzOiBiNjRJbWFnZXMsXG4gICAgICBtb2RlbDogY2hhdFNldHRpbmdzLm1vZGVsLFxuICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICBzZXF1ZW5jZV9udW1iZXI6IGNoYXRNZXNzYWdlcy5sZW5ndGgsXG4gICAgICB1cGRhdGVkX2F0OiBcIlwiLFxuICAgICAgdXNlcl9pZDogXCJcIlxuICAgIH0sXG4gICAgZmlsZUl0ZW1zOiBbXVxuICB9XG5cbiAgbGV0IHRlbXBBc3Npc3RhbnRDaGF0TWVzc2FnZTogQ2hhdE1lc3NhZ2UgPSB7XG4gICAgbWVzc2FnZToge1xuICAgICAgY2hhdF9pZDogXCJcIixcbiAgICAgIGFzc2lzdGFudF9pZDogc2VsZWN0ZWRBc3Npc3RhbnQ/LmlkIHx8IG51bGwsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgY3JlYXRlZF9hdDogXCJcIixcbiAgICAgIGlkOiB1dWlkdjQoKSxcbiAgICAgIGltYWdlX3BhdGhzOiBbXSxcbiAgICAgIG1vZGVsOiBjaGF0U2V0dGluZ3MubW9kZWwsXG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgc2VxdWVuY2VfbnVtYmVyOiBjaGF0TWVzc2FnZXMubGVuZ3RoICsgMSxcbiAgICAgIHVwZGF0ZWRfYXQ6IFwiXCIsXG4gICAgICB1c2VyX2lkOiBcIlwiXG4gICAgfSxcbiAgICBmaWxlSXRlbXM6IFtdXG4gIH1cblxuICBsZXQgbmV3TWVzc2FnZXMgPSBbXVxuXG4gIGlmIChpc1JlZ2VuZXJhdGlvbikge1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlSW5kZXggPSBjaGF0TWVzc2FnZXMubGVuZ3RoIC0gMVxuICAgIGNoYXRNZXNzYWdlc1tsYXN0TWVzc2FnZUluZGV4XS5tZXNzYWdlLmNvbnRlbnQgPSBcIlwiXG4gICAgbmV3TWVzc2FnZXMgPSBbLi4uY2hhdE1lc3NhZ2VzXVxuICB9IGVsc2Uge1xuICAgIG5ld01lc3NhZ2VzID0gW1xuICAgICAgLi4uY2hhdE1lc3NhZ2VzLFxuICAgICAgdGVtcFVzZXJDaGF0TWVzc2FnZSxcbiAgICAgIHRlbXBBc3Npc3RhbnRDaGF0TWVzc2FnZVxuICAgIF1cbiAgfVxuXG4gIHNldENoYXRNZXNzYWdlcyhuZXdNZXNzYWdlcylcblxuICByZXR1cm4ge1xuICAgIHRlbXBVc2VyQ2hhdE1lc3NhZ2UsXG4gICAgdGVtcEFzc2lzdGFudENoYXRNZXNzYWdlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGhhbmRsZUxvY2FsQ2hhdCA9IGFzeW5jIChcbiAgcGF5bG9hZDogQ2hhdFBheWxvYWQsXG4gIHByb2ZpbGU6IFRhYmxlczxcInByb2ZpbGVzXCI+LFxuICBjaGF0U2V0dGluZ3M6IENoYXRTZXR0aW5ncyxcbiAgdGVtcEFzc2lzdGFudE1lc3NhZ2U6IENoYXRNZXNzYWdlLFxuICBpc1JlZ2VuZXJhdGlvbjogYm9vbGVhbixcbiAgbmV3QWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gIHNldElzR2VuZXJhdGluZzogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+LFxuICBzZXRGaXJzdFRva2VuUmVjZWl2ZWQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPGJvb2xlYW4+PixcbiAgc2V0Q2hhdE1lc3NhZ2VzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxDaGF0TWVzc2FnZVtdPj4sXG4gIHNldFRvb2xJblVzZTogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj5cbikgPT4ge1xuICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlcyA9IGF3YWl0IGJ1aWxkRmluYWxNZXNzYWdlcyhwYXlsb2FkLCBwcm9maWxlLCBbXSlcblxuICAvLyBPbGxhbWEgQVBJOiBodHRwczovL2dpdGh1Yi5jb20vam1vcmdhbmNhL29sbGFtYS9ibG9iL21haW4vZG9jcy9hcGkubWRcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaENoYXRSZXNwb25zZShcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PTExBTUFfVVJMICsgXCIvYXBpL2NoYXRcIixcbiAgICB7XG4gICAgICBtb2RlbDogY2hhdFNldHRpbmdzLm1vZGVsLFxuICAgICAgbWVzc2FnZXM6IGZvcm1hdHRlZE1lc3NhZ2VzLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0ZW1wZXJhdHVyZTogcGF5bG9hZC5jaGF0U2V0dGluZ3MudGVtcGVyYXR1cmVcbiAgICAgIH1cbiAgICB9LFxuICAgIGZhbHNlLFxuICAgIG5ld0Fib3J0Q29udHJvbGxlcixcbiAgICBzZXRJc0dlbmVyYXRpbmcsXG4gICAgc2V0Q2hhdE1lc3NhZ2VzXG4gIClcblxuICByZXR1cm4gYXdhaXQgcHJvY2Vzc1Jlc3BvbnNlKFxuICAgIHJlc3BvbnNlLFxuICAgIGlzUmVnZW5lcmF0aW9uXG4gICAgICA/IHBheWxvYWQuY2hhdE1lc3NhZ2VzW3BheWxvYWQuY2hhdE1lc3NhZ2VzLmxlbmd0aCAtIDFdXG4gICAgICA6IHRlbXBBc3Npc3RhbnRNZXNzYWdlLFxuICAgIGZhbHNlLFxuICAgIG5ld0Fib3J0Q29udHJvbGxlcixcbiAgICBzZXRGaXJzdFRva2VuUmVjZWl2ZWQsXG4gICAgc2V0Q2hhdE1lc3NhZ2VzLFxuICAgIHNldFRvb2xJblVzZVxuICApXG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVIb3N0ZWRDaGF0ID0gYXN5bmMgKFxuICBwYXlsb2FkOiBDaGF0UGF5bG9hZCxcbiAgcHJvZmlsZTogVGFibGVzPFwicHJvZmlsZXNcIj4sXG4gIG1vZGVsRGF0YTogTExNLFxuICB0ZW1wQXNzaXN0YW50Q2hhdE1lc3NhZ2U6IENoYXRNZXNzYWdlLFxuICBpc1JlZ2VuZXJhdGlvbjogYm9vbGVhbixcbiAgbmV3QWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gIG5ld01lc3NhZ2VJbWFnZXM6IE1lc3NhZ2VJbWFnZVtdLFxuICBjaGF0SW1hZ2VzOiBNZXNzYWdlSW1hZ2VbXSxcbiAgc2V0SXNHZW5lcmF0aW5nOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxib29sZWFuPj4sXG4gIHNldEZpcnN0VG9rZW5SZWNlaXZlZDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+LFxuICBzZXRDaGF0TWVzc2FnZXM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPENoYXRNZXNzYWdlW10+PixcbiAgc2V0VG9vbEluVXNlOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PlxuKSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVyID1cbiAgICBtb2RlbERhdGEucHJvdmlkZXIgPT09IFwib3BlbmFpXCIgJiYgcHJvZmlsZS51c2VfYXp1cmVfb3BlbmFpXG4gICAgICA/IFwiYXp1cmVcIlxuICAgICAgOiBtb2RlbERhdGEucHJvdmlkZXJcblxuICBsZXQgZHJhZnRNZXNzYWdlcyA9IGF3YWl0IGJ1aWxkRmluYWxNZXNzYWdlcyhwYXlsb2FkLCBwcm9maWxlLCBjaGF0SW1hZ2VzKVxuXG4gIGxldCBmb3JtYXR0ZWRNZXNzYWdlcyA6IGFueVtdID0gW11cbiAgaWYgKHByb3ZpZGVyID09PSBcImdvb2dsZVwiKSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZXMgPSBhd2FpdCBhZGFwdE1lc3NhZ2VzRm9yR29vZ2xlR2VtaW5pKHBheWxvYWQsIGRyYWZ0TWVzc2FnZXMpXG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZXMgPSBkcmFmdE1lc3NhZ2VzXG4gIH1cblxuICBjb25zdCBhcGlFbmRwb2ludCA9XG4gICAgcHJvdmlkZXIgPT09IFwiY3VzdG9tXCIgPyBcIi9hcGkvY2hhdC9jdXN0b21cIiA6IGAvYXBpL2NoYXQvJHtwcm92aWRlcn1gXG5cbiAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgY2hhdFNldHRpbmdzOiBwYXlsb2FkLmNoYXRTZXR0aW5ncyxcbiAgICBtZXNzYWdlczogZm9ybWF0dGVkTWVzc2FnZXMsXG4gICAgY3VzdG9tTW9kZWxJZDogcHJvdmlkZXIgPT09IFwiY3VzdG9tXCIgPyBtb2RlbERhdGEuaG9zdGVkSWQgOiBcIlwiXG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoQ2hhdFJlc3BvbnNlKFxuICAgIGFwaUVuZHBvaW50LFxuICAgIHJlcXVlc3RCb2R5LFxuICAgIHRydWUsXG4gICAgbmV3QWJvcnRDb250cm9sbGVyLFxuICAgIHNldElzR2VuZXJhdGluZyxcbiAgICBzZXRDaGF0TWVzc2FnZXNcbiAgKVxuXG4gIHJldHVybiBhd2FpdCBwcm9jZXNzUmVzcG9uc2UoXG4gICAgcmVzcG9uc2UsXG4gICAgaXNSZWdlbmVyYXRpb25cbiAgICAgID8gcGF5bG9hZC5jaGF0TWVzc2FnZXNbcGF5bG9hZC5jaGF0TWVzc2FnZXMubGVuZ3RoIC0gMV1cbiAgICAgIDogdGVtcEFzc2lzdGFudENoYXRNZXNzYWdlLFxuICAgIHRydWUsXG4gICAgbmV3QWJvcnRDb250cm9sbGVyLFxuICAgIHNldEZpcnN0VG9rZW5SZWNlaXZlZCxcbiAgICBzZXRDaGF0TWVzc2FnZXMsXG4gICAgc2V0VG9vbEluVXNlXG4gIClcbn1cblxuZXhwb3J0IGNvbnN0IGZldGNoQ2hhdFJlc3BvbnNlID0gYXN5bmMgKFxuICB1cmw6IHN0cmluZyxcbiAgYm9keTogb2JqZWN0LFxuICBpc0hvc3RlZDogYm9vbGVhbixcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyLFxuICBzZXRJc0dlbmVyYXRpbmc6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPGJvb2xlYW4+PixcbiAgc2V0Q2hhdE1lc3NhZ2VzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxDaGF0TWVzc2FnZVtdPj5cbikgPT4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICB9KVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQgJiYgIWlzSG9zdGVkKSB7XG4gICAgICB0b2FzdC5lcnJvcihcbiAgICAgICAgXCJNb2RlbCBub3QgZm91bmQuIE1ha2Ugc3VyZSB5b3UgaGF2ZSBpdCBkb3dubG9hZGVkIHZpYSBPbGxhbWEuXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcblxuICAgIHRvYXN0LmVycm9yKGVycm9yRGF0YS5tZXNzYWdlKVxuXG4gICAgc2V0SXNHZW5lcmF0aW5nKGZhbHNlKVxuICAgIHNldENoYXRNZXNzYWdlcyhwcmV2TWVzc2FnZXMgPT4gcHJldk1lc3NhZ2VzLnNsaWNlKDAsIC0yKSlcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG5leHBvcnQgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlID0gYXN5bmMgKFxuICByZXNwb25zZTogUmVzcG9uc2UsXG4gIGxhc3RDaGF0TWVzc2FnZTogQ2hhdE1lc3NhZ2UsXG4gIGlzSG9zdGVkOiBib29sZWFuLFxuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gIHNldEZpcnN0VG9rZW5SZWNlaXZlZDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+LFxuICBzZXRDaGF0TWVzc2FnZXM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPENoYXRNZXNzYWdlW10+PixcbiAgc2V0VG9vbEluVXNlOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PlxuKSA9PiB7XG4gIGxldCBmdWxsVGV4dCA9IFwiXCJcbiAgbGV0IGNvbnRlbnRUb0FkZCA9IFwiXCJcblxuICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgIGF3YWl0IGNvbnN1bWVSZWFkYWJsZVN0cmVhbShcbiAgICAgIHJlc3BvbnNlLmJvZHksXG4gICAgICBjaHVuayA9PiB7XG4gICAgICAgIHNldEZpcnN0VG9rZW5SZWNlaXZlZCh0cnVlKVxuICAgICAgICBzZXRUb29sSW5Vc2UoXCJub25lXCIpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb250ZW50VG9BZGQgPSBpc0hvc3RlZFxuICAgICAgICAgICAgPyBjaHVua1xuICAgICAgICAgICAgOiAvLyBPbGxhbWEncyBzdHJlYW1pbmcgZW5kcG9pbnQgcmV0dXJucyBuZXctbGluZSBzZXBhcmF0ZWQgSlNPTlxuICAgICAgICAgICAgICAvLyBvYmplY3RzLiBBIGNodW5rIG1heSBoYXZlIG1vcmUgdGhhbiBvbmUgb2YgdGhlc2Ugb2JqZWN0cywgc28gd2VcbiAgICAgICAgICAgICAgLy8gbmVlZCB0byBzcGxpdCB0aGUgY2h1bmsgYnkgbmV3LWxpbmVzIGFuZCBoYW5kbGUgZWFjaCBvbmVcbiAgICAgICAgICAgICAgLy8gc2VwYXJhdGVseS5cbiAgICAgICAgICAgICAgY2h1bmtcbiAgICAgICAgICAgICAgICAudHJpbUVuZCgpXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgIChhY2MsIGxpbmUpID0+IGFjYyArIEpTT04ucGFyc2UobGluZSkubWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICBmdWxsVGV4dCArPSBjb250ZW50VG9BZGRcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBKU09OOlwiLCBlcnJvcilcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENoYXRNZXNzYWdlcyhwcmV2ID0+XG4gICAgICAgICAgcHJldi5tYXAoY2hhdE1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYXRNZXNzYWdlLm1lc3NhZ2UuaWQgPT09IGxhc3RDaGF0TWVzc2FnZS5tZXNzYWdlLmlkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDaGF0TWVzc2FnZTogQ2hhdE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgICAgLi4uY2hhdE1lc3NhZ2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bGxUZXh0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBmaWxlSXRlbXM6IGNoYXRNZXNzYWdlLmZpbGVJdGVtc1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRDaGF0TWVzc2FnZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2hhdE1lc3NhZ2VcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlci5zaWduYWxcbiAgICApXG5cbiAgICByZXR1cm4gZnVsbFRleHRcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlQ3JlYXRlQ2hhdCA9IGFzeW5jIChcbiAgY2hhdFNldHRpbmdzOiBDaGF0U2V0dGluZ3MsXG4gIHByb2ZpbGU6IFRhYmxlczxcInByb2ZpbGVzXCI+LFxuICBzZWxlY3RlZFdvcmtzcGFjZTogVGFibGVzPFwid29ya3NwYWNlc1wiPixcbiAgbWVzc2FnZUNvbnRlbnQ6IHN0cmluZyxcbiAgc2VsZWN0ZWRBc3Npc3RhbnQ6IFRhYmxlczxcImFzc2lzdGFudHNcIj4sXG4gIG5ld01lc3NhZ2VGaWxlczogQ2hhdEZpbGVbXSxcbiAgc2V0U2VsZWN0ZWRDaGF0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxUYWJsZXM8XCJjaGF0c1wiPiB8IG51bGw+PixcbiAgc2V0Q2hhdHM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFRhYmxlczxcImNoYXRzXCI+W10+PixcbiAgc2V0Q2hhdEZpbGVzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxDaGF0RmlsZVtdPj5cbikgPT4ge1xuICBjb25zdCBjcmVhdGVkQ2hhdCA9IGF3YWl0IGNyZWF0ZUNoYXQoe1xuICAgIHVzZXJfaWQ6IHByb2ZpbGUudXNlcl9pZCxcbiAgICB3b3Jrc3BhY2VfaWQ6IHNlbGVjdGVkV29ya3NwYWNlLmlkLFxuICAgIGFzc2lzdGFudF9pZDogc2VsZWN0ZWRBc3Npc3RhbnQ/LmlkIHx8IG51bGwsXG4gICAgY29udGV4dF9sZW5ndGg6IGNoYXRTZXR0aW5ncy5jb250ZXh0TGVuZ3RoLFxuICAgIGluY2x1ZGVfcHJvZmlsZV9jb250ZXh0OiBjaGF0U2V0dGluZ3MuaW5jbHVkZVByb2ZpbGVDb250ZXh0LFxuICAgIGluY2x1ZGVfd29ya3NwYWNlX2luc3RydWN0aW9uczogY2hhdFNldHRpbmdzLmluY2x1ZGVXb3Jrc3BhY2VJbnN0cnVjdGlvbnMsXG4gICAgbW9kZWw6IGNoYXRTZXR0aW5ncy5tb2RlbCxcbiAgICBuYW1lOiBtZXNzYWdlQ29udGVudC5zdWJzdHJpbmcoMCwgMTAwKSxcbiAgICBwcm9tcHQ6IGNoYXRTZXR0aW5ncy5wcm9tcHQsXG4gICAgdGVtcGVyYXR1cmU6IGNoYXRTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICBlbWJlZGRpbmdzX3Byb3ZpZGVyOiBjaGF0U2V0dGluZ3MuZW1iZWRkaW5nc1Byb3ZpZGVyXG4gIH0pXG5cbiAgc2V0U2VsZWN0ZWRDaGF0KGNyZWF0ZWRDaGF0KVxuICBzZXRDaGF0cyhjaGF0cyA9PiBbY3JlYXRlZENoYXQsIC4uLmNoYXRzXSlcblxuICBhd2FpdCBjcmVhdGVDaGF0RmlsZXMoXG4gICAgbmV3TWVzc2FnZUZpbGVzLm1hcChmaWxlID0+ICh7XG4gICAgICB1c2VyX2lkOiBwcm9maWxlLnVzZXJfaWQsXG4gICAgICBjaGF0X2lkOiBjcmVhdGVkQ2hhdC5pZCxcbiAgICAgIGZpbGVfaWQ6IGZpbGUuaWRcbiAgICB9KSlcbiAgKVxuXG4gIHNldENoYXRGaWxlcyhwcmV2ID0+IFsuLi5wcmV2LCAuLi5uZXdNZXNzYWdlRmlsZXNdKVxuXG4gIHJldHVybiBjcmVhdGVkQ2hhdFxufVxuXG5leHBvcnQgY29uc3QgaGFuZGxlQ3JlYXRlTWVzc2FnZXMgPSBhc3luYyAoXG4gIGNoYXRNZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSxcbiAgY3VycmVudENoYXQ6IFRhYmxlczxcImNoYXRzXCI+LFxuICBwcm9maWxlOiBUYWJsZXM8XCJwcm9maWxlc1wiPixcbiAgbW9kZWxEYXRhOiBMTE0sXG4gIG1lc3NhZ2VDb250ZW50OiBzdHJpbmcsXG4gIGdlbmVyYXRlZFRleHQ6IHN0cmluZyxcbiAgbmV3TWVzc2FnZUltYWdlczogTWVzc2FnZUltYWdlW10sXG4gIGlzUmVnZW5lcmF0aW9uOiBib29sZWFuLFxuICByZXRyaWV2ZWRGaWxlSXRlbXM6IFRhYmxlczxcImZpbGVfaXRlbXNcIj5bXSxcbiAgc2V0Q2hhdE1lc3NhZ2VzOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxDaGF0TWVzc2FnZVtdPj4sXG4gIHNldENoYXRGaWxlSXRlbXM6IFJlYWN0LkRpc3BhdGNoPFxuICAgIFJlYWN0LlNldFN0YXRlQWN0aW9uPFRhYmxlczxcImZpbGVfaXRlbXNcIj5bXT5cbiAgPixcbiAgc2V0Q2hhdEltYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248TWVzc2FnZUltYWdlW10+PixcbiAgc2VsZWN0ZWRBc3Npc3RhbnQ6IFRhYmxlczxcImFzc2lzdGFudHNcIj4gfCBudWxsXG4pID0+IHtcbiAgY29uc3QgZmluYWxVc2VyTWVzc2FnZTogVGFibGVzSW5zZXJ0PFwibWVzc2FnZXNcIj4gPSB7XG4gICAgY2hhdF9pZDogY3VycmVudENoYXQuaWQsXG4gICAgYXNzaXN0YW50X2lkOiBudWxsLFxuICAgIHVzZXJfaWQ6IHByb2ZpbGUudXNlcl9pZCxcbiAgICBjb250ZW50OiBtZXNzYWdlQ29udGVudCxcbiAgICBtb2RlbDogbW9kZWxEYXRhLm1vZGVsSWQsXG4gICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgc2VxdWVuY2VfbnVtYmVyOiBjaGF0TWVzc2FnZXMubGVuZ3RoLFxuICAgIGltYWdlX3BhdGhzOiBbXVxuICB9XG5cbiAgY29uc3QgZmluYWxBc3Npc3RhbnRNZXNzYWdlOiBUYWJsZXNJbnNlcnQ8XCJtZXNzYWdlc1wiPiA9IHtcbiAgICBjaGF0X2lkOiBjdXJyZW50Q2hhdC5pZCxcbiAgICBhc3Npc3RhbnRfaWQ6IHNlbGVjdGVkQXNzaXN0YW50Py5pZCB8fCBudWxsLFxuICAgIHVzZXJfaWQ6IHByb2ZpbGUudXNlcl9pZCxcbiAgICBjb250ZW50OiBnZW5lcmF0ZWRUZXh0LFxuICAgIG1vZGVsOiBtb2RlbERhdGEubW9kZWxJZCxcbiAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgIHNlcXVlbmNlX251bWJlcjogY2hhdE1lc3NhZ2VzLmxlbmd0aCArIDEsXG4gICAgaW1hZ2VfcGF0aHM6IFtdXG4gIH1cblxuICBsZXQgZmluYWxDaGF0TWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXVxuXG4gIGlmIChpc1JlZ2VuZXJhdGlvbikge1xuICAgIGNvbnN0IGxhc3RTdGFydGluZ01lc3NhZ2UgPSBjaGF0TWVzc2FnZXNbY2hhdE1lc3NhZ2VzLmxlbmd0aCAtIDFdLm1lc3NhZ2VcblxuICAgIGNvbnN0IHVwZGF0ZWRNZXNzYWdlID0gYXdhaXQgdXBkYXRlTWVzc2FnZShsYXN0U3RhcnRpbmdNZXNzYWdlLmlkLCB7XG4gICAgICAuLi5sYXN0U3RhcnRpbmdNZXNzYWdlLFxuICAgICAgY29udGVudDogZ2VuZXJhdGVkVGV4dFxuICAgIH0pXG5cbiAgICBjaGF0TWVzc2FnZXNbY2hhdE1lc3NhZ2VzLmxlbmd0aCAtIDFdLm1lc3NhZ2UgPSB1cGRhdGVkTWVzc2FnZVxuXG4gICAgZmluYWxDaGF0TWVzc2FnZXMgPSBbLi4uY2hhdE1lc3NhZ2VzXVxuXG4gICAgc2V0Q2hhdE1lc3NhZ2VzKGZpbmFsQ2hhdE1lc3NhZ2VzKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNyZWF0ZWRNZXNzYWdlcyA9IGF3YWl0IGNyZWF0ZU1lc3NhZ2VzKFtcbiAgICAgIGZpbmFsVXNlck1lc3NhZ2UsXG4gICAgICBmaW5hbEFzc2lzdGFudE1lc3NhZ2VcbiAgICBdKVxuXG4gICAgLy8gVXBsb2FkIGVhY2ggaW1hZ2UgKHN0b3JlZCBpbiBuZXdNZXNzYWdlSW1hZ2VzKSBmb3IgdGhlIHVzZXIgbWVzc2FnZSB0byBtZXNzYWdlX2ltYWdlcyBidWNrZXRcbiAgICBjb25zdCB1cGxvYWRQcm9taXNlcyA9IG5ld01lc3NhZ2VJbWFnZXNcbiAgICAgIC5maWx0ZXIob2JqID0+IG9iai5maWxlICE9PSBudWxsKVxuICAgICAgLm1hcChvYmogPT4ge1xuICAgICAgICBsZXQgZmlsZVBhdGggPSBgJHtwcm9maWxlLnVzZXJfaWR9LyR7Y3VycmVudENoYXQuaWR9LyR7XG4gICAgICAgICAgY3JlYXRlZE1lc3NhZ2VzWzBdLmlkXG4gICAgICAgIH0vJHt1dWlkdjQoKX1gXG5cbiAgICAgICAgcmV0dXJuIHVwbG9hZE1lc3NhZ2VJbWFnZShmaWxlUGF0aCwgb2JqLmZpbGUgYXMgRmlsZSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgaW1hZ2UgYXQgJHtmaWxlUGF0aH06YCwgZXJyb3IpXG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICBjb25zdCBwYXRocyA9IChhd2FpdCBQcm9taXNlLmFsbCh1cGxvYWRQcm9taXNlcykpLmZpbHRlcihcbiAgICAgIEJvb2xlYW5cbiAgICApIGFzIHN0cmluZ1tdXG5cbiAgICBzZXRDaGF0SW1hZ2VzKHByZXZJbWFnZXMgPT4gW1xuICAgICAgLi4ucHJldkltYWdlcyxcbiAgICAgIC4uLm5ld01lc3NhZ2VJbWFnZXMubWFwKChvYmosIGluZGV4KSA9PiAoe1xuICAgICAgICAuLi5vYmosXG4gICAgICAgIG1lc3NhZ2VJZDogY3JlYXRlZE1lc3NhZ2VzWzBdLmlkLFxuICAgICAgICBwYXRoOiBwYXRoc1tpbmRleF1cbiAgICAgIH0pKVxuICAgIF0pXG5cbiAgICBjb25zdCB1cGRhdGVkTWVzc2FnZSA9IGF3YWl0IHVwZGF0ZU1lc3NhZ2UoY3JlYXRlZE1lc3NhZ2VzWzBdLmlkLCB7XG4gICAgICAuLi5jcmVhdGVkTWVzc2FnZXNbMF0sXG4gICAgICBpbWFnZV9wYXRoczogcGF0aHNcbiAgICB9KVxuXG4gICAgY29uc3QgY3JlYXRlZE1lc3NhZ2VGaWxlSXRlbXMgPSBhd2FpdCBjcmVhdGVNZXNzYWdlRmlsZUl0ZW1zKFxuICAgICAgcmV0cmlldmVkRmlsZUl0ZW1zLm1hcChmaWxlSXRlbSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcl9pZDogcHJvZmlsZS51c2VyX2lkLFxuICAgICAgICAgIG1lc3NhZ2VfaWQ6IGNyZWF0ZWRNZXNzYWdlc1sxXS5pZCxcbiAgICAgICAgICBmaWxlX2l0ZW1faWQ6IGZpbGVJdGVtLmlkXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuXG4gICAgZmluYWxDaGF0TWVzc2FnZXMgPSBbXG4gICAgICAuLi5jaGF0TWVzc2FnZXMsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2U6IHVwZGF0ZWRNZXNzYWdlLFxuICAgICAgICBmaWxlSXRlbXM6IFtdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtZXNzYWdlOiBjcmVhdGVkTWVzc2FnZXNbMV0sXG4gICAgICAgIGZpbGVJdGVtczogcmV0cmlldmVkRmlsZUl0ZW1zLm1hcChmaWxlSXRlbSA9PiBmaWxlSXRlbS5pZClcbiAgICAgIH1cbiAgICBdXG5cbiAgICBzZXRDaGF0RmlsZUl0ZW1zKHByZXZGaWxlSXRlbXMgPT4ge1xuICAgICAgY29uc3QgbmV3RmlsZUl0ZW1zID0gcmV0cmlldmVkRmlsZUl0ZW1zLmZpbHRlcihcbiAgICAgICAgZmlsZUl0ZW0gPT4gIXByZXZGaWxlSXRlbXMuc29tZShwcmV2SXRlbSA9PiBwcmV2SXRlbS5pZCA9PT0gZmlsZUl0ZW0uaWQpXG4gICAgICApXG5cbiAgICAgIHJldHVybiBbLi4ucHJldkZpbGVJdGVtcywgLi4ubmV3RmlsZUl0ZW1zXVxuICAgIH0pXG5cbiAgICBzZXRDaGF0TWVzc2FnZXMoZmluYWxDaGF0TWVzc2FnZXMpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVDaGF0RmlsZXMiLCJjcmVhdGVDaGF0IiwiY3JlYXRlTWVzc2FnZUZpbGVJdGVtcyIsImNyZWF0ZU1lc3NhZ2VzIiwidXBkYXRlTWVzc2FnZSIsInVwbG9hZE1lc3NhZ2VJbWFnZSIsImJ1aWxkRmluYWxNZXNzYWdlcyIsImFkYXB0TWVzc2FnZXNGb3JHb29nbGVHZW1pbmkiLCJjb25zdW1lUmVhZGFibGVTdHJlYW0iLCJSZWFjdCIsInRvYXN0IiwidjQiLCJ1dWlkdjQiLCJ2YWxpZGF0ZUNoYXRTZXR0aW5ncyIsImNoYXRTZXR0aW5ncyIsIm1vZGVsRGF0YSIsInByb2ZpbGUiLCJzZWxlY3RlZFdvcmtzcGFjZSIsIm1lc3NhZ2VDb250ZW50IiwiRXJyb3IiLCJoYW5kbGVSZXRyaWV2YWwiLCJ1c2VySW5wdXQiLCJuZXdNZXNzYWdlRmlsZXMiLCJjaGF0RmlsZXMiLCJlbWJlZGRpbmdzUHJvdmlkZXIiLCJzb3VyY2VDb3VudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZpbGVJZHMiLCJtYXAiLCJmaWxlIiwiaWQiLCJvayIsImNvbnNvbGUiLCJlcnJvciIsInJlc3VsdHMiLCJqc29uIiwiY3JlYXRlVGVtcE1lc3NhZ2VzIiwiY2hhdE1lc3NhZ2VzIiwiYjY0SW1hZ2VzIiwiaXNSZWdlbmVyYXRpb24iLCJzZXRDaGF0TWVzc2FnZXMiLCJzZWxlY3RlZEFzc2lzdGFudCIsInRlbXBVc2VyQ2hhdE1lc3NhZ2UiLCJtZXNzYWdlIiwiY2hhdF9pZCIsImFzc2lzdGFudF9pZCIsImNvbnRlbnQiLCJjcmVhdGVkX2F0IiwiaW1hZ2VfcGF0aHMiLCJtb2RlbCIsInJvbGUiLCJzZXF1ZW5jZV9udW1iZXIiLCJsZW5ndGgiLCJ1cGRhdGVkX2F0IiwidXNlcl9pZCIsImZpbGVJdGVtcyIsInRlbXBBc3Npc3RhbnRDaGF0TWVzc2FnZSIsIm5ld01lc3NhZ2VzIiwibGFzdE1lc3NhZ2VJbmRleCIsImhhbmRsZUxvY2FsQ2hhdCIsInBheWxvYWQiLCJ0ZW1wQXNzaXN0YW50TWVzc2FnZSIsIm5ld0Fib3J0Q29udHJvbGxlciIsInNldElzR2VuZXJhdGluZyIsInNldEZpcnN0VG9rZW5SZWNlaXZlZCIsInNldFRvb2xJblVzZSIsImZvcm1hdHRlZE1lc3NhZ2VzIiwiZmV0Y2hDaGF0UmVzcG9uc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfT0xMQU1BX1VSTCIsIm1lc3NhZ2VzIiwib3B0aW9ucyIsInRlbXBlcmF0dXJlIiwicHJvY2Vzc1Jlc3BvbnNlIiwiaGFuZGxlSG9zdGVkQ2hhdCIsIm5ld01lc3NhZ2VJbWFnZXMiLCJjaGF0SW1hZ2VzIiwicHJvdmlkZXIiLCJ1c2VfYXp1cmVfb3BlbmFpIiwiZHJhZnRNZXNzYWdlcyIsImFwaUVuZHBvaW50IiwicmVxdWVzdEJvZHkiLCJjdXN0b21Nb2RlbElkIiwiaG9zdGVkSWQiLCJ1cmwiLCJpc0hvc3RlZCIsImNvbnRyb2xsZXIiLCJzaWduYWwiLCJzdGF0dXMiLCJlcnJvckRhdGEiLCJwcmV2TWVzc2FnZXMiLCJzbGljZSIsImxhc3RDaGF0TWVzc2FnZSIsImZ1bGxUZXh0IiwiY29udGVudFRvQWRkIiwiY2h1bmsiLCJ0cmltRW5kIiwic3BsaXQiLCJyZWR1Y2UiLCJhY2MiLCJsaW5lIiwicGFyc2UiLCJwcmV2IiwiY2hhdE1lc3NhZ2UiLCJ1cGRhdGVkQ2hhdE1lc3NhZ2UiLCJoYW5kbGVDcmVhdGVDaGF0Iiwic2V0U2VsZWN0ZWRDaGF0Iiwic2V0Q2hhdHMiLCJzZXRDaGF0RmlsZXMiLCJjcmVhdGVkQ2hhdCIsIndvcmtzcGFjZV9pZCIsImNvbnRleHRfbGVuZ3RoIiwiY29udGV4dExlbmd0aCIsImluY2x1ZGVfcHJvZmlsZV9jb250ZXh0IiwiaW5jbHVkZVByb2ZpbGVDb250ZXh0IiwiaW5jbHVkZV93b3Jrc3BhY2VfaW5zdHJ1Y3Rpb25zIiwiaW5jbHVkZVdvcmtzcGFjZUluc3RydWN0aW9ucyIsIm5hbWUiLCJzdWJzdHJpbmciLCJwcm9tcHQiLCJlbWJlZGRpbmdzX3Byb3ZpZGVyIiwiY2hhdHMiLCJmaWxlX2lkIiwiaGFuZGxlQ3JlYXRlTWVzc2FnZXMiLCJjdXJyZW50Q2hhdCIsImdlbmVyYXRlZFRleHQiLCJyZXRyaWV2ZWRGaWxlSXRlbXMiLCJzZXRDaGF0RmlsZUl0ZW1zIiwic2V0Q2hhdEltYWdlcyIsImZpbmFsVXNlck1lc3NhZ2UiLCJtb2RlbElkIiwiZmluYWxBc3Npc3RhbnRNZXNzYWdlIiwiZmluYWxDaGF0TWVzc2FnZXMiLCJsYXN0U3RhcnRpbmdNZXNzYWdlIiwidXBkYXRlZE1lc3NhZ2UiLCJjcmVhdGVkTWVzc2FnZXMiLCJ1cGxvYWRQcm9taXNlcyIsImZpbHRlciIsIm9iaiIsImZpbGVQYXRoIiwiY2F0Y2giLCJwYXRocyIsIlByb21pc2UiLCJhbGwiLCJCb29sZWFuIiwicHJldkltYWdlcyIsImluZGV4IiwibWVzc2FnZUlkIiwicGF0aCIsImNyZWF0ZWRNZXNzYWdlRmlsZUl0ZW1zIiwiZmlsZUl0ZW0iLCJtZXNzYWdlX2lkIiwiZmlsZV9pdGVtX2lkIiwicHJldkZpbGVJdGVtcyIsIm5ld0ZpbGVJdGVtcyIsInNvbWUiLCJwcmV2SXRlbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/chat/chat-helpers/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/models/fetch-models.ts":
/*!************************************!*\
  !*** ./lib/models/fetch-models.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchHostedModels: function() { return /* binding */ fetchHostedModels; },\n/* harmony export */   fetchOllamaModels: function() { return /* binding */ fetchOllamaModels; },\n/* harmony export */   fetchOpenRouterModels: function() { return /* binding */ fetchOpenRouterModels; }\n/* harmony export */ });\n/* harmony import */ var sonner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sonner */ \"(app-pages-browser)/./node_modules/sonner/dist/index.mjs\");\n/* harmony import */ var _llm_llm_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./llm/llm-list */ \"(app-pages-browser)/./lib/models/llm/llm-list.ts\");\n\n\nconst fetchHostedModels = async (profile)=>{\n    try {\n        const providers = [\n            \"google\",\n            \"anthropic\",\n            \"mistral\",\n            \"groq\",\n            \"perplexity\"\n        ];\n        if (profile.use_azure_openai) {\n            providers.push(\"azure\");\n        } else {\n            providers.push(\"openai\");\n        }\n        const response = await fetch(\"/api/keys\");\n        if (!response.ok) {\n            throw new Error(\"Server is not responding.\");\n        }\n        const data = await response.json();\n        let modelsToAdd = [];\n        for (const provider of providers){\n            let providerKey;\n            if (provider === \"google\") {\n                providerKey = \"google_gemini_api_key\";\n            } else if (provider === \"azure\") {\n                providerKey = \"azure_openai_api_key\";\n            } else {\n                providerKey = \"\".concat(provider, \"_api_key\");\n            }\n            if ((profile === null || profile === void 0 ? void 0 : profile[providerKey]) || data.isUsingEnvKeyMap[provider]) {\n                const models = _llm_llm_list__WEBPACK_IMPORTED_MODULE_1__.LLM_LIST_MAP[provider];\n                if (Array.isArray(models)) {\n                    modelsToAdd.push(...models);\n                }\n            }\n        }\n        return {\n            envKeyMap: data.isUsingEnvKeyMap,\n            hostedModels: modelsToAdd\n        };\n    } catch (error) {\n        console.warn(\"Error fetching hosted models: \" + error);\n    }\n};\nconst fetchOllamaModels = async ()=>{\n    try {\n        const response = await fetch(\"127.0.0.1:11434\" + \"/api/tags\");\n        if (!response.ok) {\n            throw new Error(\"Ollama server is not responding.\");\n        }\n        const data = await response.json();\n        const localModels = data.models.map((model)=>({\n                modelId: model.name,\n                modelName: model.name,\n                provider: \"ollama\",\n                hostedId: model.name,\n                platformLink: \"https://ollama.ai/library\",\n                imageInput: false\n            }));\n        return localModels;\n    } catch (error) {\n        console.warn(\"Error fetching Ollama models: \" + error);\n    }\n};\nconst fetchOpenRouterModels = async ()=>{\n    try {\n        const response = await fetch(\"https://openrouter.ai/api/v1/models\");\n        if (!response.ok) {\n            throw new Error(\"OpenRouter server is not responding.\");\n        }\n        const { data } = await response.json();\n        const openRouterModels = data.map((model)=>({\n                modelId: model.id,\n                modelName: model.id,\n                provider: \"openrouter\",\n                hostedId: model.name,\n                platformLink: \"https://openrouter.dev\",\n                imageInput: false,\n                maxContext: model.context_length\n            }));\n        return openRouterModels;\n    } catch (error) {\n        console.error(\"Error fetching Open Router models: \" + error);\n        sonner__WEBPACK_IMPORTED_MODULE_0__.toast.error(\"Error fetching Open Router models: \" + error);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbHMvZmV0Y2gtbW9kZWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRThCO0FBQ2U7QUFFdEMsTUFBTUUsb0JBQW9CLE9BQU9DO0lBQ3RDLElBQUk7UUFDRixNQUFNQyxZQUFZO1lBQUM7WUFBVTtZQUFhO1lBQVc7WUFBUTtTQUFhO1FBRTFFLElBQUlELFFBQVFFLGdCQUFnQixFQUFFO1lBQzVCRCxVQUFVRSxJQUFJLENBQUM7UUFDakIsT0FBTztZQUNMRixVQUFVRSxJQUFJLENBQUM7UUFDakI7UUFFQSxNQUFNQyxXQUFXLE1BQU1DLE1BQU07UUFFN0IsSUFBSSxDQUFDRCxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFPO1FBQ25CO1FBRUEsTUFBTUMsT0FBTyxNQUFNSixTQUFTSyxJQUFJO1FBRWhDLElBQUlDLGNBQXFCLEVBQUU7UUFFM0IsS0FBSyxNQUFNQyxZQUFZVixVQUFXO1lBQ2hDLElBQUlXO1lBRUosSUFBSUQsYUFBYSxVQUFVO2dCQUN6QkMsY0FBYztZQUNoQixPQUFPLElBQUlELGFBQWEsU0FBUztnQkFDL0JDLGNBQWM7WUFDaEIsT0FBTztnQkFDTEEsY0FBYyxHQUFZLE9BQVRELFVBQVM7WUFDNUI7WUFFQSxJQUFJWCxDQUFBQSxvQkFBQUEsOEJBQUFBLE9BQVMsQ0FBQ1ksWUFBWSxLQUFJSixLQUFLSyxnQkFBZ0IsQ0FBQ0YsU0FBUyxFQUFFO2dCQUM3RCxNQUFNRyxTQUFTaEIsdURBQVksQ0FBQ2EsU0FBUztnQkFFckMsSUFBSUksTUFBTUMsT0FBTyxDQUFDRixTQUFTO29CQUN6QkosWUFBWVAsSUFBSSxJQUFJVztnQkFDdEI7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUNMRyxXQUFXVCxLQUFLSyxnQkFBZ0I7WUFDaENLLGNBQWNSO1FBQ2hCO0lBQ0YsRUFBRSxPQUFPUyxPQUFPO1FBQ2RDLFFBQVFDLElBQUksQ0FBQyxtQ0FBbUNGO0lBQ2xEO0FBQ0YsRUFBQztBQUVNLE1BQU1HLG9CQUFvQjtJQUMvQixJQUFJO1FBQ0YsTUFBTWxCLFdBQVcsTUFBTUMsTUFDckJrQixpQkFBa0MsR0FBRztRQUd2QyxJQUFJLENBQUNuQixTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFPO1FBQ25CO1FBRUEsTUFBTUMsT0FBTyxNQUFNSixTQUFTSyxJQUFJO1FBRWhDLE1BQU1pQixjQUFxQmxCLEtBQUtNLE1BQU0sQ0FBQ2EsR0FBRyxDQUFDLENBQUNDLFFBQWdCO2dCQUMxREMsU0FBU0QsTUFBTUUsSUFBSTtnQkFDbkJDLFdBQVdILE1BQU1FLElBQUk7Z0JBQ3JCbkIsVUFBVTtnQkFDVnFCLFVBQVVKLE1BQU1FLElBQUk7Z0JBQ3BCRyxjQUFjO2dCQUNkQyxZQUFZO1lBQ2Q7UUFFQSxPQUFPUjtJQUNULEVBQUUsT0FBT1AsT0FBTztRQUNkQyxRQUFRQyxJQUFJLENBQUMsbUNBQW1DRjtJQUNsRDtBQUNGLEVBQUM7QUFFTSxNQUFNZ0Isd0JBQXdCO0lBQ25DLElBQUk7UUFDRixNQUFNL0IsV0FBVyxNQUFNQyxNQUFNO1FBRTdCLElBQUksQ0FBQ0QsU0FBU0UsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTztRQUNuQjtRQUVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTUosU0FBU0ssSUFBSTtRQUVwQyxNQUFNMkIsbUJBQW1CNUIsS0FBS21CLEdBQUcsQ0FDL0IsQ0FBQ0MsUUFJcUI7Z0JBQ3BCQyxTQUFTRCxNQUFNUyxFQUFFO2dCQUNqQk4sV0FBV0gsTUFBTVMsRUFBRTtnQkFDbkIxQixVQUFVO2dCQUNWcUIsVUFBVUosTUFBTUUsSUFBSTtnQkFDcEJHLGNBQWM7Z0JBQ2RDLFlBQVk7Z0JBQ1pJLFlBQVlWLE1BQU1XLGNBQWM7WUFDbEM7UUFHRixPQUFPSDtJQUNULEVBQUUsT0FBT2pCLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLHdDQUF3Q0E7UUFDdER0Qix5Q0FBS0EsQ0FBQ3NCLEtBQUssQ0FBQyx3Q0FBd0NBO0lBQ3REO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWxzL2ZldGNoLW1vZGVscy50cz82NGYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRhYmxlcyB9IGZyb20gXCJAL3N1cGFiYXNlL3R5cGVzXCJcbmltcG9ydCB7IExMTSwgTExNSUQsIE9wZW5Sb3V0ZXJMTE0gfSBmcm9tIFwiQC90eXBlc1wiXG5pbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJzb25uZXJcIlxuaW1wb3J0IHsgTExNX0xJU1RfTUFQIH0gZnJvbSBcIi4vbGxtL2xsbS1saXN0XCJcblxuZXhwb3J0IGNvbnN0IGZldGNoSG9zdGVkTW9kZWxzID0gYXN5bmMgKHByb2ZpbGU6IFRhYmxlczxcInByb2ZpbGVzXCI+KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdmlkZXJzID0gW1wiZ29vZ2xlXCIsIFwiYW50aHJvcGljXCIsIFwibWlzdHJhbFwiLCBcImdyb3FcIiwgXCJwZXJwbGV4aXR5XCJdXG5cbiAgICBpZiAocHJvZmlsZS51c2VfYXp1cmVfb3BlbmFpKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcImF6dXJlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3ZpZGVycy5wdXNoKFwib3BlbmFpXCIpXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi9hcGkva2V5c1wiKVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgaXMgbm90IHJlc3BvbmRpbmcuYClcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBsZXQgbW9kZWxzVG9BZGQ6IExMTVtdID0gW11cblxuICAgIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgcHJvdmlkZXJzKSB7XG4gICAgICBsZXQgcHJvdmlkZXJLZXk6IGtleW9mIHR5cGVvZiBwcm9maWxlXG5cbiAgICAgIGlmIChwcm92aWRlciA9PT0gXCJnb29nbGVcIikge1xuICAgICAgICBwcm92aWRlcktleSA9IFwiZ29vZ2xlX2dlbWluaV9hcGlfa2V5XCJcbiAgICAgIH0gZWxzZSBpZiAocHJvdmlkZXIgPT09IFwiYXp1cmVcIikge1xuICAgICAgICBwcm92aWRlcktleSA9IFwiYXp1cmVfb3BlbmFpX2FwaV9rZXlcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXJLZXkgPSBgJHtwcm92aWRlcn1fYXBpX2tleWAgYXMga2V5b2YgdHlwZW9mIHByb2ZpbGVcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2ZpbGU/Lltwcm92aWRlcktleV0gfHwgZGF0YS5pc1VzaW5nRW52S2V5TWFwW3Byb3ZpZGVyXSkge1xuICAgICAgICBjb25zdCBtb2RlbHMgPSBMTE1fTElTVF9NQVBbcHJvdmlkZXJdXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxzKSkge1xuICAgICAgICAgIG1vZGVsc1RvQWRkLnB1c2goLi4ubW9kZWxzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVudktleU1hcDogZGF0YS5pc1VzaW5nRW52S2V5TWFwLFxuICAgICAgaG9zdGVkTW9kZWxzOiBtb2RlbHNUb0FkZFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oXCJFcnJvciBmZXRjaGluZyBob3N0ZWQgbW9kZWxzOiBcIiArIGVycm9yKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmZXRjaE9sbGFtYU1vZGVscyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT0xMQU1BX1VSTCArIFwiL2FwaS90YWdzXCJcbiAgICApXG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9sbGFtYSBzZXJ2ZXIgaXMgbm90IHJlc3BvbmRpbmcuYClcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBjb25zdCBsb2NhbE1vZGVsczogTExNW10gPSBkYXRhLm1vZGVscy5tYXAoKG1vZGVsOiBhbnkpID0+ICh7XG4gICAgICBtb2RlbElkOiBtb2RlbC5uYW1lIGFzIExMTUlELFxuICAgICAgbW9kZWxOYW1lOiBtb2RlbC5uYW1lLFxuICAgICAgcHJvdmlkZXI6IFwib2xsYW1hXCIsXG4gICAgICBob3N0ZWRJZDogbW9kZWwubmFtZSxcbiAgICAgIHBsYXRmb3JtTGluazogXCJodHRwczovL29sbGFtYS5haS9saWJyYXJ5XCIsXG4gICAgICBpbWFnZUlucHV0OiBmYWxzZVxuICAgIH0pKVxuXG4gICAgcmV0dXJuIGxvY2FsTW9kZWxzXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKFwiRXJyb3IgZmV0Y2hpbmcgT2xsYW1hIG1vZGVsczogXCIgKyBlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmV0Y2hPcGVuUm91dGVyTW9kZWxzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCJodHRwczovL29wZW5yb3V0ZXIuYWkvYXBpL3YxL21vZGVsc1wiKVxuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVuUm91dGVyIHNlcnZlciBpcyBub3QgcmVzcG9uZGluZy5gKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG5cbiAgICBjb25zdCBvcGVuUm91dGVyTW9kZWxzID0gZGF0YS5tYXAoXG4gICAgICAobW9kZWw6IHtcbiAgICAgICAgaWQ6IHN0cmluZ1xuICAgICAgICBuYW1lOiBzdHJpbmdcbiAgICAgICAgY29udGV4dF9sZW5ndGg6IG51bWJlclxuICAgICAgfSk6IE9wZW5Sb3V0ZXJMTE0gPT4gKHtcbiAgICAgICAgbW9kZWxJZDogbW9kZWwuaWQgYXMgTExNSUQsXG4gICAgICAgIG1vZGVsTmFtZTogbW9kZWwuaWQsXG4gICAgICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXJcIixcbiAgICAgICAgaG9zdGVkSWQ6IG1vZGVsLm5hbWUsXG4gICAgICAgIHBsYXRmb3JtTGluazogXCJodHRwczovL29wZW5yb3V0ZXIuZGV2XCIsXG4gICAgICAgIGltYWdlSW5wdXQ6IGZhbHNlLFxuICAgICAgICBtYXhDb250ZXh0OiBtb2RlbC5jb250ZXh0X2xlbmd0aFxuICAgICAgfSlcbiAgICApXG5cbiAgICByZXR1cm4gb3BlblJvdXRlck1vZGVsc1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBPcGVuIFJvdXRlciBtb2RlbHM6IFwiICsgZXJyb3IpXG4gICAgdG9hc3QuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBPcGVuIFJvdXRlciBtb2RlbHM6IFwiICsgZXJyb3IpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ0b2FzdCIsIkxMTV9MSVNUX01BUCIsImZldGNoSG9zdGVkTW9kZWxzIiwicHJvZmlsZSIsInByb3ZpZGVycyIsInVzZV9henVyZV9vcGVuYWkiLCJwdXNoIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsIm1vZGVsc1RvQWRkIiwicHJvdmlkZXIiLCJwcm92aWRlcktleSIsImlzVXNpbmdFbnZLZXlNYXAiLCJtb2RlbHMiLCJBcnJheSIsImlzQXJyYXkiLCJlbnZLZXlNYXAiLCJob3N0ZWRNb2RlbHMiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiZmV0Y2hPbGxhbWFNb2RlbHMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfT0xMQU1BX1VSTCIsImxvY2FsTW9kZWxzIiwibWFwIiwibW9kZWwiLCJtb2RlbElkIiwibmFtZSIsIm1vZGVsTmFtZSIsImhvc3RlZElkIiwicGxhdGZvcm1MaW5rIiwiaW1hZ2VJbnB1dCIsImZldGNoT3BlblJvdXRlck1vZGVscyIsIm9wZW5Sb3V0ZXJNb2RlbHMiLCJpZCIsIm1heENvbnRleHQiLCJjb250ZXh0X2xlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/models/fetch-models.ts\n"));

/***/ })

});