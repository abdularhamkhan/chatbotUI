"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@apidevtools";
exports.ids = ["vendor-chunks/@apidevtools"];
exports.modules = {

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nexports[\"default\"] = bundle;\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param parser\n * @param options\n */ function bundle(parser, options) {\n    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n    // Build an inventory of all $ref pointers in the JSON Schema\n    const inventory = [];\n    crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n    // Remap all $ref pointers\n    remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param key - The property key of `parent` to be crawled\n * @param path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of the property being crawled, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */ function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const obj = key === null ? parent : parent[key];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n        // @ts-expect-error TS(2554): Expected 2 arguments, but got 1.\n        if (ref_js_1.default.isAllowed$Ref(obj)) {\n            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n        } else {\n            // Crawl the object in a specific order that's optimized for bundling.\n            // This is important because it determines how `pathFromRoot` gets built,\n            // which later determines which keys get dereferenced and which ones get remapped\n            const keys = Object.keys(obj).sort((a, b)=>{\n                // Most people will expect references to be bundled into the the \"definitions\" property,\n                // so we always crawl that property first, if it exists.\n                if (a === \"definitions\") {\n                    return -1;\n                } else if (b === \"definitions\") {\n                    return 1;\n                } else {\n                    // Otherwise, crawl the keys based on their length.\n                    // This produces the shortest possible bundled references\n                    return a.length - b.length;\n                }\n            });\n            // eslint-disable-next-line no-shadow\n            for (const key of keys){\n                const keyPath = pointer_js_1.default.join(path, key);\n                const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                const value = obj[key];\n                // @ts-expect-error TS(2554): Expected 2 arguments, but got 1.\n                if (ref_js_1.default.isAllowed$Ref(value)) {\n                    inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n                } else {\n                    crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n            }\n        }\n    }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param $refParent - The object that contains a JSON Reference as one of its keys\n * @param $refKey - The key in `$refParent` that is a JSON Reference\n * @param path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param indirections - unknown\n * @param pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */ function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const $ref = $refKey === null ? $refParent : $refParent[$refKey];\n    const $refPath = url.resolve(path, $ref.$ref);\n    const pointer = $refs._resolve($refPath, pathFromRoot, options);\n    if (pointer === null) {\n        return;\n    }\n    const depth = pointer_js_1.default.parse(pathFromRoot).length;\n    const file = url.stripHash(pointer.path);\n    const hash = url.getHash(pointer.path);\n    const external = file !== $refs._root$Ref.path;\n    const extended = ref_js_1.default.isExtended$Ref($ref);\n    indirections += pointer.indirections;\n    const existingEntry = findInInventory(inventory, $refParent, $refKey);\n    if (existingEntry) {\n        // This $Ref has already been inventoried, so we don't need to process it again\n        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n            removeFromInventory(inventory, existingEntry);\n        } else {\n            return;\n        }\n    }\n    inventory.push({\n        $ref,\n        parent: $refParent,\n        key: $refKey,\n        pathFromRoot,\n        depth,\n        file,\n        hash,\n        value: pointer.value,\n        circular: pointer.circular,\n        extended,\n        external,\n        indirections\n    });\n    // Recursively crawl the resolved value\n    if (!existingEntry || external) {\n        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n    }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example: {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param inventory\n */ function remap(inventory) {\n    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n    inventory.sort((a, b)=>{\n        if (a.file !== b.file) {\n            // Group all the $refs that point to the same file\n            return a.file < b.file ? -1 : +1;\n        } else if (a.hash !== b.hash) {\n            // Group all the $refs that point to the same part of the file\n            return a.hash < b.hash ? -1 : +1;\n        } else if (a.circular !== b.circular) {\n            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n            return a.circular ? -1 : +1;\n        } else if (a.extended !== b.extended) {\n            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n            return a.extended ? +1 : -1;\n        } else if (a.indirections !== b.indirections) {\n            // Sort direct references higher than indirect references\n            return a.indirections - b.indirections;\n        } else if (a.depth !== b.depth) {\n            // Sort $refs by how close they are to the JSON Schema root\n            return a.depth - b.depth;\n        } else {\n            // Determine how far each $ref is from the \"definitions\" property.\n            // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n            const aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n            const bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n            if (aDefinitionsIndex !== bDefinitionsIndex) {\n                // Give higher priority to the $ref that's closer to the \"definitions\" property\n                return bDefinitionsIndex - aDefinitionsIndex;\n            } else {\n                // All else is equal, so use the shorter path, which will produce the shortest possible reference\n                return a.pathFromRoot.length - b.pathFromRoot.length;\n            }\n        }\n    });\n    let file, hash, pathFromRoot;\n    for (const entry of inventory){\n        // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n        if (!entry.external) {\n            // This $ref already resolves to the main JSON Schema file\n            entry.$ref.$ref = entry.hash;\n        } else if (entry.file === file && entry.hash === hash) {\n            // This $ref points to the same value as the prevous $ref, so remap it to the same path\n            entry.$ref.$ref = pathFromRoot;\n        } else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n            // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n            entry.$ref.$ref = pointer_js_1.default.join(pathFromRoot, pointer_js_1.default.parse(entry.hash.replace(hash, \"#\")));\n        } else {\n            // We've moved to a new file or new hash\n            file = entry.file;\n            hash = entry.hash;\n            pathFromRoot = entry.pathFromRoot;\n            // This is the first $ref to point to this value, so dereference the value.\n            // Any other $refs that point to the same value will point to this $ref instead\n            entry.$ref = entry.parent[entry.key] = ref_js_1.default.dereference(entry.$ref, entry.value);\n            if (entry.circular) {\n                // This $ref points to itself\n                entry.$ref.$ref = entry.pathFromRoot;\n            }\n        }\n    // console.log('    new value: %s', (entry.$ref && entry.$ref.$ref) ? entry.$ref.$ref : '[object Object]');\n    }\n}\n/**\n * TODO\n */ function findInInventory(inventory, $refParent, $refKey) {\n    for(let i = 0; i < inventory.length; i++){\n        const existingEntry = inventory[i];\n        if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n            return existingEntry;\n        }\n    }\n}\nfunction removeFromInventory(inventory, entry) {\n    const index = inventory.indexOf(entry);\n    inventory.splice(index, 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFNQyxDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUMxRixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQixJQUFJRyxPQUFPUCxPQUFPUSx3QkFBd0IsQ0FBQ0wsR0FBR0M7SUFDOUMsSUFBSSxDQUFDRyxRQUFTLFVBQVNBLE9BQU8sQ0FBQ0osRUFBRU0sVUFBVSxHQUFHRixLQUFLRyxRQUFRLElBQUlILEtBQUtJLFlBQVksR0FBRztRQUNqRkosT0FBTztZQUFFSyxZQUFZO1lBQU1DLEtBQUs7Z0JBQWEsT0FBT1YsQ0FBQyxDQUFDQyxFQUFFO1lBQUU7UUFBRTtJQUM5RDtJQUNBSixPQUFPYyxjQUFjLENBQUNaLEdBQUdHLElBQUlFO0FBQ2pDLElBQU0sU0FBU0wsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSVcscUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1mLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVjLENBQUM7SUFDekZoQixPQUFPYyxjQUFjLENBQUNaLEdBQUcsV0FBVztRQUFFVSxZQUFZO1FBQU1LLE9BQU9EO0lBQUU7QUFDckUsSUFBSyxTQUFTZCxDQUFDLEVBQUVjLENBQUM7SUFDZGQsQ0FBQyxDQUFDLFVBQVUsR0FBR2M7QUFDbkI7QUFDQSxJQUFJRSxlQUFlLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsWUFBWSxJQUFLLFNBQVVDLEdBQUc7SUFDM0QsSUFBSUEsT0FBT0EsSUFBSVYsVUFBVSxFQUFFLE9BQU9VO0lBQ2xDLElBQUlDLFNBQVMsQ0FBQztJQUNkLElBQUlELE9BQU8sTUFBTTtRQUFBLElBQUssSUFBSWYsS0FBS2UsSUFBSyxJQUFJZixNQUFNLGFBQWFKLE9BQU9xQixTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLZixJQUFJTCxnQkFBZ0JxQixRQUFRRCxLQUFLZjtJQUFFO0lBQ3hJVyxtQkFBbUJLLFFBQVFEO0lBQzNCLE9BQU9DO0FBQ1g7QUFDQSxJQUFJSSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUwsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlWLFVBQVUsR0FBSVUsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQW5CLDhDQUE2QztJQUFFaUIsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNUyxXQUFXRixnQkFBZ0JHLG1CQUFPQSxDQUFDLDBGQUFVO0FBQ25ELE1BQU1DLGVBQWVKLGdCQUFnQkcsbUJBQU9BLENBQUMsa0dBQWM7QUFDM0QsTUFBTUUsTUFBTVgsYUFBYVMsbUJBQU9BLENBQUMsb0dBQWU7QUFDaERGLGtCQUFlLEdBQUdNO0FBQ2xCOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQSxPQUFPQyxNQUFNLEVBQUVDLE9BQU87SUFDM0IsNEVBQTRFO0lBQzVFLDZEQUE2RDtJQUM3RCxNQUFNQyxZQUFZLEVBQUU7SUFDcEJDLE1BQU1ILFFBQVEsVUFBVUEsT0FBT0ksS0FBSyxDQUFDQyxTQUFTLENBQUNDLElBQUksR0FBRyxLQUFLLEtBQUssR0FBR0osV0FBV0YsT0FBT0ksS0FBSyxFQUFFSDtJQUM1RiwwQkFBMEI7SUFDMUJNLE1BQU1MO0FBQ1Y7QUFDQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsU0FBU0MsTUFBTUssTUFBTSxFQUFFQyxHQUFHLEVBQUVILElBQUksRUFBRUksWUFBWSxFQUFFQyxZQUFZLEVBQUVULFNBQVMsRUFBRUUsS0FBSyxFQUFFSCxPQUFPO0lBQ25GLE1BQU1XLE1BQU1ILFFBQVEsT0FBT0QsU0FBU0EsTUFBTSxDQUFDQyxJQUFJO0lBQy9DLElBQUlHLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUNDLFlBQVlDLE1BQU0sQ0FBQ0YsTUFBTTtRQUM1RCw4REFBOEQ7UUFDOUQsSUFBSWxCLFNBQVNJLE9BQU8sQ0FBQ2lCLGFBQWEsQ0FBQ0gsTUFBTTtZQUNyQ0ksY0FBY1IsUUFBUUMsS0FBS0gsTUFBTUksY0FBY0MsY0FBY1QsV0FBV0UsT0FBT0g7UUFDbkYsT0FDSztZQUNELHNFQUFzRTtZQUN0RSx5RUFBeUU7WUFDekUsaUZBQWlGO1lBQ2pGLE1BQU1nQixPQUFPakQsT0FBT2lELElBQUksQ0FBQ0wsS0FBS00sSUFBSSxDQUFDLENBQUNDLEdBQUdDO2dCQUNuQyx3RkFBd0Y7Z0JBQ3hGLHdEQUF3RDtnQkFDeEQsSUFBSUQsTUFBTSxlQUFlO29CQUNyQixPQUFPLENBQUM7Z0JBQ1osT0FDSyxJQUFJQyxNQUFNLGVBQWU7b0JBQzFCLE9BQU87Z0JBQ1gsT0FDSztvQkFDRCxtREFBbUQ7b0JBQ25ELHlEQUF5RDtvQkFDekQsT0FBT0QsRUFBRUUsTUFBTSxHQUFHRCxFQUFFQyxNQUFNO2dCQUM5QjtZQUNKO1lBQ0EscUNBQXFDO1lBQ3JDLEtBQUssTUFBTVosT0FBT1EsS0FBTTtnQkFDcEIsTUFBTUssVUFBVTFCLGFBQWFFLE9BQU8sQ0FBQ3lCLElBQUksQ0FBQ2pCLE1BQU1HO2dCQUNoRCxNQUFNZSxrQkFBa0I1QixhQUFhRSxPQUFPLENBQUN5QixJQUFJLENBQUNiLGNBQWNEO2dCQUNoRSxNQUFNeEIsUUFBUTJCLEdBQUcsQ0FBQ0gsSUFBSTtnQkFDdEIsOERBQThEO2dCQUM5RCxJQUFJZixTQUFTSSxPQUFPLENBQUNpQixhQUFhLENBQUM5QixRQUFRO29CQUN2QytCLGNBQWNKLEtBQUtILEtBQUtILE1BQU1rQixpQkFBaUJiLGNBQWNULFdBQVdFLE9BQU9IO2dCQUNuRixPQUNLO29CQUNERSxNQUFNUyxLQUFLSCxLQUFLYSxTQUFTRSxpQkFBaUJiLGNBQWNULFdBQVdFLE9BQU9IO2dCQUM5RTtZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsU0FBU2UsY0FBY1MsVUFBVSxFQUFFQyxPQUFPLEVBQUVwQixJQUFJLEVBQUVJLFlBQVksRUFBRUMsWUFBWSxFQUFFVCxTQUFTLEVBQUVFLEtBQUssRUFBRUgsT0FBTztJQUNuRyxNQUFNMEIsT0FBT0QsWUFBWSxPQUFPRCxhQUFhQSxVQUFVLENBQUNDLFFBQVE7SUFDaEUsTUFBTUUsV0FBVy9CLElBQUlnQyxPQUFPLENBQUN2QixNQUFNcUIsS0FBS0EsSUFBSTtJQUM1QyxNQUFNRyxVQUFVMUIsTUFBTTJCLFFBQVEsQ0FBQ0gsVUFBVWxCLGNBQWNUO0lBQ3ZELElBQUk2QixZQUFZLE1BQU07UUFDbEI7SUFDSjtJQUNBLE1BQU1FLFFBQVFwQyxhQUFhRSxPQUFPLENBQUNtQyxLQUFLLENBQUN2QixjQUFjVyxNQUFNO0lBQzdELE1BQU1hLE9BQU9yQyxJQUFJc0MsU0FBUyxDQUFDTCxRQUFReEIsSUFBSTtJQUN2QyxNQUFNOEIsT0FBT3ZDLElBQUl3QyxPQUFPLENBQUNQLFFBQVF4QixJQUFJO0lBQ3JDLE1BQU1nQyxXQUFXSixTQUFTOUIsTUFBTUMsU0FBUyxDQUFDQyxJQUFJO0lBQzlDLE1BQU1pQyxXQUFXN0MsU0FBU0ksT0FBTyxDQUFDMEMsY0FBYyxDQUFDYjtJQUNqRGhCLGdCQUFnQm1CLFFBQVFuQixZQUFZO0lBQ3BDLE1BQU04QixnQkFBZ0JDLGdCQUFnQnhDLFdBQVd1QixZQUFZQztJQUM3RCxJQUFJZSxlQUFlO1FBQ2YsK0VBQStFO1FBQy9FLElBQUlULFFBQVFTLGNBQWNULEtBQUssSUFBSXJCLGVBQWU4QixjQUFjOUIsWUFBWSxFQUFFO1lBQzFFZ0Msb0JBQW9CekMsV0FBV3VDO1FBQ25DLE9BQ0s7WUFDRDtRQUNKO0lBQ0o7SUFDQXZDLFVBQVUwQyxJQUFJLENBQUM7UUFDWGpCO1FBQ0FuQixRQUFRaUI7UUFDUmhCLEtBQUtpQjtRQUNMaEI7UUFDQXNCO1FBQ0FFO1FBQ0FFO1FBQ0FuRCxPQUFPNkMsUUFBUTdDLEtBQUs7UUFDcEI0RCxVQUFVZixRQUFRZSxRQUFRO1FBQzFCTjtRQUNBRDtRQUNBM0I7SUFDSjtJQUNBLHVDQUF1QztJQUN2QyxJQUFJLENBQUM4QixpQkFBaUJILFVBQVU7UUFDNUJuQyxNQUFNMkIsUUFBUTdDLEtBQUssRUFBRSxNQUFNNkMsUUFBUXhCLElBQUksRUFBRUksY0FBY0MsZUFBZSxHQUFHVCxXQUFXRSxPQUFPSDtJQUMvRjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNELFNBQVNNLE1BQU1MLFNBQVM7SUFDcEIscUdBQXFHO0lBQ3JHQSxVQUFVZ0IsSUFBSSxDQUFDLENBQUNDLEdBQUdDO1FBQ2YsSUFBSUQsRUFBRWUsSUFBSSxLQUFLZCxFQUFFYyxJQUFJLEVBQUU7WUFDbkIsa0RBQWtEO1lBQ2xELE9BQU9mLEVBQUVlLElBQUksR0FBR2QsRUFBRWMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQ25DLE9BQ0ssSUFBSWYsRUFBRWlCLElBQUksS0FBS2hCLEVBQUVnQixJQUFJLEVBQUU7WUFDeEIsOERBQThEO1lBQzlELE9BQU9qQixFQUFFaUIsSUFBSSxHQUFHaEIsRUFBRWdCLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQztRQUNuQyxPQUNLLElBQUlqQixFQUFFMEIsUUFBUSxLQUFLekIsRUFBRXlCLFFBQVEsRUFBRTtZQUNoQyw2RkFBNkY7WUFDN0YsT0FBTzFCLEVBQUUwQixRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUM7UUFDOUIsT0FDSyxJQUFJMUIsRUFBRW9CLFFBQVEsS0FBS25CLEVBQUVtQixRQUFRLEVBQUU7WUFDaEMsMEdBQTBHO1lBQzFHLE9BQU9wQixFQUFFb0IsUUFBUSxHQUFHLENBQUMsSUFBSSxDQUFDO1FBQzlCLE9BQ0ssSUFBSXBCLEVBQUVSLFlBQVksS0FBS1MsRUFBRVQsWUFBWSxFQUFFO1lBQ3hDLHlEQUF5RDtZQUN6RCxPQUFPUSxFQUFFUixZQUFZLEdBQUdTLEVBQUVULFlBQVk7UUFDMUMsT0FDSyxJQUFJUSxFQUFFYSxLQUFLLEtBQUtaLEVBQUVZLEtBQUssRUFBRTtZQUMxQiwyREFBMkQ7WUFDM0QsT0FBT2IsRUFBRWEsS0FBSyxHQUFHWixFQUFFWSxLQUFLO1FBQzVCLE9BQ0s7WUFDRCxrRUFBa0U7WUFDbEUsb0dBQW9HO1lBQ3BHLE1BQU1jLG9CQUFvQjNCLEVBQUVULFlBQVksQ0FBQ3FDLFdBQVcsQ0FBQztZQUNyRCxNQUFNQyxvQkFBb0I1QixFQUFFVixZQUFZLENBQUNxQyxXQUFXLENBQUM7WUFDckQsSUFBSUQsc0JBQXNCRSxtQkFBbUI7Z0JBQ3pDLCtFQUErRTtnQkFDL0UsT0FBT0Esb0JBQW9CRjtZQUMvQixPQUNLO2dCQUNELGlHQUFpRztnQkFDakcsT0FBTzNCLEVBQUVULFlBQVksQ0FBQ1csTUFBTSxHQUFHRCxFQUFFVixZQUFZLENBQUNXLE1BQU07WUFDeEQ7UUFDSjtJQUNKO0lBQ0EsSUFBSWEsTUFBTUUsTUFBTTFCO0lBQ2hCLEtBQUssTUFBTXVDLFNBQVMvQyxVQUFXO1FBQzNCLDBGQUEwRjtRQUMxRixJQUFJLENBQUMrQyxNQUFNWCxRQUFRLEVBQUU7WUFDakIsMERBQTBEO1lBQzFEVyxNQUFNdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUdzQixNQUFNYixJQUFJO1FBQ2hDLE9BQ0ssSUFBSWEsTUFBTWYsSUFBSSxLQUFLQSxRQUFRZSxNQUFNYixJQUFJLEtBQUtBLE1BQU07WUFDakQsdUZBQXVGO1lBQ3ZGYSxNQUFNdEIsSUFBSSxDQUFDQSxJQUFJLEdBQUdqQjtRQUN0QixPQUNLLElBQUl1QyxNQUFNZixJQUFJLEtBQUtBLFFBQVFlLE1BQU1iLElBQUksQ0FBQ2MsT0FBTyxDQUFDZCxPQUFPLFNBQVMsR0FBRztZQUNsRSxxRkFBcUY7WUFDckZhLE1BQU10QixJQUFJLENBQUNBLElBQUksR0FBRy9CLGFBQWFFLE9BQU8sQ0FBQ3lCLElBQUksQ0FBQ2IsY0FBY2QsYUFBYUUsT0FBTyxDQUFDbUMsS0FBSyxDQUFDZ0IsTUFBTWIsSUFBSSxDQUFDZSxPQUFPLENBQUNmLE1BQU07UUFDbEgsT0FDSztZQUNELHdDQUF3QztZQUN4Q0YsT0FBT2UsTUFBTWYsSUFBSTtZQUNqQkUsT0FBT2EsTUFBTWIsSUFBSTtZQUNqQjFCLGVBQWV1QyxNQUFNdkMsWUFBWTtZQUNqQywyRUFBMkU7WUFDM0UsK0VBQStFO1lBQy9FdUMsTUFBTXRCLElBQUksR0FBR3NCLE1BQU16QyxNQUFNLENBQUN5QyxNQUFNeEMsR0FBRyxDQUFDLEdBQUdmLFNBQVNJLE9BQU8sQ0FBQ3NELFdBQVcsQ0FBQ0gsTUFBTXRCLElBQUksRUFBRXNCLE1BQU1oRSxLQUFLO1lBQzNGLElBQUlnRSxNQUFNSixRQUFRLEVBQUU7Z0JBQ2hCLDZCQUE2QjtnQkFDN0JJLE1BQU10QixJQUFJLENBQUNBLElBQUksR0FBR3NCLE1BQU12QyxZQUFZO1lBQ3hDO1FBQ0o7SUFDQSwyR0FBMkc7SUFDL0c7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU2dDLGdCQUFnQnhDLFNBQVMsRUFBRXVCLFVBQVUsRUFBRUMsT0FBTztJQUNuRCxJQUFLLElBQUkyQixJQUFJLEdBQUdBLElBQUluRCxVQUFVbUIsTUFBTSxFQUFFZ0MsSUFBSztRQUN2QyxNQUFNWixnQkFBZ0J2QyxTQUFTLENBQUNtRCxFQUFFO1FBQ2xDLElBQUlaLGNBQWNqQyxNQUFNLEtBQUtpQixjQUFjZ0IsY0FBY2hDLEdBQUcsS0FBS2lCLFNBQVM7WUFDdEUsT0FBT2U7UUFDWDtJQUNKO0FBQ0o7QUFDQSxTQUFTRSxvQkFBb0J6QyxTQUFTLEVBQUUrQyxLQUFLO0lBQ3pDLE1BQU1LLFFBQVFwRCxVQUFVZ0QsT0FBTyxDQUFDRDtJQUNoQy9DLFVBQVVxRCxNQUFNLENBQUNELE9BQU87QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL2J1bmRsZS5qcz9lNDczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWZfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZWYuanNcIikpO1xuY29uc3QgcG9pbnRlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BvaW50ZXIuanNcIikpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWwvdXJsLmpzXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1bmRsZTtcbi8qKlxuICogQnVuZGxlcyBhbGwgZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2VzIGludG8gdGhlIG1haW4gSlNPTiBzY2hlbWEsIHRodXMgcmVzdWx0aW5nIGluIGEgc2NoZW1hIHRoYXRcbiAqIG9ubHkgaGFzICppbnRlcm5hbCogcmVmZXJlbmNlcywgbm90IGFueSAqZXh0ZXJuYWwqIHJlZmVyZW5jZXMuXG4gKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSBKU09OIHNjaGVtYSBvYmplY3QsIGFkZGluZyBuZXcgcmVmZXJlbmNlcyBhbmQgcmUtbWFwcGluZyBleGlzdGluZyBvbmVzLlxuICpcbiAqIEBwYXJhbSBwYXJzZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGJ1bmRsZShwYXJzZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnQnVuZGxpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCk7XG4gICAgLy8gQnVpbGQgYW4gaW52ZW50b3J5IG9mIGFsbCAkcmVmIHBvaW50ZXJzIGluIHRoZSBKU09OIFNjaGVtYVxuICAgIGNvbnN0IGludmVudG9yeSA9IFtdO1xuICAgIGNyYXdsKHBhcnNlciwgXCJzY2hlbWFcIiwgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoICsgXCIjXCIsIFwiI1wiLCAwLCBpbnZlbnRvcnksIHBhcnNlci4kcmVmcywgb3B0aW9ucyk7XG4gICAgLy8gUmVtYXAgYWxsICRyZWYgcG9pbnRlcnNcbiAgICByZW1hcChpbnZlbnRvcnkpO1xufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjcmF3bHMgdGhlIGdpdmVuIHZhbHVlLCBhbmQgaW52ZW50b3JpZXMgYWxsIEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSB2YWx1ZSB0byBjcmF3bC4gSWYgdGhlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUgcHJvcGVydHkga2V5IG9mIGBwYXJlbnRgIHRvIGJlIGNyYXdsZWRcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY3Jhd2xlZCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBjcmF3bGVkLCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIGludmVudG9yeSAtIEFuIGFycmF5IG9mIGFscmVhZHktaW52ZW50b3JpZWQgJHJlZiBwb2ludGVyc1xuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBjcmF3bChwYXJlbnQsIGtleSwgcGF0aCwgcGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvYmogPSBrZXkgPT09IG51bGwgPyBwYXJlbnQgOiBwYXJlbnRba2V5XTtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhvYmopKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMoMjU1NCk6IEV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZ290IDEuXG4gICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYob2JqKSkge1xuICAgICAgICAgICAgaW52ZW50b3J5JFJlZihwYXJlbnQsIGtleSwgcGF0aCwgcGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Jhd2wgdGhlIG9iamVjdCBpbiBhIHNwZWNpZmljIG9yZGVyIHRoYXQncyBvcHRpbWl6ZWQgZm9yIGJ1bmRsaW5nLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSBpdCBkZXRlcm1pbmVzIGhvdyBgcGF0aEZyb21Sb290YCBnZXRzIGJ1aWx0LFxuICAgICAgICAgICAgLy8gd2hpY2ggbGF0ZXIgZGV0ZXJtaW5lcyB3aGljaCBrZXlzIGdldCBkZXJlZmVyZW5jZWQgYW5kIHdoaWNoIG9uZXMgZ2V0IHJlbWFwcGVkXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTW9zdCBwZW9wbGUgd2lsbCBleHBlY3QgcmVmZXJlbmNlcyB0byBiZSBidW5kbGVkIGludG8gdGhlIHRoZSBcImRlZmluaXRpb25zXCIgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgYWx3YXlzIGNyYXdsIHRoYXQgcHJvcGVydHkgZmlyc3QsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgICAgICBpZiAoYSA9PT0gXCJkZWZpbml0aW9uc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYiA9PT0gXCJkZWZpbml0aW9uc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmF3bCB0aGUga2V5cyBiYXNlZCBvbiB0aGVpciBsZW5ndGguXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJvZHVjZXMgdGhlIHNob3J0ZXN0IHBvc3NpYmxlIGJ1bmRsZWQgcmVmZXJlbmNlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoID0gcG9pbnRlcl9qc18xLmRlZmF1bHQuam9pbihwYXRoLCBrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhdGhGcm9tUm9vdCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aEZyb21Sb290LCBrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUygyNTU0KTogRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBnb3QgMS5cbiAgICAgICAgICAgICAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZlbnRvcnkkUmVmKG9iaiwga2V5LCBwYXRoLCBrZXlQYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucywgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcmF3bChvYmosIGtleSwga2V5UGF0aCwga2V5UGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogSW52ZW50b3JpZXMgdGhlIGdpdmVuIEpTT04gUmVmZXJlbmNlIChpLmUuIHJlY29yZHMgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgaXQgc28gd2UgY2FuXG4gKiBvcHRpbWl6ZSBhbGwgJHJlZnMgaW4gdGhlIHNjaGVtYSksIGFuZCB0aGVuIGNyYXdscyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtICRyZWZQYXJlbnQgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgYSBKU09OIFJlZmVyZW5jZSBhcyBvbmUgb2YgaXRzIGtleXNcbiAqIEBwYXJhbSAkcmVmS2V5IC0gVGhlIGtleSBpbiBgJHJlZlBhcmVudGAgdGhhdCBpcyBhIEpTT04gUmVmZXJlbmNlXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgdGhlIEpTT04gUmVmZXJlbmNlIGF0IGAkcmVmS2V5YCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIGluZGlyZWN0aW9ucyAtIHVua25vd25cbiAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiB0aGUgSlNPTiBSZWZlcmVuY2UgYXQgYCRyZWZLZXlgLCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIGludmVudG9yeSAtIEFuIGFycmF5IG9mIGFscmVhZHktaW52ZW50b3JpZWQgJHJlZiBwb2ludGVyc1xuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBpbnZlbnRvcnkkUmVmKCRyZWZQYXJlbnQsICRyZWZLZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgJHJlZiA9ICRyZWZLZXkgPT09IG51bGwgPyAkcmVmUGFyZW50IDogJHJlZlBhcmVudFskcmVmS2V5XTtcbiAgICBjb25zdCAkcmVmUGF0aCA9IHVybC5yZXNvbHZlKHBhdGgsICRyZWYuJHJlZik7XG4gICAgY29uc3QgcG9pbnRlciA9ICRyZWZzLl9yZXNvbHZlKCRyZWZQYXRoLCBwYXRoRnJvbVJvb3QsIG9wdGlvbnMpO1xuICAgIGlmIChwb2ludGVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVwdGggPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5wYXJzZShwYXRoRnJvbVJvb3QpLmxlbmd0aDtcbiAgICBjb25zdCBmaWxlID0gdXJsLnN0cmlwSGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGhhc2ggPSB1cmwuZ2V0SGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGV4dGVybmFsID0gZmlsZSAhPT0gJHJlZnMuX3Jvb3QkUmVmLnBhdGg7XG4gICAgY29uc3QgZXh0ZW5kZWQgPSByZWZfanNfMS5kZWZhdWx0LmlzRXh0ZW5kZWQkUmVmKCRyZWYpO1xuICAgIGluZGlyZWN0aW9ucyArPSBwb2ludGVyLmluZGlyZWN0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gZmluZEluSW52ZW50b3J5KGludmVudG9yeSwgJHJlZlBhcmVudCwgJHJlZktleSk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyAkUmVmIGhhcyBhbHJlYWR5IGJlZW4gaW52ZW50b3JpZWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VzcyBpdCBhZ2FpblxuICAgICAgICBpZiAoZGVwdGggPCBleGlzdGluZ0VudHJ5LmRlcHRoIHx8IGluZGlyZWN0aW9ucyA8IGV4aXN0aW5nRW50cnkuaW5kaXJlY3Rpb25zKSB7XG4gICAgICAgICAgICByZW1vdmVGcm9tSW52ZW50b3J5KGludmVudG9yeSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52ZW50b3J5LnB1c2goe1xuICAgICAgICAkcmVmLFxuICAgICAgICBwYXJlbnQ6ICRyZWZQYXJlbnQsXG4gICAgICAgIGtleTogJHJlZktleSxcbiAgICAgICAgcGF0aEZyb21Sb290LFxuICAgICAgICBkZXB0aCxcbiAgICAgICAgZmlsZSxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgdmFsdWU6IHBvaW50ZXIudmFsdWUsXG4gICAgICAgIGNpcmN1bGFyOiBwb2ludGVyLmNpcmN1bGFyLFxuICAgICAgICBleHRlbmRlZCxcbiAgICAgICAgZXh0ZXJuYWwsXG4gICAgICAgIGluZGlyZWN0aW9ucywgLy8gVGhlIG51bWJlciBvZiBpbmRpcmVjdCByZWZlcmVuY2VzIHRoYXQgd2VyZSB0cmF2ZXJzZWQgdG8gcmVzb2x2ZSB0aGUgdmFsdWVcbiAgICB9KTtcbiAgICAvLyBSZWN1cnNpdmVseSBjcmF3bCB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICBpZiAoIWV4aXN0aW5nRW50cnkgfHwgZXh0ZXJuYWwpIHtcbiAgICAgICAgY3Jhd2wocG9pbnRlci52YWx1ZSwgbnVsbCwgcG9pbnRlci5wYXRoLCBwYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucyArIDEsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbi8qKlxuICogUmUtbWFwcyBldmVyeSAkcmVmIHBvaW50ZXIsIHNvIHRoYXQgdGhleSdyZSBhbGwgcmVsYXRpdmUgdG8gdGhlIHJvb3Qgb2YgdGhlIEpTT04gU2NoZW1hLlxuICogRWFjaCByZWZlcmVuY2VkIHZhbHVlIGlzIGRlcmVmZXJlbmNlZCBFWEFDVExZIE9OQ0UuICBBbGwgc3Vic2VxdWVudCByZWZlcmVuY2VzIHRvIHRoZSBzYW1lXG4gKiB2YWx1ZSBhcmUgcmUtbWFwcGVkIHRvIHBvaW50IHRvIHRoZSBmaXJzdCByZWZlcmVuY2UuXG4gKlxuICogQGV4YW1wbGU6IHtcbiAqICAgIGZpcnN0OiB7ICRyZWY6IHNvbWVmaWxlLmpzb24jL3NvbWUvcGFydCB9LFxuICogICAgc2Vjb25kOiB7ICRyZWY6IHNvbWVmaWxlLmpzb24jL2Fub3RoZXIvcGFydCB9LFxuICogICAgdGhpcmQ6IHsgJHJlZjogc29tZWZpbGUuanNvbiB9LFxuICogICAgZm91cnRoOiB7ICRyZWY6IHNvbWVmaWxlLmpzb24jL3NvbWUvcGFydC9zdWIvcGFydCB9XG4gKiAgfVxuICpcbiAqIEluIHRoaXMgZXhhbXBsZSwgdGhlcmUgYXJlIGZvdXIgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBmaWxlLCBidXQgc2luY2UgdGhlIHRoaXJkIHJlZmVyZW5jZSBwb2ludHNcbiAqIHRvIHRoZSBFTlRJUkUgZmlsZSwgdGhhdCdzIHRoZSBvbmx5IG9uZSB3ZSBuZWVkIHRvIGRlcmVmZXJlbmNlLiAgVGhlIG90aGVyIHRocmVlIGNhbiBqdXN0IGJlXG4gKiByZW1hcHBlZCB0byBwb2ludCBpbnNpZGUgdGhlIHRoaXJkIG9uZS5cbiAqXG4gKiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgdGhlIHRoaXJkIHJlZmVyZW5jZSBESUROJ1QgZXhpc3QsIHRoZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgd291bGQgYm90aCBuZWVkXG4gKiB0byBiZSBkZXJlZmVyZW5jZWQsIHNpbmNlIHRoZXkgcG9pbnQgdG8gZGlmZmVyZW50IHBhcnRzIG9mIHRoZSBmaWxlLiBUaGUgZm91cnRoIHJlZmVyZW5jZSBkb2VzIE5PVFxuICogbmVlZCB0byBiZSBkZXJlZmVyZW5jZWQsIGJlY2F1c2UgaXQgY2FuIGJlIHJlbWFwcGVkIHRvIHBvaW50IGluc2lkZSB0aGUgZmlyc3Qgb25lLlxuICpcbiAqIEBwYXJhbSBpbnZlbnRvcnlcbiAqL1xuZnVuY3Rpb24gcmVtYXAoaW52ZW50b3J5KSB7XG4gICAgLy8gR3JvdXAgJiBzb3J0IGFsbCB0aGUgJHJlZiBwb2ludGVycywgc28gdGhleSdyZSBpbiB0aGUgb3JkZXIgdGhhdCB3ZSBuZWVkIHRvIGRlcmVmZXJlbmNlL3JlbWFwIHRoZW1cbiAgICBpbnZlbnRvcnkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBpZiAoYS5maWxlICE9PSBiLmZpbGUpIHtcbiAgICAgICAgICAgIC8vIEdyb3VwIGFsbCB0aGUgJHJlZnMgdGhhdCBwb2ludCB0byB0aGUgc2FtZSBmaWxlXG4gICAgICAgICAgICByZXR1cm4gYS5maWxlIDwgYi5maWxlID8gLTEgOiArMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmhhc2ggIT09IGIuaGFzaCkge1xuICAgICAgICAgICAgLy8gR3JvdXAgYWxsIHRoZSAkcmVmcyB0aGF0IHBvaW50IHRvIHRoZSBzYW1lIHBhcnQgb2YgdGhlIGZpbGVcbiAgICAgICAgICAgIHJldHVybiBhLmhhc2ggPCBiLmhhc2ggPyAtMSA6ICsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuY2lyY3VsYXIgIT09IGIuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSAkcmVmIHBvaW50cyB0byBpdHNlbGYsIHRoZW4gc29ydCBpdCBoaWdoZXIgdGhhbiBvdGhlciAkcmVmcyB0aGF0IHBvaW50IHRvIHRoaXMgJHJlZlxuICAgICAgICAgICAgcmV0dXJuIGEuY2lyY3VsYXIgPyAtMSA6ICsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuZXh0ZW5kZWQgIT09IGIuZXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSAkcmVmIGV4dGVuZHMgdGhlIHJlc29sdmVkIHZhbHVlLCB0aGVuIHNvcnQgaXQgbG93ZXIgdGhhbiBvdGhlciAkcmVmcyB0aGF0IGRvbid0IGV4dGVuZCB0aGUgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiBhLmV4dGVuZGVkID8gKzEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmluZGlyZWN0aW9ucyAhPT0gYi5pbmRpcmVjdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFNvcnQgZGlyZWN0IHJlZmVyZW5jZXMgaGlnaGVyIHRoYW4gaW5kaXJlY3QgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIGEuaW5kaXJlY3Rpb25zIC0gYi5pbmRpcmVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5kZXB0aCAhPT0gYi5kZXB0aCkge1xuICAgICAgICAgICAgLy8gU29ydCAkcmVmcyBieSBob3cgY2xvc2UgdGhleSBhcmUgdG8gdGhlIEpTT04gU2NoZW1hIHJvb3RcbiAgICAgICAgICAgIHJldHVybiBhLmRlcHRoIC0gYi5kZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSBob3cgZmFyIGVhY2ggJHJlZiBpcyBmcm9tIHRoZSBcImRlZmluaXRpb25zXCIgcHJvcGVydHkuXG4gICAgICAgICAgICAvLyBNb3N0IHBlb3BsZSB3aWxsIGV4cGVjdCByZWZlcmVuY2VzIHRvIGJlIGJ1bmRsZWQgaW50byB0aGUgdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eSBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGFEZWZpbml0aW9uc0luZGV4ID0gYS5wYXRoRnJvbVJvb3QubGFzdEluZGV4T2YoXCIvZGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICBjb25zdCBiRGVmaW5pdGlvbnNJbmRleCA9IGIucGF0aEZyb21Sb290Lmxhc3RJbmRleE9mKFwiL2RlZmluaXRpb25zXCIpO1xuICAgICAgICAgICAgaWYgKGFEZWZpbml0aW9uc0luZGV4ICE9PSBiRGVmaW5pdGlvbnNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEdpdmUgaGlnaGVyIHByaW9yaXR5IHRvIHRoZSAkcmVmIHRoYXQncyBjbG9zZXIgdG8gdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIHJldHVybiBiRGVmaW5pdGlvbnNJbmRleCAtIGFEZWZpbml0aW9uc0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsIGVsc2UgaXMgZXF1YWwsIHNvIHVzZSB0aGUgc2hvcnRlciBwYXRoLCB3aGljaCB3aWxsIHByb2R1Y2UgdGhlIHNob3J0ZXN0IHBvc3NpYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiBhLnBhdGhGcm9tUm9vdC5sZW5ndGggLSBiLnBhdGhGcm9tUm9vdC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgZmlsZSwgaGFzaCwgcGF0aEZyb21Sb290O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZS1tYXBwaW5nICRyZWYgcG9pbnRlciBcIiVzXCIgYXQgJXMnLCBlbnRyeS4kcmVmLiRyZWYsIGVudHJ5LnBhdGhGcm9tUm9vdCk7XG4gICAgICAgIGlmICghZW50cnkuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBhbHJlYWR5IHJlc29sdmVzIHRvIHRoZSBtYWluIEpTT04gU2NoZW1hIGZpbGVcbiAgICAgICAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IGVudHJ5Lmhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkuZmlsZSA9PT0gZmlsZSAmJiBlbnRyeS5oYXNoID09PSBoYXNoKSB7XG4gICAgICAgICAgICAvLyBUaGlzICRyZWYgcG9pbnRzIHRvIHRoZSBzYW1lIHZhbHVlIGFzIHRoZSBwcmV2b3VzICRyZWYsIHNvIHJlbWFwIGl0IHRvIHRoZSBzYW1lIHBhdGhcbiAgICAgICAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IHBhdGhGcm9tUm9vdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5maWxlID09PSBmaWxlICYmIGVudHJ5Lmhhc2guaW5kZXhPZihoYXNoICsgXCIvXCIpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzICRyZWYgcG9pbnRzIHRvIGEgc3ViLXZhbHVlIG9mIHRoZSBwcmV2b3VzICRyZWYsIHNvIHJlbWFwIGl0IGJlbmVhdGggdGhhdCBwYXRoXG4gICAgICAgICAgICBlbnRyeS4kcmVmLiRyZWYgPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5qb2luKHBhdGhGcm9tUm9vdCwgcG9pbnRlcl9qc18xLmRlZmF1bHQucGFyc2UoZW50cnkuaGFzaC5yZXBsYWNlKGhhc2gsIFwiI1wiKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UndmUgbW92ZWQgdG8gYSBuZXcgZmlsZSBvciBuZXcgaGFzaFxuICAgICAgICAgICAgZmlsZSA9IGVudHJ5LmZpbGU7XG4gICAgICAgICAgICBoYXNoID0gZW50cnkuaGFzaDtcbiAgICAgICAgICAgIHBhdGhGcm9tUm9vdCA9IGVudHJ5LnBhdGhGcm9tUm9vdDtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0ICRyZWYgdG8gcG9pbnQgdG8gdGhpcyB2YWx1ZSwgc28gZGVyZWZlcmVuY2UgdGhlIHZhbHVlLlxuICAgICAgICAgICAgLy8gQW55IG90aGVyICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhlIHNhbWUgdmFsdWUgd2lsbCBwb2ludCB0byB0aGlzICRyZWYgaW5zdGVhZFxuICAgICAgICAgICAgZW50cnkuJHJlZiA9IGVudHJ5LnBhcmVudFtlbnRyeS5rZXldID0gcmVmX2pzXzEuZGVmYXVsdC5kZXJlZmVyZW5jZShlbnRyeS4kcmVmLCBlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZW50cnkuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzICRyZWYgcG9pbnRzIHRvIGl0c2VsZlxuICAgICAgICAgICAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IGVudHJ5LnBhdGhGcm9tUm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnICAgIG5ldyB2YWx1ZTogJXMnLCAoZW50cnkuJHJlZiAmJiBlbnRyeS4kcmVmLiRyZWYpID8gZW50cnkuJHJlZi4kcmVmIDogJ1tvYmplY3QgT2JqZWN0XScpO1xuICAgIH1cbn1cbi8qKlxuICogVE9ET1xuICovXG5mdW5jdGlvbiBmaW5kSW5JbnZlbnRvcnkoaW52ZW50b3J5LCAkcmVmUGFyZW50LCAkcmVmS2V5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnZlbnRvcnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IGludmVudG9yeVtpXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRW50cnkucGFyZW50ID09PSAkcmVmUGFyZW50ICYmIGV4aXN0aW5nRW50cnkua2V5ID09PSAkcmVmS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21JbnZlbnRvcnkoaW52ZW50b3J5LCBlbnRyeSkge1xuICAgIGNvbnN0IGluZGV4ID0gaW52ZW50b3J5LmluZGV4T2YoZW50cnkpO1xuICAgIGludmVudG9yeS5zcGxpY2UoaW5kZXgsIDEpO1xufVxuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJyZWZfanNfMSIsInJlcXVpcmUiLCJwb2ludGVyX2pzXzEiLCJ1cmwiLCJkZWZhdWx0IiwiYnVuZGxlIiwicGFyc2VyIiwib3B0aW9ucyIsImludmVudG9yeSIsImNyYXdsIiwiJHJlZnMiLCJfcm9vdCRSZWYiLCJwYXRoIiwicmVtYXAiLCJwYXJlbnQiLCJrZXkiLCJwYXRoRnJvbVJvb3QiLCJpbmRpcmVjdGlvbnMiLCJvYmoiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImlzQWxsb3dlZCRSZWYiLCJpbnZlbnRvcnkkUmVmIiwia2V5cyIsInNvcnQiLCJhIiwiYiIsImxlbmd0aCIsImtleVBhdGgiLCJqb2luIiwia2V5UGF0aEZyb21Sb290IiwiJHJlZlBhcmVudCIsIiRyZWZLZXkiLCIkcmVmIiwiJHJlZlBhdGgiLCJyZXNvbHZlIiwicG9pbnRlciIsIl9yZXNvbHZlIiwiZGVwdGgiLCJwYXJzZSIsImZpbGUiLCJzdHJpcEhhc2giLCJoYXNoIiwiZ2V0SGFzaCIsImV4dGVybmFsIiwiZXh0ZW5kZWQiLCJpc0V4dGVuZGVkJFJlZiIsImV4aXN0aW5nRW50cnkiLCJmaW5kSW5JbnZlbnRvcnkiLCJyZW1vdmVGcm9tSW52ZW50b3J5IiwicHVzaCIsImNpcmN1bGFyIiwiYURlZmluaXRpb25zSW5kZXgiLCJsYXN0SW5kZXhPZiIsImJEZWZpbml0aW9uc0luZGV4IiwiZW50cnkiLCJpbmRleE9mIiwicmVwbGFjZSIsImRlcmVmZXJlbmNlIiwiaSIsImluZGV4Iiwic3BsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nexports[\"default\"] = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param parser\n * @param options\n */ function dereference(parser, options) {\n    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n    const dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options);\n    parser.$refs.circular = dereferenced.circular;\n    parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `obj` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been processed\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */ function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n    let dereferenced;\n    const result = {\n        value: obj,\n        circular: false\n    };\n    const isExcludedPath = options.dereference.excludedPathMatcher || (()=>false);\n    if (options.dereference.circular === \"ignore\" || !processedObjects.has(obj)) {\n        if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {\n            parents.add(obj);\n            processedObjects.add(obj);\n            if (ref_js_1.default.isAllowed$Ref(obj, options)) {\n                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                result.circular = dereferenced.circular;\n                result.value = dereferenced.value;\n            } else {\n                for (const key of Object.keys(obj)){\n                    const keyPath = pointer_js_1.default.join(path, key);\n                    const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                    if (isExcludedPath(keyPathFromRoot)) {\n                        continue;\n                    }\n                    const value = obj[key];\n                    let circular = false;\n                    if (ref_js_1.default.isAllowed$Ref(value, options)) {\n                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                        circular = dereferenced.circular;\n                        // Avoid pointless mutations; breaks frozen objects to no profit\n                        if (obj[key] !== dereferenced.value) {\n                            obj[key] = dereferenced.value;\n                            if (options.dereference.onDereference) {\n                                options.dereference.onDereference(value.$ref, obj[key]);\n                            }\n                        }\n                    } else {\n                        if (!parents.has(value)) {\n                            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n                            circular = dereferenced.circular;\n                            // Avoid pointless mutations; breaks frozen objects to no profit\n                            if (obj[key] !== dereferenced.value) {\n                                obj[key] = dereferenced.value;\n                            }\n                        } else {\n                            circular = foundCircularReference(keyPath, $refs, options);\n                        }\n                    }\n                    // Set the \"isCircular\" flag if this or any other property is circular\n                    result.circular = result.circular || circular;\n                }\n            }\n            parents.delete(obj);\n        }\n    }\n    return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `$ref` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been dereferenced\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */ function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {\n    // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n    const isExternalRef = ref_js_1.default.isExternal$Ref($ref);\n    const shouldResolveOnCwd = isExternalRef && options?.dereference.externalReferenceResolution === \"root\";\n    const $refPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const cache = dereferencedCache.get($refPath);\n    if (cache) {\n        const refKeys = Object.keys($ref);\n        if (refKeys.length > 1) {\n            const extraKeys = {};\n            for (const key of refKeys){\n                if (key !== \"$ref\" && !(key in cache.value)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    extraKeys[key] = $ref[key];\n                }\n            }\n            return {\n                circular: cache.circular,\n                value: Object.assign({}, cache.value, extraKeys)\n            };\n        }\n        return cache;\n    }\n    const pointer = $refs._resolve($refPath, path, options);\n    if (pointer === null) {\n        return {\n            circular: false,\n            value: null\n        };\n    }\n    // Check for circular references\n    const directCircular = pointer.circular;\n    let circular = directCircular || parents.has(pointer.value);\n    circular && foundCircularReference(path, $refs, options);\n    // Dereference the JSON reference\n    let dereferencedValue = ref_js_1.default.dereference($ref, pointer.value);\n    // Crawl the dereferenced value (unless it's circular)\n    if (!circular) {\n        // Determine if the dereferenced value is circular\n        const dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);\n        circular = dereferenced.circular;\n        dereferencedValue = dereferenced.value;\n    }\n    if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n        // The user has chosen to \"ignore\" circular references, so don't change the value\n        dereferencedValue = $ref;\n    }\n    if (directCircular) {\n        // The pointer is a DIRECT circular reference (i.e. it references itself).\n        // So replace the $ref path with the absolute path from the JSON Schema root\n        dereferencedValue.$ref = pathFromRoot;\n    }\n    const dereferencedObject = {\n        circular,\n        value: dereferencedValue\n    };\n    // only cache if no extra properties than $ref\n    if (Object.keys($ref).length === 1) {\n        dereferencedCache.set($refPath, dereferencedObject);\n    }\n    return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param keyPath - The JSON Reference path of the circular reference\n * @param $refs\n * @param options\n * @returns - always returns true, to indicate that a circular reference was found\n */ function foundCircularReference(keyPath, $refs, options) {\n    $refs.circular = true;\n    if (!options.dereference.circular) {\n        throw ono_1.ono.reference(`Circular $ref pointer found at ${keyPath}`);\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvZGVyZWZlcmVuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVB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LEVBQUUxQixRQUFRLENBQUM7SUFDekU7SUFDQSxPQUFPO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL2RlcmVmZXJlbmNlLmpzPzNkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVyZWZlcmVuY2U7XG4vKipcbiAqIENyYXdscyB0aGUgSlNPTiBzY2hlbWEsIGZpbmRzIGFsbCBKU09OIHJlZmVyZW5jZXMsIGFuZCBkZXJlZmVyZW5jZXMgdGhlbS5cbiAqIFRoaXMgbWV0aG9kIG11dGF0ZXMgdGhlIEpTT04gc2NoZW1hIG9iamVjdCwgcmVwbGFjaW5nIEpTT04gcmVmZXJlbmNlcyB3aXRoIHRoZWlyIHJlc29sdmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwYXJzZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGRlcmVmZXJlbmNlKHBhcnNlciwgb3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdEZXJlZmVyZW5jaW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICAgIGNvbnN0IGRlcmVmZXJlbmNlZCA9IGNyYXdsKHBhcnNlci5zY2hlbWEsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCwgXCIjXCIsIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgTWFwKCksIHBhcnNlci4kcmVmcywgb3B0aW9ucyk7XG4gICAgcGFyc2VyLiRyZWZzLmNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgIHBhcnNlci5zY2hlbWEgPSBkZXJlZmVyZW5jZWQudmFsdWU7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNyYXdscyB0aGUgZ2l2ZW4gdmFsdWUsIGFuZCBkZXJlZmVyZW5jZXMgYW55IEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIGNyYXdsLiBJZiBpdCdzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgb2JqYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIGBvYmpgIGZyb20gdGhlIHNjaGVtYSByb290XG4gKiBAcGFyYW0gcGFyZW50cyAtIEFuIGFycmF5IG9mIHRoZSBwYXJlbnQgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIHByb2Nlc3NlZE9iamVjdHMgLSBBbiBhcnJheSBvZiBhbGwgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWRcbiAqIEBwYXJhbSBkZXJlZmVyZW5jZWRDYWNoZSAtIEFuIG1hcCBvZiBhbGwgdGhlIGRlcmVmZXJlbmNlZCBvYmplY3RzXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmF3bChvYmosIHBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zKSB7XG4gICAgbGV0IGRlcmVmZXJlbmNlZDtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHZhbHVlOiBvYmosXG4gICAgICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGlzRXhjbHVkZWRQYXRoID0gb3B0aW9ucy5kZXJlZmVyZW5jZS5leGNsdWRlZFBhdGhNYXRjaGVyIHx8ICgoKSA9PiBmYWxzZSk7XG4gICAgaWYgKG9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXIgPT09IFwiaWdub3JlXCIgfHwgIXByb2Nlc3NlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSAmJiAhaXNFeGNsdWRlZFBhdGgocGF0aEZyb21Sb290KSkge1xuICAgICAgICAgICAgcGFyZW50cy5hZGQob2JqKTtcbiAgICAgICAgICAgIHByb2Nlc3NlZE9iamVjdHMuYWRkKG9iaik7XG4gICAgICAgICAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKG9iaiwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZWQgPSBkZXJlZmVyZW5jZSRSZWYob2JqLCBwYXRoLCBwYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IGRlcmVmZXJlbmNlZC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aEZyb21Sb290ID0gcG9pbnRlcl9qc18xLmRlZmF1bHQuam9pbihwYXRoRnJvbVJvb3QsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V4Y2x1ZGVkUGF0aChrZXlQYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2lyY3VsYXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZl9qc18xLmRlZmF1bHQuaXNBbGxvd2VkJFJlZih2YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGRlcmVmZXJlbmNlJFJlZih2YWx1ZSwga2V5UGF0aCwga2V5UGF0aEZyb21Sb290LCBwYXJlbnRzLCBwcm9jZXNzZWRPYmplY3RzLCBkZXJlZmVyZW5jZWRDYWNoZSwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBwb2ludGxlc3MgbXV0YXRpb25zOyBicmVha3MgZnJvemVuIG9iamVjdHMgdG8gbm8gcHJvZml0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gIT09IGRlcmVmZXJlbmNlZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlcmVmZXJlbmNlLm9uRGVyZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZXJlZmVyZW5jZS5vbkRlcmVmZXJlbmNlKHZhbHVlLiRyZWYsIG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGNyYXdsKHZhbHVlLCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgcG9pbnRsZXNzIG11dGF0aW9uczsgYnJlYWtzIGZyb3plbiBvYmplY3RzIHRvIG5vIHByb2ZpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmpba2V5XSAhPT0gZGVyZWZlcmVuY2VkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyID0gZm91bmRDaXJjdWxhclJlZmVyZW5jZShrZXlQYXRoLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBcImlzQ2lyY3VsYXJcIiBmbGFnIGlmIHRoaXMgb3IgYW55IG90aGVyIHByb3BlcnR5IGlzIGNpcmN1bGFyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jaXJjdWxhciA9IHJlc3VsdC5jaXJjdWxhciB8fCBjaXJjdWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnRzLmRlbGV0ZShvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERlcmVmZXJlbmNlcyB0aGUgZ2l2ZW4gSlNPTiBSZWZlcmVuY2UsIGFuZCB0aGVuIGNyYXdscyB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAkcmVmIC0gVGhlIEpTT04gUmVmZXJlbmNlIHRvIHJlc29sdmVcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgJHJlZmAsIHBvc3NpYmx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiBgJHJlZmAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSBwYXJlbnRzIC0gQW4gYXJyYXkgb2YgdGhlIHBhcmVudCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0gcHJvY2Vzc2VkT2JqZWN0cyAtIEFuIGFycmF5IG9mIGFsbCB0aGUgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIGRlcmVmZXJlbmNlZENhY2hlIC0gQW4gbWFwIG9mIGFsbCB0aGUgZGVyZWZlcmVuY2VkIG9iamVjdHNcbiAqIEBwYXJhbSAkcmVmc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGRlcmVmZXJlbmNlJFJlZigkcmVmLCBwYXRoLCBwYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdEZXJlZmVyZW5jaW5nICRyZWYgcG9pbnRlciBcIiVzXCIgYXQgJXMnLCAkcmVmLiRyZWYsIHBhdGgpO1xuICAgIGNvbnN0IGlzRXh0ZXJuYWxSZWYgPSByZWZfanNfMS5kZWZhdWx0LmlzRXh0ZXJuYWwkUmVmKCRyZWYpO1xuICAgIGNvbnN0IHNob3VsZFJlc29sdmVPbkN3ZCA9IGlzRXh0ZXJuYWxSZWYgJiYgb3B0aW9ucz8uZGVyZWZlcmVuY2UuZXh0ZXJuYWxSZWZlcmVuY2VSZXNvbHV0aW9uID09PSBcInJvb3RcIjtcbiAgICBjb25zdCAkcmVmUGF0aCA9IHVybC5yZXNvbHZlKHNob3VsZFJlc29sdmVPbkN3ZCA/IHVybC5jd2QoKSA6IHBhdGgsICRyZWYuJHJlZik7XG4gICAgY29uc3QgY2FjaGUgPSBkZXJlZmVyZW5jZWRDYWNoZS5nZXQoJHJlZlBhdGgpO1xuICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjb25zdCByZWZLZXlzID0gT2JqZWN0LmtleXMoJHJlZik7XG4gICAgICAgIGlmIChyZWZLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVmS2V5cykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiJHJlZlwiICYmICEoa2V5IGluIGNhY2hlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTKDcwNTMpOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGUgYmVjYXVzZSBleHByZS4uLiBSZW1vdmUgdGhpcyBjb21tZW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5c1trZXldID0gJHJlZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2lyY3VsYXI6IGNhY2hlLmNpcmN1bGFyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZS52YWx1ZSwgZXh0cmFLZXlzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyID0gJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChwb2ludGVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBjb25zdCBkaXJlY3RDaXJjdWxhciA9IHBvaW50ZXIuY2lyY3VsYXI7XG4gICAgbGV0IGNpcmN1bGFyID0gZGlyZWN0Q2lyY3VsYXIgfHwgcGFyZW50cy5oYXMocG9pbnRlci52YWx1ZSk7XG4gICAgY2lyY3VsYXIgJiYgZm91bmRDaXJjdWxhclJlZmVyZW5jZShwYXRoLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgLy8gRGVyZWZlcmVuY2UgdGhlIEpTT04gcmVmZXJlbmNlXG4gICAgbGV0IGRlcmVmZXJlbmNlZFZhbHVlID0gcmVmX2pzXzEuZGVmYXVsdC5kZXJlZmVyZW5jZSgkcmVmLCBwb2ludGVyLnZhbHVlKTtcbiAgICAvLyBDcmF3bCB0aGUgZGVyZWZlcmVuY2VkIHZhbHVlICh1bmxlc3MgaXQncyBjaXJjdWxhcilcbiAgICBpZiAoIWNpcmN1bGFyKSB7XG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZGVyZWZlcmVuY2VkIHZhbHVlIGlzIGNpcmN1bGFyXG4gICAgICAgIGNvbnN0IGRlcmVmZXJlbmNlZCA9IGNyYXdsKGRlcmVmZXJlbmNlZFZhbHVlLCBwb2ludGVyLnBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgIGRlcmVmZXJlbmNlZFZhbHVlID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIgJiYgIWRpcmVjdENpcmN1bGFyICYmIG9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXIgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIgaGFzIGNob3NlbiB0byBcImlnbm9yZVwiIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHNvIGRvbid0IGNoYW5nZSB0aGUgdmFsdWVcbiAgICAgICAgZGVyZWZlcmVuY2VkVmFsdWUgPSAkcmVmO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0Q2lyY3VsYXIpIHtcbiAgICAgICAgLy8gVGhlIHBvaW50ZXIgaXMgYSBESVJFQ1QgY2lyY3VsYXIgcmVmZXJlbmNlIChpLmUuIGl0IHJlZmVyZW5jZXMgaXRzZWxmKS5cbiAgICAgICAgLy8gU28gcmVwbGFjZSB0aGUgJHJlZiBwYXRoIHdpdGggdGhlIGFic29sdXRlIHBhdGggZnJvbSB0aGUgSlNPTiBTY2hlbWEgcm9vdFxuICAgICAgICBkZXJlZmVyZW5jZWRWYWx1ZS4kcmVmID0gcGF0aEZyb21Sb290O1xuICAgIH1cbiAgICBjb25zdCBkZXJlZmVyZW5jZWRPYmplY3QgPSB7XG4gICAgICAgIGNpcmN1bGFyLFxuICAgICAgICB2YWx1ZTogZGVyZWZlcmVuY2VkVmFsdWUsXG4gICAgfTtcbiAgICAvLyBvbmx5IGNhY2hlIGlmIG5vIGV4dHJhIHByb3BlcnRpZXMgdGhhbiAkcmVmXG4gICAgaWYgKE9iamVjdC5rZXlzKCRyZWYpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBkZXJlZmVyZW5jZWRDYWNoZS5zZXQoJHJlZlBhdGgsIGRlcmVmZXJlbmNlZE9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBkZXJlZmVyZW5jZWRPYmplY3Q7XG59XG4vKipcbiAqIENhbGxlZCB3aGVuIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIGZvdW5kLlxuICogSXQgc2V0cyB0aGUge0BsaW5rICRSZWZzI2NpcmN1bGFyfSBmbGFnLCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIG9wdGlvbnMuZGVyZWZlcmVuY2UuY2lyY3VsYXIgaXMgZmFsc2UuXG4gKlxuICogQHBhcmFtIGtleVBhdGggLSBUaGUgSlNPTiBSZWZlcmVuY2UgcGF0aCBvZiB0aGUgY2lyY3VsYXIgcmVmZXJlbmNlXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyAtIGFsd2F5cyByZXR1cm5zIHRydWUsIHRvIGluZGljYXRlIHRoYXQgYSBjaXJjdWxhciByZWZlcmVuY2Ugd2FzIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGZvdW5kQ2lyY3VsYXJSZWZlcmVuY2Uoa2V5UGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICAkcmVmcy5jaXJjdWxhciA9IHRydWU7XG4gICAgaWYgKCFvcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyKSB7XG4gICAgICAgIHRocm93IG9ub18xLm9uby5yZWZlcmVuY2UoYENpcmN1bGFyICRyZWYgcG9pbnRlciBmb3VuZCBhdCAke2tleVBhdGh9YCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbIl9fY3JlYXRlQmluZGluZyIsIk9iamVjdCIsImNyZWF0ZSIsIm8iLCJtIiwiayIsImsyIiwidW5kZWZpbmVkIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZXNNb2R1bGUiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9faW1wb3J0U3RhciIsIm1vZCIsInJlc3VsdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9faW1wb3J0RGVmYXVsdCIsImV4cG9ydHMiLCJyZWZfanNfMSIsInJlcXVpcmUiLCJwb2ludGVyX2pzXzEiLCJvbm9fMSIsInVybCIsImRlZmF1bHQiLCJkZXJlZmVyZW5jZSIsInBhcnNlciIsIm9wdGlvbnMiLCJkZXJlZmVyZW5jZWQiLCJjcmF3bCIsInNjaGVtYSIsIiRyZWZzIiwiX3Jvb3QkUmVmIiwicGF0aCIsIlNldCIsIk1hcCIsImNpcmN1bGFyIiwib2JqIiwicGF0aEZyb21Sb290IiwicGFyZW50cyIsInByb2Nlc3NlZE9iamVjdHMiLCJkZXJlZmVyZW5jZWRDYWNoZSIsImlzRXhjbHVkZWRQYXRoIiwiZXhjbHVkZWRQYXRoTWF0Y2hlciIsImhhcyIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYWRkIiwiaXNBbGxvd2VkJFJlZiIsImRlcmVmZXJlbmNlJFJlZiIsImtleSIsImtleXMiLCJrZXlQYXRoIiwiam9pbiIsImtleVBhdGhGcm9tUm9vdCIsIm9uRGVyZWZlcmVuY2UiLCIkcmVmIiwiZm91bmRDaXJjdWxhclJlZmVyZW5jZSIsImRlbGV0ZSIsImlzRXh0ZXJuYWxSZWYiLCJpc0V4dGVybmFsJFJlZiIsInNob3VsZFJlc29sdmVPbkN3ZCIsImV4dGVybmFsUmVmZXJlbmNlUmVzb2x1dGlvbiIsIiRyZWZQYXRoIiwicmVzb2x2ZSIsImN3ZCIsImNhY2hlIiwicmVmS2V5cyIsImxlbmd0aCIsImV4dHJhS2V5cyIsImFzc2lnbiIsInBvaW50ZXIiLCJfcmVzb2x2ZSIsImRpcmVjdENpcmN1bGFyIiwiZGVyZWZlcmVuY2VkVmFsdWUiLCJkZXJlZmVyZW5jZWRPYmplY3QiLCJzZXQiLCJvbm8iLCJyZWZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.dereference = exports.bundle = exports.resolve = exports.parse = exports.$RefParser = exports.UnmatchedResolverError = exports.UnmatchedParserError = exports.ParserError = exports.ResolverError = exports.MissingPointerError = exports.InvalidPointerError = exports.JSONParserError = void 0;\nconst refs_js_1 = __importDefault(__webpack_require__(/*! ./refs.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst normalize_args_js_1 = __importDefault(__webpack_require__(/*! ./normalize-args.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\"));\nconst resolve_external_js_1 = __importDefault(__webpack_require__(/*! ./resolve-external.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\"));\nconst bundle_js_1 = __importDefault(__webpack_require__(/*! ./bundle.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\"));\nconst dereference_js_1 = __importDefault(__webpack_require__(/*! ./dereference.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nObject.defineProperty(exports, \"JSONParserError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.JSONParserError;\n    }\n}));\nObject.defineProperty(exports, \"InvalidPointerError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.InvalidPointerError;\n    }\n}));\nObject.defineProperty(exports, \"MissingPointerError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.MissingPointerError;\n    }\n}));\nObject.defineProperty(exports, \"ResolverError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.ResolverError;\n    }\n}));\nObject.defineProperty(exports, \"ParserError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.ParserError;\n    }\n}));\nObject.defineProperty(exports, \"UnmatchedParserError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.UnmatchedParserError;\n    }\n}));\nObject.defineProperty(exports, \"UnmatchedResolverError\", ({\n    enumerable: true,\n    get: function() {\n        return errors_js_1.UnmatchedResolverError;\n    }\n}));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst maybe_js_1 = __importDefault(__webpack_require__(/*! ./util/maybe.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\"));\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @class\n */ class $RefParser {\n    constructor(){\n        /**\n         * The parsed (and possibly dereferenced) JSON schema object\n         *\n         * @type {object}\n         * @readonly\n         */ this.schema = null;\n        /**\n         * The resolved JSON references\n         *\n         * @type {$Refs}\n         * @readonly\n         */ this.$refs = new refs_js_1.default();\n    }\n    async parse() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        let promise;\n        if (!args.path && !args.schema) {\n            const err = (0, ono_1.ono)(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n        // Reset everything\n        this.schema = null;\n        this.$refs = new refs_js_1.default();\n        // If the path is a filesystem path, then convert it to a URL.\n        // NOTE: According to the JSON Reference spec, these should already be URLs,\n        // but, in practice, many people use local filesystem paths instead.\n        // So we're being generous here and doing the conversion automatically.\n        // This is not intended to be a 100% bulletproof solution.\n        // If it doesn't work for your use-case, then use a URL instead.\n        let pathType = \"http\";\n        if (url.isFileSystemPath(args.path)) {\n            args.path = url.fromFileSystemPath(args.path);\n            pathType = \"file\";\n        } else if (!args.path && args.schema && args.schema.$id) {\n            // when schema id has defined an URL should use that hostname to request the references,\n            // instead of using the current page URL\n            const params = url.parse(args.schema.$id);\n            const port = params.protocol === \"https:\" ? 443 : 80;\n            args.path = `${params.protocol}//${params.hostname}:${port}`;\n        }\n        // Resolve the absolute path of the schema\n        args.path = url.resolve(url.cwd(), args.path);\n        if (args.schema && typeof args.schema === \"object\") {\n            // A schema object was passed-in.\n            // So immediately add a new $Ref with the schema object as its value\n            const $ref = this.$refs._add(args.path);\n            $ref.value = args.schema;\n            $ref.pathType = pathType;\n            promise = Promise.resolve(args.schema);\n        } else {\n            // Parse the schema file/url\n            promise = (0, parse_js_1.default)(args.path, this.$refs, args.options);\n        }\n        try {\n            const result = await promise;\n            if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n                this.schema = result;\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            } else if (args.options.continueOnError) {\n                this.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            } else {\n                throw ono_1.ono.syntax(`\"${this.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n            }\n        } catch (err) {\n            if (!args.options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n            }\n            if (this.$refs._$refs[url.stripHash(args.path)]) {\n                this.$refs._$refs[url.stripHash(args.path)].addError(err);\n            }\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(null));\n        }\n    }\n    static parse() {\n        const parser = new $RefParser();\n        return parser.parse.apply(parser, arguments);\n    }\n    /**\n     * Parses the given JSON schema and resolves any JSON references, including references in\n     * externally-referenced files.\n     *\n     * @param [path] - The file path or URL of the JSON schema\n     * @param [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n     * @param [options] - Options that determine how the schema is parsed and resolved\n     * @param [callback]\n     * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n     *\n     * @returns\n     * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n     */ async resolve() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.parse(args.path, args.schema, args.options);\n            await (0, resolve_external_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.$refs));\n        } catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static resolve() {\n        const instance = new $RefParser();\n        return instance.resolve.apply(instance, arguments);\n    }\n    static bundle() {\n        const instance = new $RefParser();\n        return instance.bundle.apply(instance, arguments);\n    }\n    async bundle() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, bundle_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        } catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static dereference() {\n        const instance = new $RefParser();\n        return instance.dereference.apply(instance, arguments);\n    }\n    async dereference() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, dereference_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        } catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n}\nexports.$RefParser = $RefParser;\nexports[\"default\"] = $RefParser;\nfunction finalize(parser) {\n    const errors = errors_js_1.JSONParserErrorGroup.getParserErrors(parser);\n    if (errors.length > 0) {\n        throw new errors_js_1.JSONParserErrorGroup(parser);\n    }\n}\nexports.parse = $RefParser.parse;\nexports.resolve = $RefParser.resolve;\nexports.bundle = $RefParser.bundle;\nexports.dereference = $RefParser.dereference;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FB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QUFNNUIsY0FBYztRQUNoQixNQUFNMkIsT0FBTyxDQUFDLEdBQUdaLG9CQUFvQlcsT0FBTyxFQUFFRTtRQUM5QyxJQUFJO1lBQ0EsTUFBTSxJQUFJLENBQUMxQixPQUFPLENBQUN5QixLQUFLRyxJQUFJLEVBQUVILEtBQUtILE1BQU0sRUFBRUcsS0FBS29CLE9BQU87WUFDdEQsSUFBRzdCLGlCQUFpQlEsT0FBTyxFQUFFLElBQUksRUFBRUMsS0FBS29CLE9BQU87WUFDaERZLFNBQVMsSUFBSTtZQUNiLE9BQU8sQ0FBQyxHQUFHckMsV0FBV0ksT0FBTyxFQUFFQyxLQUFLTSxRQUFRLEVBQUVDLFFBQVFoQyxPQUFPLENBQUMsSUFBSSxDQUFDc0IsTUFBTTtRQUM3RSxFQUNBLE9BQU9PLEtBQUs7WUFDUixPQUFPLENBQUMsR0FBR1QsV0FBV0ksT0FBTyxFQUFFQyxLQUFLTSxRQUFRLEVBQUVDLFFBQVFDLE1BQU0sQ0FBQ0o7UUFDakU7SUFDSjtBQUNKO0FBQ0FoQyxrQkFBa0IsR0FBR0s7QUFDckJMLGtCQUFlLEdBQUdLO0FBQ2xCLFNBQVN1RCxTQUFTRixNQUFNO0lBQ3BCLE1BQU1JLFNBQVN6QyxZQUFZMEMsb0JBQW9CLENBQUNDLGVBQWUsQ0FBQ047SUFDaEUsSUFBSUksT0FBT0csTUFBTSxHQUFHLEdBQUc7UUFDbkIsTUFBTSxJQUFJNUMsWUFBWTBDLG9CQUFvQixDQUFDTDtJQUMvQztBQUNKO0FBQ0ExRCxhQUFhLEdBQUdLLFdBQVdELEtBQUs7QUFDaENKLGVBQWUsR0FBR0ssV0FBV0YsT0FBTztBQUNwQ0gsY0FBYyxHQUFHSyxXQUFXSCxNQUFNO0FBQ2xDRixtQkFBbUIsR0FBR0ssV0FBV0osV0FBVyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvaW5kZXguanM/NmMxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXJlZmVyZW5jZSA9IGV4cG9ydHMuYnVuZGxlID0gZXhwb3J0cy5yZXNvbHZlID0gZXhwb3J0cy5wYXJzZSA9IGV4cG9ydHMuJFJlZlBhcnNlciA9IGV4cG9ydHMuVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciA9IGV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBleHBvcnRzLlBhcnNlckVycm9yID0gZXhwb3J0cy5SZXNvbHZlckVycm9yID0gZXhwb3J0cy5NaXNzaW5nUG9pbnRlckVycm9yID0gZXhwb3J0cy5JbnZhbGlkUG9pbnRlckVycm9yID0gZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSB2b2lkIDA7XG5jb25zdCByZWZzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmcy5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IG5vcm1hbGl6ZV9hcmdzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9ybWFsaXplLWFyZ3MuanNcIikpO1xuY29uc3QgcmVzb2x2ZV9leHRlcm5hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc29sdmUtZXh0ZXJuYWwuanNcIikpO1xuY29uc3QgYnVuZGxlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnVuZGxlLmpzXCIpKTtcbmNvbnN0IGRlcmVmZXJlbmNlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVyZWZlcmVuY2UuanNcIikpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWwvdXJsLmpzXCIpKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vdXRpbC9lcnJvcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU09OUGFyc2VyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFsaWRQb2ludGVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLkludmFsaWRQb2ludGVyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUG9pbnRlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5NaXNzaW5nUG9pbnRlckVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzb2x2ZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuUmVzb2x2ZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWF0Y2hlZFBhcnNlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5Vbm1hdGNoZWRQYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWF0Y2hlZFJlc29sdmVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLlVubWF0Y2hlZFJlc29sdmVyRXJyb3I7IH0gfSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCBtYXliZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWF5YmUuanNcIikpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHBhcnNlcyBhIEpTT04gc2NoZW1hLCBidWlsZHMgYSBtYXAgb2YgaXRzIEpTT04gcmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLFxuICogYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yIHRyYXZlcnNpbmcsIG1hbmlwdWxhdGluZywgYW5kIGRlcmVmZXJlbmNpbmcgdGhvc2UgcmVmZXJlbmNlcy5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgJFJlZlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyc2VkIChhbmQgcG9zc2libHkgZGVyZWZlcmVuY2VkKSBKU09OIHNjaGVtYSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVtYSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x2ZWQgSlNPTiByZWZlcmVuY2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHskUmVmc31cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRyZWZzID0gbmV3IHJlZnNfanNfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gKDAsIG5vcm1hbGl6ZV9hcmdzX2pzXzEuZGVmYXVsdCkoYXJndW1lbnRzKTtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghYXJncy5wYXRoICYmICFhcmdzLnNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gKDAsIG9ub18xLm9ubykoYEV4cGVjdGVkIGEgZmlsZSBwYXRoLCBVUkwsIG9yIG9iamVjdC4gR290ICR7YXJncy5wYXRoIHx8IGFyZ3Muc2NoZW1hfWApO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZWZzID0gbmV3IHJlZnNfanNfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIGEgZmlsZXN5c3RlbSBwYXRoLCB0aGVuIGNvbnZlcnQgaXQgdG8gYSBVUkwuXG4gICAgICAgIC8vIE5PVEU6IEFjY29yZGluZyB0byB0aGUgSlNPTiBSZWZlcmVuY2Ugc3BlYywgdGhlc2Ugc2hvdWxkIGFscmVhZHkgYmUgVVJMcyxcbiAgICAgICAgLy8gYnV0LCBpbiBwcmFjdGljZSwgbWFueSBwZW9wbGUgdXNlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHMgaW5zdGVhZC5cbiAgICAgICAgLy8gU28gd2UncmUgYmVpbmcgZ2VuZXJvdXMgaGVyZSBhbmQgZG9pbmcgdGhlIGNvbnZlcnNpb24gYXV0b21hdGljYWxseS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgYSAxMDAlIGJ1bGxldHByb29mIHNvbHV0aW9uLlxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IHdvcmsgZm9yIHlvdXIgdXNlLWNhc2UsIHRoZW4gdXNlIGEgVVJMIGluc3RlYWQuXG4gICAgICAgIGxldCBwYXRoVHlwZSA9IFwiaHR0cFwiO1xuICAgICAgICBpZiAodXJsLmlzRmlsZVN5c3RlbVBhdGgoYXJncy5wYXRoKSkge1xuICAgICAgICAgICAgYXJncy5wYXRoID0gdXJsLmZyb21GaWxlU3lzdGVtUGF0aChhcmdzLnBhdGgpO1xuICAgICAgICAgICAgcGF0aFR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYXJncy5wYXRoICYmIGFyZ3Muc2NoZW1hICYmIGFyZ3Muc2NoZW1hLiRpZCkge1xuICAgICAgICAgICAgLy8gd2hlbiBzY2hlbWEgaWQgaGFzIGRlZmluZWQgYW4gVVJMIHNob3VsZCB1c2UgdGhhdCBob3N0bmFtZSB0byByZXF1ZXN0IHRoZSByZWZlcmVuY2VzLFxuICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiB1c2luZyB0aGUgY3VycmVudCBwYWdlIFVSTFxuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gdXJsLnBhcnNlKGFyZ3Muc2NoZW1hLiRpZCk7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gcGFyYW1zLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gNDQzIDogODA7XG4gICAgICAgICAgICBhcmdzLnBhdGggPSBgJHtwYXJhbXMucHJvdG9jb2x9Ly8ke3BhcmFtcy5ob3N0bmFtZX06JHtwb3J0fWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgc2NoZW1hXG4gICAgICAgIGFyZ3MucGF0aCA9IHVybC5yZXNvbHZlKHVybC5jd2QoKSwgYXJncy5wYXRoKTtcbiAgICAgICAgaWYgKGFyZ3Muc2NoZW1hICYmIHR5cGVvZiBhcmdzLnNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQSBzY2hlbWEgb2JqZWN0IHdhcyBwYXNzZWQtaW4uXG4gICAgICAgICAgICAvLyBTbyBpbW1lZGlhdGVseSBhZGQgYSBuZXcgJFJlZiB3aXRoIHRoZSBzY2hlbWEgb2JqZWN0IGFzIGl0cyB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgJHJlZiA9IHRoaXMuJHJlZnMuX2FkZChhcmdzLnBhdGgpO1xuICAgICAgICAgICAgJHJlZi52YWx1ZSA9IGFyZ3Muc2NoZW1hO1xuICAgICAgICAgICAgJHJlZi5wYXRoVHlwZSA9IHBhdGhUeXBlO1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShhcmdzLnNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgc2NoZW1hIGZpbGUvdXJsXG4gICAgICAgICAgICBwcm9taXNlID0gKDAsIHBhcnNlX2pzXzEuZGVmYXVsdCkoYXJncy5wYXRoLCB0aGlzLiRyZWZzLCBhcmdzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiICYmICFCdWZmZXIuaXNCdWZmZXIocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy5zY2hlbWEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3Mub3B0aW9ucy5jb250aW51ZU9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG51bGw7IC8vIGl0J3MgYWxyZWFkeSBzZXQgdG8gbnVsbCBhdCBsaW5lIDc5LCBidXQgbGV0J3Mgc2V0IGl0IGFnYWluIGZvciB0aGUgc2FrZSBvZiByZWFkYWJpbGl0eVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy5zY2hlbWEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG9ub18xLm9uby5zeW50YXgoYFwiJHt0aGlzLiRyZWZzLl9yb290JFJlZi5wYXRoIHx8IHJlc3VsdH1cIiBpcyBub3QgYSB2YWxpZCBKU09OIFNjaGVtYWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghYXJncy5vcHRpb25zLmNvbnRpbnVlT25FcnJvciB8fCAhKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuJHJlZnMuXyRyZWZzW3VybC5zdHJpcEhhc2goYXJncy5wYXRoKV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRyZWZzLl8kcmVmc1t1cmwuc3RyaXBIYXNoKGFyZ3MucGF0aCldLmFkZEVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZXNvbHZlKG51bGwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyAkUmVmUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIEpTT04gc2NoZW1hIGFuZCByZXNvbHZlcyBhbnkgSlNPTiByZWZlcmVuY2VzLCBpbmNsdWRpbmcgcmVmZXJlbmNlcyBpblxuICAgICAqIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbcGF0aF0gLSBUaGUgZmlsZSBwYXRoIG9yIFVSTCBvZiB0aGUgSlNPTiBzY2hlbWFcbiAgICAgKiBAcGFyYW0gW3NjaGVtYV0gLSBBIEpTT04gc2NoZW1hIG9iamVjdC4gVGhpcyBvYmplY3Qgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgcmVhZGluZyBmcm9tIGBwYXRoYC5cbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gT3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIHNjaGVtYSBpcyBwYXJzZWQgYW5kIHJlc29sdmVkXG4gICAgICogQHBhcmFtIFtjYWxsYmFja11cbiAgICAgKiAtIEFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhIHtAbGluayAkUmVmc30gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdmVkIEpTT04gcmVmZXJlbmNlc1xuICAgICAqXG4gICAgICogQHJldHVybnNcbiAgICAgKiBUaGUgcmV0dXJuZWQgcHJvbWlzZSByZXNvbHZlcyB3aXRoIGEge0BsaW5rICRSZWZzfSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzb2x2ZWQgSlNPTiByZWZlcmVuY2VzXG4gICAgICovXG4gICAgYXN5bmMgcmVzb2x2ZSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9ICgwLCBub3JtYWxpemVfYXJnc19qc18xLmRlZmF1bHQpKGFyZ3VtZW50cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlKGFyZ3MucGF0aCwgYXJncy5zY2hlbWEsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBhd2FpdCAoMCwgcmVzb2x2ZV9leHRlcm5hbF9qc18xLmRlZmF1bHQpKHRoaXMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBmaW5hbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy4kcmVmcykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcmVzb2x2ZSgpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgJFJlZlBhcnNlcigpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UucmVzb2x2ZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgc3RhdGljIGJ1bmRsZSgpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgJFJlZlBhcnNlcigpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuYnVuZGxlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhc3luYyBidW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoMCwgbm9ybWFsaXplX2FyZ3NfanNfMS5kZWZhdWx0KShhcmd1bWVudHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXNvbHZlKGFyZ3MucGF0aCwgYXJncy5zY2hlbWEsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICAoMCwgYnVuZGxlX2pzXzEuZGVmYXVsdCkodGhpcywgYXJncy5vcHRpb25zKTtcbiAgICAgICAgICAgIGZpbmFsaXplKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZSh0aGlzLnNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlamVjdChlcnIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UoKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3ICRSZWZQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmRlcmVmZXJlbmNlLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBhc3luYyBkZXJlZmVyZW5jZSgpIHtcbiAgICAgICAgY29uc3QgYXJncyA9ICgwLCBub3JtYWxpemVfYXJnc19qc18xLmRlZmF1bHQpKGFyZ3VtZW50cyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc29sdmUoYXJncy5wYXRoLCBhcmdzLnNjaGVtYSwgYXJncy5vcHRpb25zKTtcbiAgICAgICAgICAgICgwLCBkZXJlZmVyZW5jZV9qc18xLmRlZmF1bHQpKHRoaXMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBmaW5hbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy5zY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLiRSZWZQYXJzZXIgPSAkUmVmUGFyc2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gJFJlZlBhcnNlcjtcbmZ1bmN0aW9uIGZpbmFsaXplKHBhcnNlcikge1xuICAgIGNvbnN0IGVycm9ycyA9IGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvckdyb3VwLmdldFBhcnNlckVycm9ycyhwYXJzZXIpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuSlNPTlBhcnNlckVycm9yR3JvdXAocGFyc2VyKTtcbiAgICB9XG59XG5leHBvcnRzLnBhcnNlID0gJFJlZlBhcnNlci5wYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9ICRSZWZQYXJzZXIucmVzb2x2ZTtcbmV4cG9ydHMuYnVuZGxlID0gJFJlZlBhcnNlci5idW5kbGU7XG5leHBvcnRzLmRlcmVmZXJlbmNlID0gJFJlZlBhcnNlci5kZXJlZmVyZW5jZTtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwiZGVyZWZlcmVuY2UiLCJidW5kbGUiLCJyZXNvbHZlIiwicGFyc2UiLCIkUmVmUGFyc2VyIiwiVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciIsIlVubWF0Y2hlZFBhcnNlckVycm9yIiwiUGFyc2VyRXJyb3IiLCJSZXNvbHZlckVycm9yIiwiTWlzc2luZ1BvaW50ZXJFcnJvciIsIkludmFsaWRQb2ludGVyRXJyb3IiLCJKU09OUGFyc2VyRXJyb3IiLCJyZWZzX2pzXzEiLCJyZXF1aXJlIiwicGFyc2VfanNfMSIsIm5vcm1hbGl6ZV9hcmdzX2pzXzEiLCJyZXNvbHZlX2V4dGVybmFsX2pzXzEiLCJidW5kbGVfanNfMSIsImRlcmVmZXJlbmNlX2pzXzEiLCJ1cmwiLCJlcnJvcnNfanNfMSIsIm9ub18xIiwibWF5YmVfanNfMSIsImNvbnN0cnVjdG9yIiwic2NoZW1hIiwiJHJlZnMiLCJkZWZhdWx0IiwiYXJncyIsImFyZ3VtZW50cyIsInByb21pc2UiLCJwYXRoIiwiZXJyIiwib25vIiwiY2FsbGJhY2siLCJQcm9taXNlIiwicmVqZWN0IiwicGF0aFR5cGUiLCJpc0ZpbGVTeXN0ZW1QYXRoIiwiZnJvbUZpbGVTeXN0ZW1QYXRoIiwiJGlkIiwicGFyYW1zIiwicG9ydCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJjd2QiLCIkcmVmIiwiX2FkZCIsIm9wdGlvbnMiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImNvbnRpbnVlT25FcnJvciIsInN5bnRheCIsIl9yb290JFJlZiIsImlzSGFuZGxlZEVycm9yIiwiXyRyZWZzIiwic3RyaXBIYXNoIiwiYWRkRXJyb3IiLCJwYXJzZXIiLCJhcHBseSIsImZpbmFsaXplIiwiaW5zdGFuY2UiLCJlcnJvcnMiLCJKU09OUGFyc2VyRXJyb3JHcm91cCIsImdldFBhcnNlckVycm9ycyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\");\nexports[\"default\"] = normalizeArgs;\n/**\n * Normalizes the given arguments, accounting for optional args.\n */ function normalizeArgs(_args) {\n    let path, schema, options, callback;\n    const args = Array.prototype.slice.call(_args);\n    if (typeof args[args.length - 1] === \"function\") {\n        // The last parameter is a callback function\n        callback = args.pop();\n    }\n    if (typeof args[0] === \"string\") {\n        // The first parameter is the path\n        path = args[0];\n        if (typeof args[2] === \"object\") {\n            // The second parameter is the schema, and the third parameter is the options\n            schema = args[1];\n            options = args[2];\n        } else {\n            // The second parameter is the options\n            schema = undefined;\n            options = args[1];\n        }\n    } else {\n        // The first parameter is the schema\n        path = \"\";\n        schema = args[0];\n        options = args[1];\n    }\n    options = (0, options_js_1.getNewOptions)(options);\n    return {\n        path,\n        schema,\n        options,\n        callback\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvbm9ybWFsaXplLWFyZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsZUFBZUMsbUJBQU9BLENBQUMsa0dBQWM7QUFDM0NILGtCQUFlLEdBQUdLO0FBQ2xCOztDQUVDLEdBQ0QsU0FBU0EsY0FBY0MsS0FBSztJQUN4QixJQUFJQyxNQUFNQyxRQUFRQyxTQUFTQztJQUMzQixNQUFNQyxPQUFPQyxNQUFNQyxTQUFTLENBQUNDLEtBQUssQ0FBQ0MsSUFBSSxDQUFDVDtJQUN4QyxJQUFJLE9BQU9LLElBQUksQ0FBQ0EsS0FBS0ssTUFBTSxHQUFHLEVBQUUsS0FBSyxZQUFZO1FBQzdDLDRDQUE0QztRQUM1Q04sV0FBV0MsS0FBS00sR0FBRztJQUN2QjtJQUNBLElBQUksT0FBT04sSUFBSSxDQUFDLEVBQUUsS0FBSyxVQUFVO1FBQzdCLGtDQUFrQztRQUNsQ0osT0FBT0ksSUFBSSxDQUFDLEVBQUU7UUFDZCxJQUFJLE9BQU9BLElBQUksQ0FBQyxFQUFFLEtBQUssVUFBVTtZQUM3Qiw2RUFBNkU7WUFDN0VILFNBQVNHLElBQUksQ0FBQyxFQUFFO1lBQ2hCRixVQUFVRSxJQUFJLENBQUMsRUFBRTtRQUNyQixPQUNLO1lBQ0Qsc0NBQXNDO1lBQ3RDSCxTQUFTVTtZQUNUVCxVQUFVRSxJQUFJLENBQUMsRUFBRTtRQUNyQjtJQUNKLE9BQ0s7UUFDRCxvQ0FBb0M7UUFDcENKLE9BQU87UUFDUEMsU0FBU0csSUFBSSxDQUFDLEVBQUU7UUFDaEJGLFVBQVVFLElBQUksQ0FBQyxFQUFFO0lBQ3JCO0lBQ0FGLFVBQVUsQ0FBQyxHQUFHUCxhQUFhaUIsYUFBYSxFQUFFVjtJQUMxQyxPQUFPO1FBQ0hGO1FBQ0FDO1FBQ0FDO1FBQ0FDO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvbm9ybWFsaXplLWFyZ3MuanM/YjFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnMuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSBub3JtYWxpemVBcmdzO1xuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBhcmd1bWVudHMsIGFjY291bnRpbmcgZm9yIG9wdGlvbmFsIGFyZ3MuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3MoX2FyZ3MpIHtcbiAgICBsZXQgcGF0aCwgc2NoZW1hLCBvcHRpb25zLCBjYWxsYmFjaztcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoX2FyZ3MpO1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gVGhlIGxhc3QgcGFyYW1ldGVyIGlzIGEgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcGF0aFxuICAgICAgICBwYXRoID0gYXJnc1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzJdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGUgc2NoZW1hLCBhbmQgdGhlIHRoaXJkIHBhcmFtZXRlciBpcyB0aGUgb3B0aW9uc1xuICAgICAgICAgICAgc2NoZW1hID0gYXJnc1sxXTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzWzJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgIHNjaGVtYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIHRoZSBzY2hlbWFcbiAgICAgICAgcGF0aCA9IFwiXCI7XG4gICAgICAgIHNjaGVtYSA9IGFyZ3NbMF07XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgIH1cbiAgICBvcHRpb25zID0gKDAsIG9wdGlvbnNfanNfMS5nZXROZXdPcHRpb25zKShvcHRpb25zKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGNhbGxiYWNrLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJvcHRpb25zX2pzXzEiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIm5vcm1hbGl6ZUFyZ3MiLCJfYXJncyIsInBhdGgiLCJzY2hlbWEiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJsZW5ndGgiLCJwb3AiLCJ1bmRlZmluZWQiLCJnZXROZXdPcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getNewOptions = void 0;\nconst json_js_1 = __importDefault(__webpack_require__(/*! ./parsers/json.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\"));\nconst yaml_js_1 = __importDefault(__webpack_require__(/*! ./parsers/yaml.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\"));\nconst text_js_1 = __importDefault(__webpack_require__(/*! ./parsers/text.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\"));\nconst binary_js_1 = __importDefault(__webpack_require__(/*! ./parsers/binary.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\"));\nconst file_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/file.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\"));\nconst http_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/http.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\"));\nconst lodash_clonedeep_1 = __importDefault(__webpack_require__(/*! lodash.clonedeep */ \"(ssr)/./node_modules/lodash.clonedeep/index.js\"));\nconst getDefaults = ()=>{\n    const defaults = {\n        /**\n         * Determines how different types of files will be parsed.\n         *\n         * You can add additional parsers of your own, replace an existing one with\n         * your own implementation, or disable any parser by setting it to false.\n         */ parse: {\n            json: json_js_1.default,\n            yaml: yaml_js_1.default,\n            text: text_js_1.default,\n            binary: binary_js_1.default\n        },\n        /**\n         * Determines how JSON References will be resolved.\n         *\n         * You can add additional resolvers of your own, replace an existing one with\n         * your own implementation, or disable any resolver by setting it to false.\n         */ resolve: {\n            file: file_js_1.default,\n            http: http_js_1.default,\n            /**\n             * Determines whether external $ref pointers will be resolved.\n             * If this option is disabled, then none of above resolvers will be called.\n             * Instead, external $ref pointers will simply be ignored.\n             *\n             * @type {boolean}\n             */ external: true\n        },\n        /**\n         * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n         * causes it to keep processing as much as possible and then throw a single error that contains all errors\n         * that were encountered.\n         */ continueOnError: false,\n        /**\n         * Determines the types of JSON references that are allowed.\n         */ dereference: {\n            /**\n             * Dereference circular (recursive) JSON references?\n             * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n             * If \"ignore\", then circular references will not be dereferenced.\n             *\n             * @type {boolean|string}\n             */ circular: true,\n            /**\n             * A function, called for each path, which can return true to stop this path and all\n             * subpaths from being dereferenced further. This is useful in schemas where some\n             * subpaths contain literal $ref keys that should not be dereferenced.\n             *\n             * @type {function}\n             */ excludedPathMatcher: ()=>false,\n            referenceResolution: \"relative\"\n        }\n    };\n    return (0, lodash_clonedeep_1.default)(defaults);\n};\nconst getNewOptions = (options)=>{\n    const newOptions = getDefaults();\n    if (options) {\n        merge(newOptions, options);\n    }\n    return newOptions;\n};\nexports.getNewOptions = getNewOptions;\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param target - The object that we're populating\n * @param source - The options that are being merged\n * @returns\n */ function merge(target, source) {\n    if (isMergeable(source)) {\n        const keys = Object.keys(source);\n        for(let i = 0; i < keys.length; i++){\n            const key = keys[i];\n            const sourceSetting = source[key];\n            const targetSetting = target[key];\n            if (isMergeable(sourceSetting)) {\n                // It's a nested object, so merge it recursively\n                target[key] = merge(targetSetting || {}, sourceSetting);\n            } else if (sourceSetting !== undefined) {\n                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n                target[key] = sourceSetting;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param val\n * @returns\n */ function isMergeable(val) {\n    return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixNQUFNRyxZQUFZUixnQkFBZ0JTLG1CQUFPQSxDQUFDLDRHQUFtQjtBQUM3RCxNQUFNQyxZQUFZVixnQkFBZ0JTLG1CQUFPQSxDQUFDLDRHQUFtQjtBQUM3RCxNQUFNRSxZQUFZWCxnQkFBZ0JTLG1CQUFPQSxDQUFDLDRHQUFtQjtBQUM3RCxNQUFNRyxjQUFjWixnQkFBZ0JTLG1CQUFPQSxDQUFDLGdIQUFxQjtBQUNqRSxNQUFNSSxZQUFZYixnQkFBZ0JTLG1CQUFPQSxDQUFDLGdIQUFxQjtBQUMvRCxNQUFNSyxZQUFZZCxnQkFBZ0JTLG1CQUFPQSxDQUFDLGdIQUFxQjtBQUMvRCxNQUFNTSxxQkFBcUJmLGdCQUFnQlMsbUJBQU9BLENBQUMsd0VBQWtCO0FBQ3JFLE1BQU1PLGNBQWM7SUFDaEIsTUFBTUMsV0FBVztRQUNiOzs7OztTQUtDLEdBQ0RDLE9BQU87WUFDSEMsTUFBTVgsVUFBVVksT0FBTztZQUN2QkMsTUFBTVgsVUFBVVUsT0FBTztZQUN2QkUsTUFBTVgsVUFBVVMsT0FBTztZQUN2QkcsUUFBUVgsWUFBWVEsT0FBTztRQUMvQjtRQUNBOzs7OztTQUtDLEdBQ0RJLFNBQVM7WUFDTEMsTUFBTVosVUFBVU8sT0FBTztZQUN2Qk0sTUFBTVosVUFBVU0sT0FBTztZQUN2Qjs7Ozs7O2FBTUMsR0FDRE8sVUFBVTtRQUNkO1FBQ0E7Ozs7U0FJQyxHQUNEQyxpQkFBaUI7UUFDakI7O1NBRUMsR0FDREMsYUFBYTtZQUNUOzs7Ozs7YUFNQyxHQUNEQyxVQUFVO1lBQ1Y7Ozs7OzthQU1DLEdBQ0RDLHFCQUFxQixJQUFNO1lBQzNCQyxxQkFBcUI7UUFDekI7SUFDSjtJQUNBLE9BQU8sQ0FBQyxHQUFHakIsbUJBQW1CSyxPQUFPLEVBQUVIO0FBQzNDO0FBQ0EsTUFBTVYsZ0JBQWdCLENBQUMwQjtJQUNuQixNQUFNQyxhQUFhbEI7SUFDbkIsSUFBSWlCLFNBQVM7UUFDVEUsTUFBTUQsWUFBWUQ7SUFDdEI7SUFDQSxPQUFPQztBQUNYO0FBQ0E3QixxQkFBcUIsR0FBR0U7QUFDeEI7Ozs7OztDQU1DLEdBQ0QsU0FBUzRCLE1BQU1DLE1BQU0sRUFBRUMsTUFBTTtJQUN6QixJQUFJQyxZQUFZRCxTQUFTO1FBQ3JCLE1BQU1FLE9BQU9wQyxPQUFPb0MsSUFBSSxDQUFDRjtRQUN6QixJQUFLLElBQUlHLElBQUksR0FBR0EsSUFBSUQsS0FBS0UsTUFBTSxFQUFFRCxJQUFLO1lBQ2xDLE1BQU1FLE1BQU1ILElBQUksQ0FBQ0MsRUFBRTtZQUNuQixNQUFNRyxnQkFBZ0JOLE1BQU0sQ0FBQ0ssSUFBSTtZQUNqQyxNQUFNRSxnQkFBZ0JSLE1BQU0sQ0FBQ00sSUFBSTtZQUNqQyxJQUFJSixZQUFZSyxnQkFBZ0I7Z0JBQzVCLGdEQUFnRDtnQkFDaERQLE1BQU0sQ0FBQ00sSUFBSSxHQUFHUCxNQUFNUyxpQkFBaUIsQ0FBQyxHQUFHRDtZQUM3QyxPQUNLLElBQUlBLGtCQUFrQkUsV0FBVztnQkFDbEMsa0dBQWtHO2dCQUNsR1QsTUFBTSxDQUFDTSxJQUFJLEdBQUdDO1lBQ2xCO1FBQ0o7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxZQUFZUSxHQUFHO0lBQ3BCLE9BQU9BLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUSxDQUFFQSxDQUFBQSxlQUFlRyxNQUFLLEtBQU0sQ0FBRUgsQ0FBQUEsZUFBZUksSUFBRztBQUNwSCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvb3B0aW9ucy5qcz9hZWM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXROZXdPcHRpb25zID0gdm9pZCAwO1xuY29uc3QganNvbl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlcnMvanNvbi5qc1wiKSk7XG5jb25zdCB5YW1sX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2Vycy95YW1sLmpzXCIpKTtcbmNvbnN0IHRleHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZXJzL3RleHQuanNcIikpO1xuY29uc3QgYmluYXJ5X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2Vycy9iaW5hcnkuanNcIikpO1xuY29uc3QgZmlsZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc29sdmVycy9maWxlLmpzXCIpKTtcbmNvbnN0IGh0dHBfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXNvbHZlcnMvaHR0cC5qc1wiKSk7XG5jb25zdCBsb2Rhc2hfY2xvbmVkZWVwXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC5jbG9uZWRlZXBcIikpO1xuY29uc3QgZ2V0RGVmYXVsdHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGhvdyBkaWZmZXJlbnQgdHlwZXMgb2YgZmlsZXMgd2lsbCBiZSBwYXJzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgcGFyc2VycyBvZiB5b3VyIG93biwgcmVwbGFjZSBhbiBleGlzdGluZyBvbmUgd2l0aFxuICAgICAgICAgKiB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiwgb3IgZGlzYWJsZSBhbnkgcGFyc2VyIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZToge1xuICAgICAgICAgICAganNvbjoganNvbl9qc18xLmRlZmF1bHQsXG4gICAgICAgICAgICB5YW1sOiB5YW1sX2pzXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRfanNfMS5kZWZhdWx0LFxuICAgICAgICAgICAgYmluYXJ5OiBiaW5hcnlfanNfMS5kZWZhdWx0LFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgSlNPTiBSZWZlcmVuY2VzIHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFlvdSBjYW4gYWRkIGFkZGl0aW9uYWwgcmVzb2x2ZXJzIG9mIHlvdXIgb3duLCByZXBsYWNlIGFuIGV4aXN0aW5nIG9uZSB3aXRoXG4gICAgICAgICAqIHlvdXIgb3duIGltcGxlbWVudGF0aW9uLCBvciBkaXNhYmxlIGFueSByZXNvbHZlciBieSBzZXR0aW5nIGl0IHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzb2x2ZToge1xuICAgICAgICAgICAgZmlsZTogZmlsZV9qc18xLmRlZmF1bHQsXG4gICAgICAgICAgICBodHRwOiBodHRwX2pzXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGV4dGVybmFsICRyZWYgcG9pbnRlcnMgd2lsbCBiZSByZXNvbHZlZC5cbiAgICAgICAgICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIGRpc2FibGVkLCB0aGVuIG5vbmUgb2YgYWJvdmUgcmVzb2x2ZXJzIHdpbGwgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICogSW5zdGVhZCwgZXh0ZXJuYWwgJHJlZiBwb2ludGVycyB3aWxsIHNpbXBseSBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIEpTT04gU2NoZW1hICRSZWYgUGFyc2VyIHRocm93cyB0aGUgZmlyc3QgZXJyb3IgaXQgZW5jb3VudGVycy4gU2V0dGluZyBgY29udGludWVPbkVycm9yYCB0byBgdHJ1ZWBcbiAgICAgICAgICogY2F1c2VzIGl0IHRvIGtlZXAgcHJvY2Vzc2luZyBhcyBtdWNoIGFzIHBvc3NpYmxlIGFuZCB0aGVuIHRocm93IGEgc2luZ2xlIGVycm9yIHRoYXQgY29udGFpbnMgYWxsIGVycm9yc1xuICAgICAgICAgKiB0aGF0IHdlcmUgZW5jb3VudGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjb250aW51ZU9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZXMgb2YgSlNPTiByZWZlcmVuY2VzIHRoYXQgYXJlIGFsbG93ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXJlZmVyZW5jZToge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXJlZmVyZW5jZSBjaXJjdWxhciAocmVjdXJzaXZlKSBKU09OIHJlZmVyZW5jZXM/XG4gICAgICAgICAgICAgKiBJZiBmYWxzZSwgdGhlbiBhIHtAbGluayBSZWZlcmVuY2VFcnJvcn0gd2lsbCBiZSB0aHJvd24gaWYgYSBjaXJjdWxhciByZWZlcmVuY2UgaXMgZm91bmQuXG4gICAgICAgICAgICAgKiBJZiBcImlnbm9yZVwiLCB0aGVuIGNpcmN1bGFyIHJlZmVyZW5jZXMgd2lsbCBub3QgYmUgZGVyZWZlcmVuY2VkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2lyY3VsYXI6IHRydWUsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24sIGNhbGxlZCBmb3IgZWFjaCBwYXRoLCB3aGljaCBjYW4gcmV0dXJuIHRydWUgdG8gc3RvcCB0aGlzIHBhdGggYW5kIGFsbFxuICAgICAgICAgICAgICogc3VicGF0aHMgZnJvbSBiZWluZyBkZXJlZmVyZW5jZWQgZnVydGhlci4gVGhpcyBpcyB1c2VmdWwgaW4gc2NoZW1hcyB3aGVyZSBzb21lXG4gICAgICAgICAgICAgKiBzdWJwYXRocyBjb250YWluIGxpdGVyYWwgJHJlZiBrZXlzIHRoYXQgc2hvdWxkIG5vdCBiZSBkZXJlZmVyZW5jZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHR5cGUge2Z1bmN0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBleGNsdWRlZFBhdGhNYXRjaGVyOiAoKSA9PiBmYWxzZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZVJlc29sdXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiAoMCwgbG9kYXNoX2Nsb25lZGVlcF8xLmRlZmF1bHQpKGRlZmF1bHRzKTtcbn07XG5jb25zdCBnZXROZXdPcHRpb25zID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gZ2V0RGVmYXVsdHMoKTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBtZXJnZShuZXdPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnM7XG59O1xuZXhwb3J0cy5nZXROZXdPcHRpb25zID0gZ2V0TmV3T3B0aW9ucztcbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBvYmplY3QgdGhhdCB3ZSdyZSBwb3B1bGF0aW5nXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIG9wdGlvbnMgdGhhdCBhcmUgYmVpbmcgbWVyZ2VkXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmIChpc01lcmdlYWJsZShzb3VyY2UpKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTZXR0aW5nID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRTZXR0aW5nID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICBpZiAoaXNNZXJnZWFibGUoc291cmNlU2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgbmVzdGVkIG9iamVjdCwgc28gbWVyZ2UgaXQgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFNldHRpbmcgfHwge30sIHNvdXJjZVNldHRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlU2V0dGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHNjYWxhciB2YWx1ZSwgZnVuY3Rpb24sIG9yIGFycmF5LiBObyBtZXJnaW5nIG5lY2Vzc2FyeS4gSnVzdCBvdmVyd3JpdGUgdGhlIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVNldHRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgbWVyZ2VkLFxuICogb3IgaWYgaXQgaXMgYSBzY2FsYXIgdmFsdWUgdGhhdCBzaG91bGQganVzdCBvdmVycmlkZSB0aGUgdGFyZ2V0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWxcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzTWVyZ2VhYmxlKHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmICEodmFsIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAhKHZhbCBpbnN0YW5jZW9mIERhdGUpO1xufVxuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImdldE5ld09wdGlvbnMiLCJqc29uX2pzXzEiLCJyZXF1aXJlIiwieWFtbF9qc18xIiwidGV4dF9qc18xIiwiYmluYXJ5X2pzXzEiLCJmaWxlX2pzXzEiLCJodHRwX2pzXzEiLCJsb2Rhc2hfY2xvbmVkZWVwXzEiLCJnZXREZWZhdWx0cyIsImRlZmF1bHRzIiwicGFyc2UiLCJqc29uIiwiZGVmYXVsdCIsInlhbWwiLCJ0ZXh0IiwiYmluYXJ5IiwicmVzb2x2ZSIsImZpbGUiLCJodHRwIiwiZXh0ZXJuYWwiLCJjb250aW51ZU9uRXJyb3IiLCJkZXJlZmVyZW5jZSIsImNpcmN1bGFyIiwiZXhjbHVkZWRQYXRoTWF0Y2hlciIsInJlZmVyZW5jZVJlc29sdXRpb24iLCJvcHRpb25zIiwibmV3T3B0aW9ucyIsIm1lcmdlIiwidGFyZ2V0Iiwic291cmNlIiwiaXNNZXJnZWFibGUiLCJrZXlzIiwiaSIsImxlbmd0aCIsImtleSIsInNvdXJjZVNldHRpbmciLCJ0YXJnZXRTZXR0aW5nIiwidW5kZWZpbmVkIiwidmFsIiwiQXJyYXkiLCJpc0FycmF5IiwiUmVnRXhwIiwiRGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst plugins = __importStar(__webpack_require__(/*! ./util/plugins.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = parse;\n/**\n * Reads and parses the specified file path or URL.\n */ async function parse(path, $refs, options) {\n    // Remove the URL fragment, if any\n    path = url.stripHash(path);\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    const $ref = $refs._add(path);\n    // This \"file object\" will be passed to all resolvers and parsers.\n    const file = {\n        url: path,\n        extension: url.getExtension(path)\n    };\n    // Read the file and then parse the data\n    try {\n        const resolver = await readFile(file, options, $refs);\n        $ref.pathType = resolver.plugin.name;\n        file.data = resolver.result;\n        const parser = await parseFile(file, options, $refs);\n        $ref.value = parser.result;\n        return parser.result;\n    } catch (err) {\n        if ((0, errors_js_1.isHandledError)(err)) {\n            $ref.value = err;\n        }\n        throw err;\n    }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param options\n *\n * @returns\n * The promise resolves with the raw file contents and the resolver that was used.\n */ async function readFile(file, options, $refs) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    try {\n        const data = await plugins.run(resolvers, \"read\", file, $refs);\n        return data;\n    } catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedResolverError(file.url);\n        } else if (!err || !(\"error\" in err)) {\n            // Throw a generic, friendly error.\n            throw ono_1.ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`);\n        } else if (err.error instanceof errors_js_1.ResolverError) {\n            throw err.error;\n        } else {\n            throw new errors_js_1.ResolverError(err, file.url);\n        }\n    }\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param options\n *\n * @returns\n * The promise resolves with the parsed file contents and the parser that was used.\n */ async function parseFile(file, options, $refs) {\n    // console.log('Parsing %s', file.url);\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    try {\n        const parser = await plugins.run(parsers, \"parse\", file, $refs);\n        if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n            throw ono_1.ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`);\n        } else {\n            return parser;\n        }\n    } catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedParserError(file.url);\n        } else if (err && err.message && err.message.startsWith(\"Error parsing\")) {\n            throw err;\n        } else if (!err || !(\"error\" in err)) {\n            throw ono_1.ono.syntax(`Unable to parse ${file.url}`);\n        } else if (err.error instanceof errors_js_1.ParserError) {\n            throw err.error;\n        } else {\n            throw new errors_js_1.ParserError(err.error.message, file.url);\n        }\n    }\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param value\n * @returns\n */ function isEmpty(value) {\n    return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FB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STtZQUNoQyxNQUFNeEIsTUFBTWtDLEdBQUcsQ0FBQ0MsTUFBTSxDQUFDLENBQUMsZ0JBQWdCLEVBQUV0QixLQUFLWCxHQUFHLENBQUMsQ0FBQztRQUN4RCxPQUNLLElBQUlzQixJQUFJWSxLQUFLLFlBQVloQyxZQUFZMkMsV0FBVyxFQUFFO1lBQ25ELE1BQU12QixJQUFJWSxLQUFLO1FBQ25CLE9BQ0s7WUFDRCxNQUFNLElBQUloQyxZQUFZMkMsV0FBVyxDQUFDdkIsSUFBSVksS0FBSyxDQUFDUyxPQUFPLEVBQUVoQyxLQUFLWCxHQUFHO1FBQ2pFO0lBQ0o7QUFDSjtBQUNBOzs7OztDQUtDLEdBQ0QsU0FBU3lDLFFBQVFuRCxLQUFLO0lBQ2xCLE9BQVFBLFVBQVVYLGFBQ2IsT0FBT1csVUFBVSxZQUFZakIsT0FBT3lFLElBQUksQ0FBQ3hELE9BQU9pRCxNQUFNLEtBQUssS0FDM0QsT0FBT2pELFVBQVUsWUFBWUEsTUFBTXlELElBQUksR0FBR1IsTUFBTSxLQUFLLEtBQ3JEUyxPQUFPQyxRQUFRLENBQUMzRCxVQUFVQSxNQUFNaUQsTUFBTSxLQUFLO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZS5qcz83NDcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgcGx1Z2lucyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3BsdWdpbnMuanNcIikpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuLyoqXG4gKiBSZWFkcyBhbmQgcGFyc2VzIHRoZSBzcGVjaWZpZWQgZmlsZSBwYXRoIG9yIFVSTC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2UocGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICAvLyBSZW1vdmUgdGhlIFVSTCBmcmFnbWVudCwgaWYgYW55XG4gICAgcGF0aCA9IHVybC5zdHJpcEhhc2gocGF0aCk7XG4gICAgLy8gQWRkIGEgbmV3ICRSZWYgZm9yIHRoaXMgZmlsZSwgZXZlbiB0aG91Z2ggd2UgZG9uJ3QgaGF2ZSB0aGUgdmFsdWUgeWV0LlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHNpbXVsdGFuZW91c2x5IHJlYWQgJiBwYXJzZSB0aGUgc2FtZSBmaWxlIG11bHRpcGxlIHRpbWVzXG4gICAgY29uc3QgJHJlZiA9ICRyZWZzLl9hZGQocGF0aCk7XG4gICAgLy8gVGhpcyBcImZpbGUgb2JqZWN0XCIgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIHJlc29sdmVycyBhbmQgcGFyc2Vycy5cbiAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgIGV4dGVuc2lvbjogdXJsLmdldEV4dGVuc2lvbihwYXRoKSxcbiAgICB9O1xuICAgIC8vIFJlYWQgdGhlIGZpbGUgYW5kIHRoZW4gcGFyc2UgdGhlIGRhdGFcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKTtcbiAgICAgICAgJHJlZi5wYXRoVHlwZSA9IHJlc29sdmVyLnBsdWdpbi5uYW1lO1xuICAgICAgICBmaWxlLmRhdGEgPSByZXNvbHZlci5yZXN1bHQ7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBhcnNlRmlsZShmaWxlLCBvcHRpb25zLCAkcmVmcyk7XG4gICAgICAgICRyZWYudmFsdWUgPSBwYXJzZXIucmVzdWx0O1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAkcmVmLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4vKipcbiAqIFJlYWRzIHRoZSBnaXZlbiBmaWxlLCB1c2luZyB0aGUgY29uZmlndXJlZCByZXNvbHZlciBwbHVnaW5zXG4gKlxuICogQHBhcmFtIGZpbGUgICAgICAgICAgIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICogQHBhcmFtIGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gKiBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSByYXcgZmlsZSBjb250ZW50cyBhbmQgdGhlIHJlc29sdmVyIHRoYXQgd2FzIHVzZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1JlYWRpbmcgJXMnLCBmaWxlLnVybCk7XG4gICAgLy8gRmluZCB0aGUgcmVzb2x2ZXJzIHRoYXQgY2FuIHJlYWQgdGhpcyBmaWxlXG4gICAgbGV0IHJlc29sdmVycyA9IHBsdWdpbnMuYWxsKG9wdGlvbnMucmVzb2x2ZSk7XG4gICAgcmVzb2x2ZXJzID0gcGx1Z2lucy5maWx0ZXIocmVzb2x2ZXJzLCBcImNhblJlYWRcIiwgZmlsZSk7XG4gICAgLy8gUnVuIHRoZSByZXNvbHZlcnMsIGluIG9yZGVyLCB1bnRpbCBvbmUgb2YgdGhlbSBzdWNjZWVkc1xuICAgIHBsdWdpbnMuc29ydChyZXNvbHZlcnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwbHVnaW5zLnJ1bihyZXNvbHZlcnMsIFwicmVhZFwiLCBmaWxlLCAkcmVmcyk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyICYmIG9wdGlvbnMuY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuVW5tYXRjaGVkUmVzb2x2ZXJFcnJvcihmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWVyciB8fCAhKFwiZXJyb3JcIiBpbiBlcnIpKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhIGdlbmVyaWMsIGZyaWVuZGx5IGVycm9yLlxuICAgICAgICAgICAgdGhyb3cgb25vXzEub25vLnN5bnRheChgVW5hYmxlIHRvIHJlc29sdmUgJHJlZiBwb2ludGVyIFwiJHtmaWxlLnVybH1cImApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRocm93IHRoZSBvcmlnaW5hbCBlcnJvciwgaWYgaXQncyBvbmUgb2Ygb3VyIG93biAodXNlci1mcmllbmRseSkgZXJyb3JzLlxuICAgICAgICBlbHNlIGlmIChlcnIuZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnIuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuUmVzb2x2ZXJFcnJvcihlcnIsIGZpbGUudXJsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlJ3MgY29udGVudHMsIHVzaW5nIHRoZSBjb25maWd1cmVkIHBhcnNlciBwbHVnaW5zLlxuICpcbiAqIEBwYXJhbSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSBmaWxlLnVybCAgICAgICAtIFRoZSBmdWxsIFVSTCBvZiB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gKiBAcGFyYW0gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICogQHBhcmFtIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICogQHBhcmFtIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyc2VkIGZpbGUgY29udGVudHMgYW5kIHRoZSBwYXJzZXIgdGhhdCB3YXMgdXNlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1BhcnNpbmcgJXMnLCBmaWxlLnVybCk7XG4gICAgLy8gRmluZCB0aGUgcGFyc2VycyB0aGF0IGNhbiByZWFkIHRoaXMgZmlsZSB0eXBlLlxuICAgIC8vIElmIG5vbmUgb2YgdGhlIHBhcnNlcnMgYXJlIGFuIGV4YWN0IG1hdGNoIGZvciB0aGlzIGZpbGUsIHRoZW4gd2UnbGwgdHJ5IEFMTCBvZiB0aGVtLlxuICAgIC8vIFRoaXMgaGFuZGxlcyBzaXR1YXRpb25zIHdoZXJlIHRoZSBmaWxlIElTIGEgc3VwcG9ydGVkIHR5cGUsIGp1c3Qgd2l0aCBhbiB1bmtub3duIGV4dGVuc2lvbi5cbiAgICBjb25zdCBhbGxQYXJzZXJzID0gcGx1Z2lucy5hbGwob3B0aW9ucy5wYXJzZSk7XG4gICAgY29uc3QgZmlsdGVyZWRQYXJzZXJzID0gcGx1Z2lucy5maWx0ZXIoYWxsUGFyc2VycywgXCJjYW5QYXJzZVwiLCBmaWxlKTtcbiAgICBjb25zdCBwYXJzZXJzID0gZmlsdGVyZWRQYXJzZXJzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFBhcnNlcnMgOiBhbGxQYXJzZXJzO1xuICAgIC8vIFJ1biB0aGUgcGFyc2VycywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHN1Y2NlZWRzXG4gICAgcGx1Z2lucy5zb3J0KHBhcnNlcnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBsdWdpbnMucnVuKHBhcnNlcnMsIFwicGFyc2VcIiwgZmlsZSwgJHJlZnMpO1xuICAgICAgICBpZiAoIXBhcnNlci5wbHVnaW4uYWxsb3dFbXB0eSAmJiBpc0VtcHR5KHBhcnNlci5yZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBvbm9fMS5vbm8uc3ludGF4KGBFcnJvciBwYXJzaW5nIFwiJHtmaWxlLnVybH1cIiBhcyAke3BhcnNlci5wbHVnaW4ubmFtZX0uIFxcblBhcnNlZCB2YWx1ZSBpcyBlbXB0eWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyICYmIG9wdGlvbnMuY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuVW5tYXRjaGVkUGFyc2VyRXJyb3IoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5zdGFydHNXaXRoKFwiRXJyb3IgcGFyc2luZ1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICAgICAgdGhyb3cgb25vXzEub25vLnN5bnRheChgVW5hYmxlIHRvIHBhcnNlICR7ZmlsZS51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVyci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlcnIuZXJyb3IubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnNlZCB2YWx1ZSBpcyBcImVtcHR5XCIuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKTtcbn1cbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwib25vXzEiLCJyZXF1aXJlIiwidXJsIiwicGx1Z2lucyIsImVycm9yc19qc18xIiwiZGVmYXVsdCIsInBhcnNlIiwicGF0aCIsIiRyZWZzIiwib3B0aW9ucyIsInN0cmlwSGFzaCIsIiRyZWYiLCJfYWRkIiwiZmlsZSIsImV4dGVuc2lvbiIsImdldEV4dGVuc2lvbiIsInJlc29sdmVyIiwicmVhZEZpbGUiLCJwYXRoVHlwZSIsInBsdWdpbiIsIm5hbWUiLCJkYXRhIiwicGFyc2VyIiwicGFyc2VGaWxlIiwiZXJyIiwiaXNIYW5kbGVkRXJyb3IiLCJyZXNvbHZlcnMiLCJhbGwiLCJyZXNvbHZlIiwiZmlsdGVyIiwic29ydCIsInJ1biIsImNvbnRpbnVlT25FcnJvciIsIlVubWF0Y2hlZFJlc29sdmVyRXJyb3IiLCJvbm8iLCJzeW50YXgiLCJlcnJvciIsIlJlc29sdmVyRXJyb3IiLCJhbGxQYXJzZXJzIiwiZmlsdGVyZWRQYXJzZXJzIiwicGFyc2VycyIsImxlbmd0aCIsImFsbG93RW1wdHkiLCJpc0VtcHR5IiwiVW5tYXRjaGVkUGFyc2VyRXJyb3IiLCJtZXNzYWdlIiwic3RhcnRzV2l0aCIsIlBhcnNlckVycm9yIiwia2V5cyIsInRyaW0iLCJCdWZmZXIiLCJpc0J1ZmZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */ order: 400,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */ allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */ canParse (file) {\n        // Use this parser if the file is a Buffer, and has a known binary extension\n        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given data as a Buffer (byte array).\n     */ parse (file) {\n        if (Buffer.isBuffer(file.data)) {\n            return file.data;\n        } else {\n            // This will reject if data is anything other than a string or typed array\n            return Buffer.from(file.data);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9iaW5hcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsZ0JBQWdCO0FBQ3RCRixrQkFBZSxHQUFHO0lBQ2Q7O0tBRUMsR0FDREksT0FBTztJQUNQOztLQUVDLEdBQ0RDLFlBQVk7SUFDWjs7Ozs7S0FLQyxHQUNEQyxVQUFTQyxJQUFJO1FBQ1QsNEVBQTRFO1FBQzVFLE9BQU9DLE9BQU9DLFFBQVEsQ0FBQ0YsS0FBS0csSUFBSSxLQUFLUixjQUFjUyxJQUFJLENBQUNKLEtBQUtLLEdBQUc7SUFDcEU7SUFDQTs7S0FFQyxHQUNEQyxPQUFNTixJQUFJO1FBQ04sSUFBSUMsT0FBT0MsUUFBUSxDQUFDRixLQUFLRyxJQUFJLEdBQUc7WUFDNUIsT0FBT0gsS0FBS0csSUFBSTtRQUNwQixPQUNLO1lBQ0QsMEVBQTBFO1lBQzFFLE9BQU9GLE9BQU9NLElBQUksQ0FBQ1AsS0FBS0csSUFBSTtRQUNoQztJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3BhcnNlcnMvYmluYXJ5LmpzPzgwYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCSU5BUllfUkVHRVhQID0gL1xcLihqcGVnfGpwZ3xnaWZ8cG5nfGJtcHxpY28pJC9pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMgKHplcm8gYnl0ZXMpLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAgICogUGFyc2VycyB0aGF0IHJldHVybiBmYWxzZSB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBhbGwgcGFyc2VycyByZXR1cm5lZCBmYWxzZSwgaW4gd2hpY2ggY2FzZVxuICAgICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgICAqL1xuICAgIGNhblBhcnNlKGZpbGUpIHtcbiAgICAgICAgLy8gVXNlIHRoaXMgcGFyc2VyIGlmIHRoZSBmaWxlIGlzIGEgQnVmZmVyLCBhbmQgaGFzIGEga25vd24gYmluYXJ5IGV4dGVuc2lvblxuICAgICAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkgJiYgQklOQVJZX1JFR0VYUC50ZXN0KGZpbGUudXJsKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZGF0YSBhcyBhIEJ1ZmZlciAoYnl0ZSBhcnJheSkuXG4gICAgICovXG4gICAgcGFyc2UoZmlsZSkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgcmVqZWN0IGlmIGRhdGEgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBhIHN0cmluZyBvciB0eXBlZCBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpbGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJJTkFSWV9SRUdFWFAiLCJkZWZhdWx0Iiwib3JkZXIiLCJhbGxvd0VtcHR5IiwiY2FuUGFyc2UiLCJmaWxlIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJkYXRhIiwidGVzdCIsInVybCIsInBhcnNlIiwiZnJvbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */ order: 100,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */ allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */ canParse: \".json\",\n    /**\n     * Parses the given file as JSON\n     */ async parse (file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            if (data.trim().length === 0) {\n                return; // This mirrors the YAML behavior\n            } else {\n                try {\n                    return JSON.parse(data);\n                } catch (e) {\n                    throw new errors_js_1.ParserError(e.message, file.url);\n                }\n            }\n        } else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGNBQWNDLG1CQUFPQSxDQUFDLDJHQUFtQjtBQUMvQ0gsa0JBQWUsR0FBRztJQUNkOztLQUVDLEdBQ0RLLE9BQU87SUFDUDs7S0FFQyxHQUNEQyxZQUFZO0lBQ1o7Ozs7O0tBS0MsR0FDREMsVUFBVTtJQUNWOztLQUVDLEdBQ0QsTUFBTUMsT0FBTUMsSUFBSTtRQUNaLElBQUlDLE9BQU9ELEtBQUtDLElBQUk7UUFDcEIsSUFBSUMsT0FBT0MsUUFBUSxDQUFDRixPQUFPO1lBQ3ZCQSxPQUFPQSxLQUFLRyxRQUFRO1FBQ3hCO1FBQ0EsSUFBSSxPQUFPSCxTQUFTLFVBQVU7WUFDMUIsSUFBSUEsS0FBS0ksSUFBSSxHQUFHQyxNQUFNLEtBQUssR0FBRztnQkFDMUIsUUFBUSxpQ0FBaUM7WUFDN0MsT0FDSztnQkFDRCxJQUFJO29CQUNBLE9BQU9DLEtBQUtSLEtBQUssQ0FBQ0U7Z0JBQ3RCLEVBQ0EsT0FBT08sR0FBRztvQkFDTixNQUFNLElBQUlmLFlBQVlnQixXQUFXLENBQUNELEVBQUVFLE9BQU8sRUFBRVYsS0FBS1csR0FBRztnQkFDekQ7WUFDSjtRQUNKLE9BQ0s7WUFDRCw4RUFBOEU7WUFDOUUsT0FBT1Y7UUFDWDtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3BhcnNlcnMvanNvbi5qcz9mYzgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9lcnJvcnMuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoYXQgdGhpcyBwYXJzZXIgd2lsbCBydW4sIGluIHJlbGF0aW9uIHRvIG90aGVyIHBhcnNlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGFsbG93IFwiZW1wdHlcIiBmaWxlcy4gVGhpcyBpbmNsdWRlcyB6ZXJvLWJ5dGUgZmlsZXMsIGFzIHdlbGwgYXMgZW1wdHkgSlNPTiBvYmplY3RzLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFBhcnNlcnMgdGhhdCBtYXRjaCB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAgICogUGFyc2VycyB0aGF0IGRvbid0IG1hdGNoIHdpbGwgYmUgc2tpcHBlZCwgVU5MRVNTIG5vbmUgb2YgdGhlIHBhcnNlcnMgbWF0Y2gsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBldmVyeSBwYXJzZXIgd2lsbCBiZSB0cmllZC5cbiAgICAgKi9cbiAgICBjYW5QYXJzZTogXCIuanNvblwiLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSBhcyBKU09OXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UoZmlsZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGZpbGUuZGF0YTtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRoaXMgbWlycm9ycyB0aGUgWUFNTCBiZWhhdmlvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlLm1lc3NhZ2UsIGZpbGUudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkYXRhIGlzIGFscmVhZHkgYSBKYXZhU2NyaXB0IHZhbHVlIChvYmplY3QsIGFycmF5LCBudW1iZXIsIG51bGwsIE5hTiwgZXRjLilcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlcnJvcnNfanNfMSIsInJlcXVpcmUiLCJkZWZhdWx0Iiwib3JkZXIiLCJhbGxvd0VtcHR5IiwiY2FuUGFyc2UiLCJwYXJzZSIsImZpbGUiLCJkYXRhIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJ0b1N0cmluZyIsInRyaW0iLCJsZW5ndGgiLCJKU09OIiwiZSIsIlBhcnNlckVycm9yIiwibWVzc2FnZSIsInVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */ order: 300,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */ allowEmpty: true,\n    /**\n     * The encoding that the text is expected to be in.\n     */ encoding: \"utf8\",\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */ canParse (file) {\n        // Use this parser if the file is a string or Buffer, and has a known text-based extension\n        return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given file as text\n     */ parse (file) {\n        if (typeof file.data === \"string\") {\n            return file.data;\n        } else if (Buffer.isBuffer(file.data)) {\n            return file.data.toString(this.encoding);\n        } else {\n            throw new errors_js_1.ParserError(\"data is not text\", file.url);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy90ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGNBQWNDLG1CQUFPQSxDQUFDLDJHQUFtQjtBQUMvQyxNQUFNQyxjQUFjO0FBQ3BCSixrQkFBZSxHQUFHO0lBQ2Q7O0tBRUMsR0FDRE0sT0FBTztJQUNQOztLQUVDLEdBQ0RDLFlBQVk7SUFDWjs7S0FFQyxHQUNEQyxVQUFVO0lBQ1Y7Ozs7O0tBS0MsR0FDREMsVUFBU0MsSUFBSTtRQUNULDBGQUEwRjtRQUMxRixPQUFPLENBQUMsT0FBT0EsS0FBS0MsSUFBSSxLQUFLLFlBQVlDLE9BQU9DLFFBQVEsQ0FBQ0gsS0FBS0MsSUFBSSxNQUFNUCxZQUFZVSxJQUFJLENBQUNKLEtBQUtLLEdBQUc7SUFDckc7SUFDQTs7S0FFQyxHQUNEQyxPQUFNTixJQUFJO1FBQ04sSUFBSSxPQUFPQSxLQUFLQyxJQUFJLEtBQUssVUFBVTtZQUMvQixPQUFPRCxLQUFLQyxJQUFJO1FBQ3BCLE9BQ0ssSUFBSUMsT0FBT0MsUUFBUSxDQUFDSCxLQUFLQyxJQUFJLEdBQUc7WUFDakMsT0FBT0QsS0FBS0MsSUFBSSxDQUFDTSxRQUFRLENBQUMsSUFBSSxDQUFDVCxRQUFRO1FBQzNDLE9BQ0s7WUFDRCxNQUFNLElBQUlOLFlBQVlnQixXQUFXLENBQUMsb0JBQW9CUixLQUFLSyxHQUFHO1FBQ2xFO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy90ZXh0LmpzPzIyZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmNvbnN0IFRFWFRfUkVHRVhQID0gL1xcLih0eHR8aHRtfGh0bWx8bWR8eG1sfGpzfG1pbnxtYXB8Y3NzfHNjc3N8bGVzc3xzdmcpJC9pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMgKHplcm8gYnl0ZXMpLlxuICAgICAqL1xuICAgIGFsbG93RW1wdHk6IHRydWUsXG4gICAgLyoqXG4gICAgICogVGhlIGVuY29kaW5nIHRoYXQgdGhlIHRleHQgaXMgZXhwZWN0ZWQgdG8gYmUgaW4uXG4gICAgICovXG4gICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHBhcnNlciBjYW4gcGFyc2UgYSBnaXZlbiBmaWxlIHJlZmVyZW5jZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcGFyc2VzIHRoZSBmaWxlLlxuICAgICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBiZSBza2lwcGVkLCBVTkxFU1MgYWxsIHBhcnNlcnMgcmV0dXJuZWQgZmFsc2UsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBldmVyeSBwYXJzZXIgd2lsbCBiZSB0cmllZC5cbiAgICAgKi9cbiAgICBjYW5QYXJzZShmaWxlKSB7XG4gICAgICAgIC8vIFVzZSB0aGlzIHBhcnNlciBpZiB0aGUgZmlsZSBpcyBhIHN0cmluZyBvciBCdWZmZXIsIGFuZCBoYXMgYSBrbm93biB0ZXh0LWJhc2VkIGV4dGVuc2lvblxuICAgICAgICByZXR1cm4gKHR5cGVvZiBmaWxlLmRhdGEgPT09IFwic3RyaW5nXCIgfHwgQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkpICYmIFRFWFRfUkVHRVhQLnRlc3QoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlIGFzIHRleHRcbiAgICAgKi9cbiAgICBwYXJzZShmaWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZS5kYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihmaWxlLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZS5kYXRhLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlBhcnNlckVycm9yKFwiZGF0YSBpcyBub3QgdGV4dFwiLCBmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVycm9yc19qc18xIiwicmVxdWlyZSIsIlRFWFRfUkVHRVhQIiwiZGVmYXVsdCIsIm9yZGVyIiwiYWxsb3dFbXB0eSIsImVuY29kaW5nIiwiY2FuUGFyc2UiLCJmaWxlIiwiZGF0YSIsIkJ1ZmZlciIsImlzQnVmZmVyIiwidGVzdCIsInVybCIsInBhcnNlIiwidG9TdHJpbmciLCJQYXJzZXJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst js_yaml_1 = __importDefault(__webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\"));\nconst js_yaml_2 = __webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */ order: 200,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */ allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */ canParse: [\n        \".yaml\",\n        \".yml\",\n        \".json\"\n    ],\n    /**\n     * Parses the given file as YAML\n     *\n     * @param file           - An object containing information about the referenced file\n     * @param file.url       - The full URL of the referenced file\n     * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n     * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n     * @returns\n     */ async parse (file) {\n        // eslint-disable-line require-await\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            try {\n                return js_yaml_1.default.load(data, {\n                    schema: js_yaml_2.JSON_SCHEMA\n                });\n            } catch (e) {\n                // @ts-expect-error TS(2571): Object is of type 'unknown'.\n                throw new errors_js_1.ParserError(e.message, file.url);\n            }\n        } else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy95YW1sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGNBQWNDLG1CQUFPQSxDQUFDLDJHQUFtQjtBQUMvQyxNQUFNQyxZQUFZVCxnQkFBZ0JRLG1CQUFPQSxDQUFDLHNEQUFTO0FBQ25ELE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLHNEQUFTO0FBQ25DSCxrQkFBZSxHQUFHO0lBQ2Q7O0tBRUMsR0FDRE8sT0FBTztJQUNQOztLQUVDLEdBQ0RDLFlBQVk7SUFDWjs7Ozs7S0FLQyxHQUNEQyxVQUFVO1FBQUM7UUFBUztRQUFRO0tBQVE7SUFDcEM7Ozs7Ozs7O0tBUUMsR0FDRCxNQUFNQyxPQUFNQyxJQUFJO1FBQ1osb0NBQW9DO1FBQ3BDLElBQUlDLE9BQU9ELEtBQUtDLElBQUk7UUFDcEIsSUFBSUMsT0FBT0MsUUFBUSxDQUFDRixPQUFPO1lBQ3ZCQSxPQUFPQSxLQUFLRyxRQUFRO1FBQ3hCO1FBQ0EsSUFBSSxPQUFPSCxTQUFTLFVBQVU7WUFDMUIsSUFBSTtnQkFDQSxPQUFPUixVQUFVRSxPQUFPLENBQUNVLElBQUksQ0FBQ0osTUFBTTtvQkFBRUssUUFBUVosVUFBVWEsV0FBVztnQkFBQztZQUN4RSxFQUNBLE9BQU9DLEdBQUc7Z0JBQ04sMERBQTBEO2dCQUMxRCxNQUFNLElBQUlqQixZQUFZa0IsV0FBVyxDQUFDRCxFQUFFRSxPQUFPLEVBQUVWLEtBQUtXLEdBQUc7WUFDekQ7UUFDSixPQUNLO1lBQ0QsOEVBQThFO1lBQzlFLE9BQU9WO1FBQ1g7SUFDSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL3lhbWwuanM/OGY1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvZXJyb3JzLmpzXCIpO1xuY29uc3QganNfeWFtbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqcy15YW1sXCIpKTtcbmNvbnN0IGpzX3lhbWxfMiA9IHJlcXVpcmUoXCJqcy15YW1sXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMuIFRoaXMgaW5jbHVkZXMgemVyby1ieXRlIGZpbGVzLCBhcyB3ZWxsIGFzIGVtcHR5IEpTT04gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhbGxvd0VtcHR5OiB0cnVlLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHBhcnNlciBjYW4gcGFyc2UgYSBnaXZlbiBmaWxlIHJlZmVyZW5jZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgbWF0Y2ggd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcGFyc2VzIHRoZSBmaWxlLlxuICAgICAqIFBhcnNlcnMgdGhhdCBkb24ndCBtYXRjaCB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBub25lIG9mIHRoZSBwYXJzZXJzIG1hdGNoLCBpbiB3aGljaCBjYXNlXG4gICAgICogZXZlcnkgcGFyc2VyIHdpbGwgYmUgdHJpZWQuXG4gICAgICovXG4gICAgY2FuUGFyc2U6IFtcIi55YW1sXCIsIFwiLnltbFwiLCBcIi5qc29uXCJdLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSBhcyBZQU1MXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gICAgICogQHBhcmFtIGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZS5leHRlbnNpb24gLSBUaGUgbG93ZXJjYXNlZCBmaWxlIGV4dGVuc2lvbiAoZS5nLiBcIi50eHRcIiwgXCIuaHRtbFwiLCBldGMuKVxuICAgICAqIEBwYXJhbSBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIHBhcnNlKGZpbGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgICAgIGxldCBkYXRhID0gZmlsZS5kYXRhO1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ganNfeWFtbF8xLmRlZmF1bHQubG9hZChkYXRhLCB7IHNjaGVtYToganNfeWFtbF8yLkpTT05fU0NIRU1BIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTKDI1NzEpOiBPYmplY3QgaXMgb2YgdHlwZSAndW5rbm93bicuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlBhcnNlckVycm9yKGUubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhbHJlYWR5IGEgSmF2YVNjcmlwdCB2YWx1ZSAob2JqZWN0LCBhcnJheSwgbnVtYmVyLCBudWxsLCBOYU4sIGV0Yy4pXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVycm9yc19qc18xIiwicmVxdWlyZSIsImpzX3lhbWxfMSIsImpzX3lhbWxfMiIsImRlZmF1bHQiLCJvcmRlciIsImFsbG93RW1wdHkiLCJjYW5QYXJzZSIsInBhcnNlIiwiZmlsZSIsImRhdGEiLCJCdWZmZXIiLCJpc0J1ZmZlciIsInRvU3RyaW5nIiwibG9hZCIsInNjaGVtYSIsIkpTT05fU0NIRU1BIiwiZSIsIlBhcnNlckVycm9yIiwibWVzc2FnZSIsInVybCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param $ref\n * @param path\n * @param [friendlyPath] - The original user-specified path (used for error messages)\n * @class\n */ class Pointer {\n    constructor($ref, path, friendlyPath){\n        this.$ref = $ref;\n        this.path = path;\n        this.originalPath = friendlyPath || path;\n        this.value = undefined;\n        this.circular = false;\n        this.indirections = 0;\n    }\n    /**\n     * Resolves the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param options\n     * @param pathFromRoot - the path of place that initiated resolving\n     *\n     * @returns\n     * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n     * If resolving this value required resolving other JSON references, then\n     * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n     * of the resolved value.\n     */ resolve(obj, options, pathFromRoot) {\n        const tokens = Pointer.parse(this.path, this.originalPath);\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for(let i = 0; i < tokens.length; i++){\n            if (resolveIf$Ref(this, options)) {\n                // The $ref path has changed, so append the remaining tokens to the path\n                this.path = Pointer.join(this.path, tokens.slice(i));\n            }\n            if (typeof this.value === \"object\" && this.value !== null && \"$ref\" in this.value) {\n                return this;\n            }\n            const token = tokens[i];\n            if (this.value[token] === undefined || this.value[token] === null) {\n                this.value = null;\n                throw new errors_js_1.MissingPointerError(token, decodeURI(this.originalPath));\n            } else {\n                this.value = this.value[token];\n            }\n        }\n        // Resolve the final value\n        if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {\n            resolveIf$Ref(this, options);\n        }\n        return this;\n    }\n    /**\n     * Sets the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param value - the value to assign\n     * @param options\n     *\n     * @returns\n     * Returns the modified object, or an entirely new object if the entire object is overwritten.\n     */ set(obj, value, options) {\n        const tokens = Pointer.parse(this.path);\n        let token;\n        if (tokens.length === 0) {\n            // There are no tokens, replace the entire object with the new value\n            this.value = value;\n            return value;\n        }\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for(let i = 0; i < tokens.length - 1; i++){\n            resolveIf$Ref(this, options);\n            token = tokens[i];\n            if (this.value && this.value[token] !== undefined) {\n                // The token exists\n                this.value = this.value[token];\n            } else {\n                // The token doesn't exist, so create it\n                this.value = setValue(this, token, {});\n            }\n        }\n        // Set the value of the final token\n        resolveIf$Ref(this, options);\n        token = tokens[tokens.length - 1];\n        setValue(this, token, value);\n        // Return the updated object\n        return obj;\n    }\n    /**\n     * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n     * and returns an array of the pointer's tokens.\n     * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n     *\n     * The pointer is parsed according to RFC 6901\n     * {@link https://tools.ietf.org/html/rfc6901#section-3}\n     *\n     * @param path\n     * @param [originalPath]\n     * @returns\n     */ static parse(path, originalPath) {\n        // Get the JSON pointer from the path's hash\n        let pointer = url.getHash(path).substr(1);\n        // If there's no pointer, then there are no tokens,\n        // so return an empty array\n        if (!pointer) {\n            return [];\n        }\n        // Split into an array\n        pointer = pointer.split(\"/\");\n        // Decode each part, according to RFC 6901\n        for(let i = 0; i < pointer.length; i++){\n            pointer[i] = decodeURIComponent(pointer[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n        }\n        if (pointer[0] !== \"\") {\n            throw new errors_js_1.InvalidPointerError(pointer, originalPath === undefined ? path : originalPath);\n        }\n        return pointer.slice(1);\n    }\n    /**\n     * Creates a JSON pointer path, by joining one or more tokens to a base path.\n     *\n     * @param base - The base path (e.g. \"schema.json#/definitions/person\")\n     * @param tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n     * @returns\n     */ static join(base, tokens) {\n        // Ensure that the base path contains a hash\n        if (base.indexOf(\"#\") === -1) {\n            base += \"#\";\n        }\n        // Append each token to the base path\n        tokens = Array.isArray(tokens) ? tokens : [\n            tokens\n        ];\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Encode the token, according to RFC 6901\n            base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n        }\n        return base;\n    }\n}\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param pointer\n * @param options\n * @returns - Returns `true` if the resolution path changed\n */ function resolveIf$Ref(pointer, options) {\n    // Is the value a JSON reference? (and allowed?)\n    if (ref_js_1.default.isAllowed$Ref(pointer.value, options)) {\n        const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n        if ($refPath === pointer.path) {\n            // The value is a reference to itself, so there's nothing to do.\n            pointer.circular = true;\n        } else {\n            const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n            if (resolved === null) {\n                return false;\n            }\n            pointer.indirections += resolved.indirections + 1;\n            if (ref_js_1.default.isExtended$Ref(pointer.value)) {\n                // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n                // So the resolved path does NOT change.  Just the value does.\n                pointer.value = ref_js_1.default.dereference(pointer.value, resolved.value);\n                return false;\n            } else {\n                // Resolve the reference\n                pointer.$ref = resolved.$ref;\n                pointer.path = resolved.path;\n                pointer.value = resolved.value;\n            }\n            return true;\n        }\n    }\n}\nexports[\"default\"] = Pointer;\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param pointer - The JSON Pointer whose value will be modified\n * @param token - A JSON Pointer token that indicates how to modify `obj`\n * @param value - The value to assign\n * @returns - Returns the assigned value\n */ function setValue(pointer, token, value) {\n    if (pointer.value && typeof pointer.value === \"object\") {\n        if (token === \"-\" && Array.isArray(pointer.value)) {\n            pointer.value.push(value);\n        } else {\n            pointer.value[token] = value;\n        }\n    } else {\n        throw new errors_js_1.JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n    }\n    return value;\n}\nfunction unwrapOrThrow(value) {\n    if ((0, errors_js_1.isHandledError)(value)) {\n        throw value;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcG9pbnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxD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LEVBQUVyQyxLQUFLO0lBQ25DLElBQUkwQyxRQUFRMUMsS0FBSyxJQUFJLE9BQU8wQyxRQUFRMUMsS0FBSyxLQUFLLFVBQVU7UUFDcEQsSUFBSXFDLFVBQVUsT0FBT2MsTUFBTUMsT0FBTyxDQUFDVixRQUFRMUMsS0FBSyxHQUFHO1lBQy9DMEMsUUFBUTFDLEtBQUssQ0FBQzhELElBQUksQ0FBQzlEO1FBQ3ZCLE9BQ0s7WUFDRDBDLFFBQVExQyxLQUFLLENBQUNxQyxNQUFNLEdBQUdyQztRQUMzQjtJQUNKLE9BQ0s7UUFDRCxNQUFNLElBQUlZLFlBQVltRCxlQUFlLENBQUMsQ0FBQyw4QkFBOEIsRUFBRXJCLFFBQVF0QixJQUFJLENBQUMsaUJBQWlCLEVBQUVpQixNQUFNLGtCQUFrQixDQUFDO0lBQ3BJO0lBQ0EsT0FBT3JDO0FBQ1g7QUFDQSxTQUFTK0IsY0FBYy9CLEtBQUs7SUFDeEIsSUFBSSxDQUFDLEdBQUdZLFlBQVlvRCxjQUFjLEVBQUVoRSxRQUFRO1FBQ3hDLE1BQU1BO0lBQ1Y7SUFDQSxPQUFPQTtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wb2ludGVyLmpzPzhiODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9ycy5qc1wiKTtcbmNvbnN0IHNsYXNoZXMgPSAvXFwvL2c7XG5jb25zdCB0aWxkZXMgPSAvfi9nO1xuY29uc3QgZXNjYXBlZFNsYXNoID0gL34xL2c7XG5jb25zdCBlc2NhcGVkVGlsZGUgPSAvfjAvZztcbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIEpTT04gcG9pbnRlciBhbmQgaXRzIHJlc29sdmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAkcmVmXG4gKiBAcGFyYW0gcGF0aFxuICogQHBhcmFtIFtmcmllbmRseVBhdGhdIC0gVGhlIG9yaWdpbmFsIHVzZXItc3BlY2lmaWVkIHBhdGggKHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFBvaW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRyZWYsIHBhdGgsIGZyaWVuZGx5UGF0aCkge1xuICAgICAgICB0aGlzLiRyZWYgPSAkcmVmO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUGF0aCA9IGZyaWVuZGx5UGF0aCB8fCBwYXRoO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kaXJlY3Rpb25zID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGNyYXdsZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSB0aGUgcGF0aCBvZiBwbGFjZSB0aGF0IGluaXRpYXRlZCByZXNvbHZpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICogUmV0dXJucyBhIEpTT04gcG9pbnRlciB3aG9zZSB7QGxpbmsgUG9pbnRlciN2YWx1ZX0gaXMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIElmIHJlc29sdmluZyB0aGlzIHZhbHVlIHJlcXVpcmVkIHJlc29sdmluZyBvdGhlciBKU09OIHJlZmVyZW5jZXMsIHRoZW5cbiAgICAgKiB0aGUge0BsaW5rIFBvaW50ZXIjJHJlZn0gYW5kIHtAbGluayBQb2ludGVyI3BhdGh9IHdpbGwgcmVmbGVjdCB0aGUgcmVzb2x1dGlvbiBwYXRoXG4gICAgICogb2YgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIHJlc29sdmUob2JqLCBvcHRpb25zLCBwYXRoRnJvbVJvb3QpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gUG9pbnRlci5wYXJzZSh0aGlzLnBhdGgsIHRoaXMub3JpZ2luYWxQYXRoKTtcbiAgICAgICAgLy8gQ3Jhd2wgdGhlIG9iamVjdCwgb25lIHRva2VuIGF0IGEgdGltZVxuICAgICAgICB0aGlzLnZhbHVlID0gdW53cmFwT3JUaHJvdyhvYmopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVJZiRSZWYodGhpcywgb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgJHJlZiBwYXRoIGhhcyBjaGFuZ2VkLCBzbyBhcHBlbmQgdGhlIHJlbWFpbmluZyB0b2tlbnMgdG8gdGhlIHBhdGhcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBQb2ludGVyLmpvaW4odGhpcy5wYXRoLCB0b2tlbnMuc2xpY2UoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbHVlID09PSBcIm9iamVjdFwiICYmIHRoaXMudmFsdWUgIT09IG51bGwgJiYgXCIkcmVmXCIgaW4gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZVt0b2tlbl0gPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlW3Rva2VuXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5NaXNzaW5nUG9pbnRlckVycm9yKHRva2VuLCBkZWNvZGVVUkkodGhpcy5vcmlnaW5hbFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlW3Rva2VuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBmaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgKHRoaXMudmFsdWUuJHJlZiAmJiB1cmwucmVzb2x2ZSh0aGlzLnBhdGgsIHRoaXMudmFsdWUuJHJlZikgIT09IHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgICAgICAgIHJlc29sdmVJZiRSZWYodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGNyYXdsZWRcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICogUmV0dXJucyB0aGUgbW9kaWZpZWQgb2JqZWN0LCBvciBhbiBlbnRpcmVseSBuZXcgb2JqZWN0IGlmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIHNldChvYmosIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFBvaW50ZXIucGFyc2UodGhpcy5wYXRoKTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIHRva2VucywgcmVwbGFjZSB0aGUgZW50aXJlIG9iamVjdCB3aXRoIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmF3bCB0aGUgb2JqZWN0LCBvbmUgdG9rZW4gYXQgYSB0aW1lXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bndyYXBPclRocm93KG9iaik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZVt0b2tlbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0b2tlbiBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0b2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9rZW4gZG9lc24ndCBleGlzdCwgc28gY3JlYXRlIGl0XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNldFZhbHVlKHRoaXMsIHRva2VuLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZmluYWwgdG9rZW5cbiAgICAgICAgcmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBzZXRWYWx1ZSh0aGlzLCB0b2tlbiwgdmFsdWUpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHVwZGF0ZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIEpTT04gcG9pbnRlciAob3IgYSBwYXRoIGNvbnRhaW5pbmcgYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2gpXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50ZXIncyB0b2tlbnMuXG4gICAgICogKGUuZy4gXCJzY2hlbWEuanNvbiMvZGVmaW5pdGlvbnMvcGVyc29uL25hbWVcIiA9PiBbXCJkZWZpbml0aW9uc1wiLCBcInBlcnNvblwiLCBcIm5hbWVcIl0pXG4gICAgICpcbiAgICAgKiBUaGUgcG9pbnRlciBpcyBwYXJzZWQgYWNjb3JkaW5nIHRvIFJGQyA2OTAxXG4gICAgICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tM31cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICogQHBhcmFtIFtvcmlnaW5hbFBhdGhdXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2UocGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgSlNPTiBwb2ludGVyIGZyb20gdGhlIHBhdGgncyBoYXNoXG4gICAgICAgIGxldCBwb2ludGVyID0gdXJsLmdldEhhc2gocGF0aCkuc3Vic3RyKDEpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHBvaW50ZXIsIHRoZW4gdGhlcmUgYXJlIG5vIHRva2VucyxcbiAgICAgICAgLy8gc28gcmV0dXJuIGFuIGVtcHR5IGFycmF5XG4gICAgICAgIGlmICghcG9pbnRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwbGl0IGludG8gYW4gYXJyYXlcbiAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgICAgICAvLyBEZWNvZGUgZWFjaCBwYXJ0LCBhY2NvcmRpbmcgdG8gUkZDIDY5MDFcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludGVyW2ldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBvaW50ZXJbaV0ucmVwbGFjZShlc2NhcGVkU2xhc2gsIFwiL1wiKS5yZXBsYWNlKGVzY2FwZWRUaWxkZSwgXCJ+XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRlclswXSAhPT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLkludmFsaWRQb2ludGVyRXJyb3IocG9pbnRlciwgb3JpZ2luYWxQYXRoID09PSB1bmRlZmluZWQgPyBwYXRoIDogb3JpZ2luYWxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRlci5zbGljZSgxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEpTT04gcG9pbnRlciBwYXRoLCBieSBqb2luaW5nIG9uZSBvciBtb3JlIHRva2VucyB0byBhIGJhc2UgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiYXNlIC0gVGhlIGJhc2UgcGF0aCAoZS5nLiBcInNjaGVtYS5qc29uIy9kZWZpbml0aW9ucy9wZXJzb25cIilcbiAgICAgKiBAcGFyYW0gdG9rZW5zIC0gVGhlIHRva2VuKHMpIHRvIGFwcGVuZCAoZS5nLiBbXCJuYW1lXCIsIFwiZmlyc3RcIl0pXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgam9pbihiYXNlLCB0b2tlbnMpIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGJhc2UgcGF0aCBjb250YWlucyBhIGhhc2hcbiAgICAgICAgaWYgKGJhc2UuaW5kZXhPZihcIiNcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBiYXNlICs9IFwiI1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGVuZCBlYWNoIHRva2VuIHRvIHRoZSBiYXNlIHBhdGhcbiAgICAgICAgdG9rZW5zID0gQXJyYXkuaXNBcnJheSh0b2tlbnMpID8gdG9rZW5zIDogW3Rva2Vuc107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIEVuY29kZSB0aGUgdG9rZW4sIGFjY29yZGluZyB0byBSRkMgNjkwMVxuICAgICAgICAgICAgYmFzZSArPSBcIi9cIiArIGVuY29kZVVSSUNvbXBvbmVudCh0b2tlbi5yZXBsYWNlKHRpbGRlcywgXCJ+MFwiKS5yZXBsYWNlKHNsYXNoZXMsIFwifjFcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbn1cbi8qKlxuICogSWYgdGhlIGdpdmVuIHBvaW50ZXIncyB7QGxpbmsgUG9pbnRlciN2YWx1ZX0gaXMgYSBKU09OIHJlZmVyZW5jZSxcbiAqIHRoZW4gdGhlIHJlZmVyZW5jZSBpcyByZXNvbHZlZCBhbmQge0BsaW5rIFBvaW50ZXIjdmFsdWV9IGlzIHJlcGxhY2VkIHdpdGggdGhlIHJlc29sdmVkIHZhbHVlLlxuICogSW4gYWRkaXRpb24sIHtAbGluayBQb2ludGVyI3BhdGh9IGFuZCB7QGxpbmsgUG9pbnRlciMkcmVmfSBhcmUgdXBkYXRlZCB0byByZWZsZWN0IHRoZVxuICogcmVzb2x1dGlvbiBwYXRoIG9mIHRoZSBuZXcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHBvaW50ZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyAtIFJldHVybnMgYHRydWVgIGlmIHRoZSByZXNvbHV0aW9uIHBhdGggY2hhbmdlZFxuICovXG5mdW5jdGlvbiByZXNvbHZlSWYkUmVmKHBvaW50ZXIsIG9wdGlvbnMpIHtcbiAgICAvLyBJcyB0aGUgdmFsdWUgYSBKU09OIHJlZmVyZW5jZT8gKGFuZCBhbGxvd2VkPylcbiAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKHBvaW50ZXIudmFsdWUsIG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUocG9pbnRlci5wYXRoLCBwb2ludGVyLnZhbHVlLiRyZWYpO1xuICAgICAgICBpZiAoJHJlZlBhdGggPT09IHBvaW50ZXIucGF0aCkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGEgcmVmZXJlbmNlIHRvIGl0c2VsZiwgc28gdGhlcmUncyBub3RoaW5nIHRvIGRvLlxuICAgICAgICAgICAgcG9pbnRlci5jaXJjdWxhciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHBvaW50ZXIuJHJlZi4kcmVmcy5fcmVzb2x2ZSgkcmVmUGF0aCwgcG9pbnRlci5wYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIuaW5kaXJlY3Rpb25zICs9IHJlc29sdmVkLmluZGlyZWN0aW9ucyArIDE7XG4gICAgICAgICAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0V4dGVuZGVkJFJlZihwb2ludGVyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgSlNPTiByZWZlcmVuY2UgXCJleHRlbmRzXCIgdGhlIHJlc29sdmVkIHZhbHVlLCByYXRoZXIgdGhhbiBzaW1wbHkgcG9pbnRpbmcgdG8gaXQuXG4gICAgICAgICAgICAgICAgLy8gU28gdGhlIHJlc29sdmVkIHBhdGggZG9lcyBOT1QgY2hhbmdlLiAgSnVzdCB0aGUgdmFsdWUgZG9lcy5cbiAgICAgICAgICAgICAgICBwb2ludGVyLnZhbHVlID0gcmVmX2pzXzEuZGVmYXVsdC5kZXJlZmVyZW5jZShwb2ludGVyLnZhbHVlLCByZXNvbHZlZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgcG9pbnRlci4kcmVmID0gcmVzb2x2ZWQuJHJlZjtcbiAgICAgICAgICAgICAgICBwb2ludGVyLnBhdGggPSByZXNvbHZlZC5wYXRoO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIudmFsdWUgPSByZXNvbHZlZC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9pbnRlcjtcbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHRva2VuIHZhbHVlIG9mIHRoZSB7QGxpbmsgUG9pbnRlciN2YWx1ZX0uXG4gKlxuICogVGhlIHRva2VuIGlzIGV2YWx1YXRlZCBhY2NvcmRpbmcgdG8gUkZDIDY5MDEuXG4gKiB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi00fVxuICpcbiAqIEBwYXJhbSBwb2ludGVyIC0gVGhlIEpTT04gUG9pbnRlciB3aG9zZSB2YWx1ZSB3aWxsIGJlIG1vZGlmaWVkXG4gKiBAcGFyYW0gdG9rZW4gLSBBIEpTT04gUG9pbnRlciB0b2tlbiB0aGF0IGluZGljYXRlcyBob3cgdG8gbW9kaWZ5IGBvYmpgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduXG4gKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGFzc2lnbmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlKHBvaW50ZXIsIHRva2VuLCB2YWx1ZSkge1xuICAgIGlmIChwb2ludGVyLnZhbHVlICYmIHR5cGVvZiBwb2ludGVyLnZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheShwb2ludGVyLnZhbHVlKSkge1xuICAgICAgICAgICAgcG9pbnRlci52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50ZXIudmFsdWVbdG9rZW5dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5KU09OUGFyc2VyRXJyb3IoYEVycm9yIGFzc2lnbmluZyAkcmVmIHBvaW50ZXIgXCIke3BvaW50ZXIucGF0aH1cIi4gXFxuQ2Fubm90IHNldCBcIiR7dG9rZW59XCIgb2YgYSBub24tb2JqZWN0LmApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB1bndyYXBPclRocm93KHZhbHVlKSB7XG4gICAgaWYgKCgwLCBlcnJvcnNfanNfMS5pc0hhbmRsZWRFcnJvcikodmFsdWUpKSB7XG4gICAgICAgIHRocm93IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsInJlZl9qc18xIiwicmVxdWlyZSIsInVybCIsImVycm9yc19qc18xIiwic2xhc2hlcyIsInRpbGRlcyIsImVzY2FwZWRTbGFzaCIsImVzY2FwZWRUaWxkZSIsIlBvaW50ZXIiLCJjb25zdHJ1Y3RvciIsIiRyZWYiLCJwYXRoIiwiZnJpZW5kbHlQYXRoIiwib3JpZ2luYWxQYXRoIiwiY2lyY3VsYXIiLCJpbmRpcmVjdGlvbnMiLCJyZXNvbHZlIiwib2JqIiwib3B0aW9ucyIsInBhdGhGcm9tUm9vdCIsInRva2VucyIsInBhcnNlIiwidW53cmFwT3JUaHJvdyIsImkiLCJsZW5ndGgiLCJyZXNvbHZlSWYkUmVmIiwiam9pbiIsInNsaWNlIiwidG9rZW4iLCJNaXNzaW5nUG9pbnRlckVycm9yIiwiZGVjb2RlVVJJIiwic2V0Iiwic2V0VmFsdWUiLCJwb2ludGVyIiwiZ2V0SGFzaCIsInN1YnN0ciIsInNwbGl0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsIkludmFsaWRQb2ludGVyRXJyb3IiLCJiYXNlIiwiaW5kZXhPZiIsIkFycmF5IiwiaXNBcnJheSIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlZmF1bHQiLCJpc0FsbG93ZWQkUmVmIiwiJHJlZlBhdGgiLCJyZXNvbHZlZCIsIiRyZWZzIiwiX3Jlc29sdmUiLCJpc0V4dGVuZGVkJFJlZiIsImRlcmVmZXJlbmNlIiwicHVzaCIsIkpTT05QYXJzZXJFcnJvciIsImlzSGFuZGxlZEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst url_js_1 = __webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */ class $Ref {\n    constructor($refs){\n        /**\n         * List of all errors. Undefined if no errors.\n         */ this.errors = [];\n        this.$refs = $refs;\n    }\n    /**\n     * Pushes an error to errors array.\n     *\n     * @param err - The error to be pushed\n     * @returns\n     */ addError(err) {\n        if (this.errors === undefined) {\n            this.errors = [];\n        }\n        const existingErrors = this.errors.map(({ footprint })=>footprint);\n        // the path has been almost certainly set at this point,\n        // but just in case something went wrong, normalizeError injects path if necessary\n        // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n        if (\"errors\" in err && Array.isArray(err.errors)) {\n            this.errors.push(...err.errors.map(errors_js_1.normalizeError).filter(({ footprint })=>!existingErrors.includes(footprint)));\n        } else if (!(\"footprint\" in err) || !existingErrors.includes(err.footprint)) {\n            this.errors.push((0, errors_js_1.normalizeError)(err));\n        }\n    }\n    /**\n     * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns\n     */ exists(path, options) {\n        try {\n            this.resolve(path, options);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns - Returns the resolved value\n     */ get(path, options) {\n        return this.resolve(path, options)?.value;\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @param friendlyPath - The original user-specified path (used for error messages)\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @returns\n     */ resolve(path, options, friendlyPath, pathFromRoot) {\n        const pointer = new pointer_js_1.default(this, path, friendlyPath);\n        try {\n            return pointer.resolve(this.value, options, pathFromRoot);\n        } catch (err) {\n            if (!options || !options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                throw err;\n            }\n            if (err.path === null) {\n                err.path = (0, url_js_1.safePointerToPath)((0, url_js_1.getHash)(pathFromRoot));\n            }\n            if (err instanceof errors_js_1.InvalidPointerError) {\n                err.source = decodeURI((0, url_js_1.stripHash)(pathFromRoot));\n            }\n            this.addError(err);\n            return null;\n        }\n    }\n    /**\n     * Sets the value of a nested property within this {@link $Ref#value}.\n     * If the property, or any of its parents don't exist, they will be created.\n     *\n     * @param path - The full path of the property to set, optionally with a JSON pointer in the hash\n     * @param value - The value to assign\n     */ set(path, value) {\n        // @ts-expect-error TS(2554): Expected 3 arguments, but got 2.\n        const pointer = new pointer_js_1.default(this, path);\n        this.value = pointer.set(this.value, value);\n    }\n    /**\n     * Determines whether the given value is a JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */ static is$Ref(value) {\n        return value && typeof value === \"object\" && typeof value.$ref === \"string\" && value.$ref.length > 0;\n    }\n    /**\n     * Determines whether the given value is an external JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */ static isExternal$Ref(value) {\n        return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n    }\n    /**\n     * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n     * For example, if it references an external file, then options.resolve.external must be true.\n     *\n     * @param value - The value to inspect\n     * @param options\n     * @returns\n     */ static isAllowed$Ref(value, options) {\n        if (this.is$Ref(value)) {\n            if (value.$ref.substring(0, 2) === \"#/\" || value.$ref === \"#\") {\n                // It's a JSON Pointer reference, which is always allowed\n                return true;\n            } else if (value.$ref[0] !== \"#\" && (!options || options.resolve.external)) {\n                // It's an external reference, which is allowed by the options\n                return true;\n            }\n        }\n    }\n    /**\n     * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n     * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n     * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n     * value, plus the extra properties.\n     *\n     * @example: {\n       person: {\n         properties: {\n           firstName: { type: string }\n           lastName: { type: string }\n         }\n       }\n       employee: {\n         properties: {\n           $ref: #/person/properties\n           salary: { type: number }\n         }\n       }\n     }\n     *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n     *  property (salary).  The result is a NEW value that looks like this:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param value - The value to inspect\n     * @returns\n     */ static isExtended$Ref(value) {\n        return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n    }\n    /**\n     * Returns the resolved value of a JSON Reference.\n     * If necessary, the resolved value is merged with the JSON Reference to create a new object\n     *\n     * @example: {\n    person: {\n      properties: {\n        firstName: { type: string }\n        lastName: { type: string }\n      }\n    }\n    employee: {\n      properties: {\n        $ref: #/person/properties\n        salary: { type: number }\n      }\n    }\n    } When \"person\" and \"employee\" are merged, you end up with the following object:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param $ref - The JSON reference object (the one with the \"$ref\" property)\n     * @param resolvedValue - The resolved value, which can be any type\n     * @returns - Returns the dereferenced value\n     */ static dereference($ref, resolvedValue) {\n        if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n            const merged = {};\n            for (const key of Object.keys($ref)){\n                if (key !== \"$ref\") {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = $ref[key];\n                }\n            }\n            for (const key of Object.keys(resolvedValue)){\n                if (!(key in merged)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = resolvedValue[key];\n                }\n            }\n            return merged;\n        } else {\n            // Completely replace the original reference with the resolved value\n            return resolvedValue;\n        }\n    }\n}\nexports[\"default\"] = $Ref;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsa0JBQWtCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsZUFBZSxJQUFLLFNBQVVDLEdBQUc7SUFDakUsT0FBTyxPQUFRQSxJQUFJQyxVQUFVLEdBQUlELE1BQU07UUFBRSxXQUFXQTtJQUFJO0FBQzVEO0FBQ0FFLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLGVBQWVQLGdCQUFnQlEsbUJBQU9BLENBQUMsa0dBQWM7QUFDM0QsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMEdBQWtCO0FBQzlDLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLG9HQUFlO0FBQ3hDOzs7O0NBSUMsR0FDRCxNQUFNRztJQUNGQyxZQUFZQyxLQUFLLENBQUU7UUFDZjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7O0tBS0MsR0FDREUsU0FBU0MsR0FBRyxFQUFFO1FBQ1YsSUFBSSxJQUFJLENBQUNGLE1BQU0sS0FBS0csV0FBVztZQUMzQixJQUFJLENBQUNILE1BQU0sR0FBRyxFQUFFO1FBQ3BCO1FBQ0EsTUFBTUksaUJBQWlCLElBQUksQ0FBQ0osTUFBTSxDQUFDSyxHQUFHLENBQUMsQ0FBQyxFQUFFQyxTQUFTLEVBQUUsR0FBS0E7UUFDMUQsd0RBQXdEO1FBQ3hELGtGQUFrRjtRQUNsRiw0RkFBNEY7UUFDNUYsSUFBSSxZQUFZSixPQUFPSyxNQUFNQyxPQUFPLENBQUNOLElBQUlGLE1BQU0sR0FBRztZQUM5QyxJQUFJLENBQUNBLE1BQU0sQ0FBQ1MsSUFBSSxJQUFJUCxJQUFJRixNQUFNLENBQUNLLEdBQUcsQ0FBQ1YsWUFBWWUsY0FBYyxFQUFFQyxNQUFNLENBQUMsQ0FBQyxF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WUFDWDtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUNDLEdBQ0QsT0FBT0MsZUFBZS9DLEtBQUssRUFBRTtRQUN6QixPQUFPSyxLQUFLbUMsTUFBTSxDQUFDeEMsVUFBVUgsT0FBT21ELElBQUksQ0FBQ2hELE9BQU8wQyxNQUFNLEdBQUc7SUFDN0Q7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBOEJDLEdBQ0QsT0FBT08sWUFBWVIsSUFBSSxFQUFFUyxhQUFhLEVBQUU7UUFDcEMsSUFBSUEsaUJBQWlCLE9BQU9BLGtCQUFrQixZQUFZN0MsS0FBSzBDLGNBQWMsQ0FBQ04sT0FBTztZQUNqRixNQUFNVSxTQUFTLENBQUM7WUFDaEIsS0FBSyxNQUFNQyxPQUFPdkQsT0FBT21ELElBQUksQ0FBQ1AsTUFBTztnQkFDakMsSUFBSVcsUUFBUSxRQUFRO29CQUNoQixxSUFBcUk7b0JBQ3JJRCxNQUFNLENBQUNDLElBQUksR0FBR1gsSUFBSSxDQUFDVyxJQUFJO2dCQUMzQjtZQUNKO1lBQ0EsS0FBSyxNQUFNQSxPQUFPdkQsT0FBT21ELElBQUksQ0FBQ0UsZUFBZ0I7Z0JBQzFDLElBQUksQ0FBRUUsQ0FBQUEsT0FBT0QsTUFBSyxHQUFJO29CQUNsQixxSUFBcUk7b0JBQ3JJQSxNQUFNLENBQUNDLElBQUksR0FBR0YsYUFBYSxDQUFDRSxJQUFJO2dCQUNwQztZQUNKO1lBQ0EsT0FBT0Q7UUFDWCxPQUNLO1lBQ0Qsb0VBQW9FO1lBQ3BFLE9BQU9EO1FBQ1g7SUFDSjtBQUNKO0FBQ0FuRCxrQkFBZSxHQUFHTSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmLmpzPzQ5Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuY29uc3QgdXJsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIEpTT04gcmVmZXJlbmNlIGFuZCBpdHMgcmVzb2x2ZWQgdmFsdWUuXG4gKlxuICogQGNsYXNzXG4gKi9cbmNsYXNzICRSZWYge1xuICAgIGNvbnN0cnVjdG9yKCRyZWZzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGFsbCBlcnJvcnMuIFVuZGVmaW5lZCBpZiBubyBlcnJvcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLiRyZWZzID0gJHJlZnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlcnJvciB0byBlcnJvcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIHRvIGJlIHB1c2hlZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYWRkRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3JzID0gdGhpcy5lcnJvcnMubWFwKCh7IGZvb3RwcmludCB9KSA9PiBmb290cHJpbnQpO1xuICAgICAgICAvLyB0aGUgcGF0aCBoYXMgYmVlbiBhbG1vc3QgY2VydGFpbmx5IHNldCBhdCB0aGlzIHBvaW50LFxuICAgICAgICAvLyBidXQganVzdCBpbiBjYXNlIHNvbWV0aGluZyB3ZW50IHdyb25nLCBub3JtYWxpemVFcnJvciBpbmplY3RzIHBhdGggaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIG1vcmVvdmVyLCBjZXJ0YWluIGVycm9ycyBtaWdodCBwb2ludCBhdCB0aGUgc2FtZSBzcG90LCBzbyBmaWx0ZXIgdGhlbSBvdXQgdG8gcmVkdWNlIG5vaXNlXG4gICAgICAgIGlmIChcImVycm9yc1wiIGluIGVyciAmJiBBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKC4uLmVyci5lcnJvcnMubWFwKGVycm9yc19qc18xLm5vcm1hbGl6ZUVycm9yKS5maWx0ZXIoKHsgZm9vdHByaW50IH0pID0+ICFleGlzdGluZ0Vycm9ycy5pbmNsdWRlcyhmb290cHJpbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShcImZvb3RwcmludFwiIGluIGVycikgfHwgIWV4aXN0aW5nRXJyb3JzLmluY2x1ZGVzKGVyci5mb290cHJpbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKCgwLCBlcnJvcnNfanNfMS5ub3JtYWxpemVFcnJvcikoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBleGlzdHMgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZXhpc3RzKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIHdpdGhpbiB0aGlzIHtAbGluayAkUmVmI3ZhbHVlfSBhbmQgcmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmUocGF0aCwgb3B0aW9ucyk/LnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2Ugd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBmcmllbmRseVBhdGggLSBUaGUgb3JpZ2luYWwgdXNlci1zcGVjaWZpZWQgcGF0aCAodXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMpXG4gICAgICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIGBvYmpgIGZyb20gdGhlIHNjaGVtYSByb290XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZXNvbHZlKHBhdGgsIG9wdGlvbnMsIGZyaWVuZGx5UGF0aCwgcGF0aEZyb21Sb290KSB7XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgcG9pbnRlcl9qc18xLmRlZmF1bHQodGhpcywgcGF0aCwgZnJpZW5kbHlQYXRoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludGVyLnJlc29sdmUodGhpcy52YWx1ZSwgb3B0aW9ucywgcGF0aEZyb21Sb290KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuY29udGludWVPbkVycm9yIHx8ICEoMCwgZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3IpKGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlcnIucGF0aCA9ICgwLCB1cmxfanNfMS5zYWZlUG9pbnRlclRvUGF0aCkoKDAsIHVybF9qc18xLmdldEhhc2gpKHBhdGhGcm9tUm9vdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGVycm9yc19qc18xLkludmFsaWRQb2ludGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIuc291cmNlID0gZGVjb2RlVVJJKCgwLCB1cmxfanNfMS5zdHJpcEhhc2gpKHBhdGhGcm9tUm9vdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBuZXN0ZWQgcHJvcGVydHkgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICAgICAqIElmIHRoZSBwcm9wZXJ0eSwgb3IgYW55IG9mIGl0cyBwYXJlbnRzIGRvbid0IGV4aXN0LCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMoMjU1NCk6IEV4cGVjdGVkIDMgYXJndW1lbnRzLCBidXQgZ290IDIuXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgcG9pbnRlcl9qc18xLmRlZmF1bHQodGhpcywgcGF0aCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSBwb2ludGVyLnNldCh0aGlzLnZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBKU09OIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXMkUmVmKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLiRyZWYgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuJHJlZi5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGV4dGVybmFsIEpTT04gcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBpc0V4dGVybmFsJFJlZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJFJlZi5pcyRSZWYodmFsdWUpICYmIHZhbHVlLiRyZWZbMF0gIT09IFwiI1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgSlNPTiByZWZlcmVuY2UsIGFuZCB3aGV0aGVyIGl0IGlzIGFsbG93ZWQgYnkgdGhlIG9wdGlvbnMuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGl0IHJlZmVyZW5jZXMgYW4gZXh0ZXJuYWwgZmlsZSwgdGhlbiBvcHRpb25zLnJlc29sdmUuZXh0ZXJuYWwgbXVzdCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGlzQWxsb3dlZCRSZWYodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXMkUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLiRyZWYuc3Vic3RyaW5nKDAsIDIpID09PSBcIiMvXCIgfHwgdmFsdWUuJHJlZiA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgSlNPTiBQb2ludGVyIHJlZmVyZW5jZSwgd2hpY2ggaXMgYWx3YXlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLiRyZWZbMF0gIT09IFwiI1wiICYmICghb3B0aW9ucyB8fCBvcHRpb25zLnJlc29sdmUuZXh0ZXJuYWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhbiBleHRlcm5hbCByZWZlcmVuY2UsIHdoaWNoIGlzIGFsbG93ZWQgYnkgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgSlNPTiByZWZlcmVuY2UgdGhhdCBcImV4dGVuZHNcIiBpdHMgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogVGhhdCBpcywgaXQgaGFzIGV4dHJhIHByb3BlcnRpZXMgKGluIGFkZGl0aW9uIHRvIFwiJHJlZlwiKSwgc28gcmF0aGVyIHRoYW4gc2ltcGx5IHBvaW50aW5nIHRvXG4gICAgICogYW4gZXhpc3RpbmcgdmFsdWUsIHRoaXMgJHJlZiBhY3R1YWxseSBjcmVhdGVzIGEgTkVXIHZhbHVlIHRoYXQgaXMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHJlc29sdmVkXG4gICAgICogdmFsdWUsIHBsdXMgdGhlIGV4dHJhIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZToge1xuICAgICAgIHBlcnNvbjoge1xuICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICAgZW1wbG95ZWU6IHtcbiAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgJHJlZjogIy9wZXJzb24vcHJvcGVydGllc1xuICAgICAgICAgICBzYWxhcnk6IHsgdHlwZTogbnVtYmVyIH1cbiAgICAgICAgIH1cbiAgICAgICB9XG4gICAgIH1cbiAgICAgKiAgSW4gdGhpcyBleGFtcGxlLCBcImVtcGxveWVlXCIgaXMgYW4gZXh0ZW5kZWQgJHJlZiwgc2luY2UgaXQgZXh0ZW5kcyBcInBlcnNvblwiIHdpdGggYW4gYWRkaXRpb25hbFxuICAgICAqICBwcm9wZXJ0eSAoc2FsYXJ5KS4gIFRoZSByZXN1bHQgaXMgYSBORVcgdmFsdWUgdGhhdCBsb29rcyBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgIGZpcnN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAqICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgKiAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICAgICAqICAgIH1cbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBpc0V4dGVuZGVkJFJlZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJFJlZi5pcyRSZWYodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZSBvZiBhIEpTT04gUmVmZXJlbmNlLlxuICAgICAqIElmIG5lY2Vzc2FyeSwgdGhlIHJlc29sdmVkIHZhbHVlIGlzIG1lcmdlZCB3aXRoIHRoZSBKU09OIFJlZmVyZW5jZSB0byBjcmVhdGUgYSBuZXcgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZToge1xuICAgIHBlcnNvbjoge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZW1wbG95ZWU6IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgJHJlZjogIy9wZXJzb24vcHJvcGVydGllc1xuICAgICAgICBzYWxhcnk6IHsgdHlwZTogbnVtYmVyIH1cbiAgICAgIH1cbiAgICB9XG4gICAgfSBXaGVuIFwicGVyc29uXCIgYW5kIFwiZW1wbG95ZWVcIiBhcmUgbWVyZ2VkLCB5b3UgZW5kIHVwIHdpdGggdGhlIGZvbGxvd2luZyBvYmplY3Q6XG4gICAgICpcbiAgICAgKiAge1xuICAgICAqICAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgIGZpcnN0TmFtZTogeyB0eXBlOiBzdHJpbmcgfVxuICAgICAqICAgICAgbGFzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgKiAgICAgIHNhbGFyeTogeyB0eXBlOiBudW1iZXIgfVxuICAgICAqICAgIH1cbiAgICAgKiAgfVxuICAgICAqXG4gICAgICogQHBhcmFtICRyZWYgLSBUaGUgSlNPTiByZWZlcmVuY2Ugb2JqZWN0ICh0aGUgb25lIHdpdGggdGhlIFwiJHJlZlwiIHByb3BlcnR5KVxuICAgICAqIEBwYXJhbSByZXNvbHZlZFZhbHVlIC0gVGhlIHJlc29sdmVkIHZhbHVlLCB3aGljaCBjYW4gYmUgYW55IHR5cGVcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGRlcmVmZXJlbmNlZCB2YWx1ZVxuICAgICAqL1xuICAgIHN0YXRpYyBkZXJlZmVyZW5jZSgkcmVmLCByZXNvbHZlZFZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFZhbHVlICYmIHR5cGVvZiByZXNvbHZlZFZhbHVlID09PSBcIm9iamVjdFwiICYmICRSZWYuaXNFeHRlbmRlZCRSZWYoJHJlZikpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoJHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSBcIiRyZWZcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTKDcwNTMpOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGUgYmVjYXVzZSBleHByZS4uLiBSZW1vdmUgdGhpcyBjb21tZW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZFtrZXldID0gJHJlZltrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHJlc29sdmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG1lcmdlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyg3MDUzKTogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlIGJlY2F1c2UgZXhwcmUuLi4gUmVtb3ZlIHRoaXMgY29tbWVudCB0byBzZWUgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSA9IHJlc29sdmVkVmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29tcGxldGVseSByZXBsYWNlIHRoZSBvcmlnaW5hbCByZWZlcmVuY2Ugd2l0aCB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gJFJlZjtcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwb2ludGVyX2pzXzEiLCJyZXF1aXJlIiwiZXJyb3JzX2pzXzEiLCJ1cmxfanNfMSIsIiRSZWYiLCJjb25zdHJ1Y3RvciIsIiRyZWZzIiwiZXJyb3JzIiwiYWRkRXJyb3IiLCJlcnIiLCJ1bmRlZmluZWQiLCJleGlzdGluZ0Vycm9ycyIsIm1hcCIsImZvb3RwcmludCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJub3JtYWxpemVFcnJvciIsImZpbHRlciIsImluY2x1ZGVzIiwiZXhpc3RzIiwicGF0aCIsIm9wdGlvbnMiLCJyZXNvbHZlIiwiZSIsImdldCIsImZyaWVuZGx5UGF0aCIsInBhdGhGcm9tUm9vdCIsInBvaW50ZXIiLCJkZWZhdWx0IiwiY29udGludWVPbkVycm9yIiwiaXNIYW5kbGVkRXJyb3IiLCJzYWZlUG9pbnRlclRvUGF0aCIsImdldEhhc2giLCJJbnZhbGlkUG9pbnRlckVycm9yIiwic291cmNlIiwiZGVjb2RlVVJJIiwic3RyaXBIYXNoIiwic2V0IiwiaXMkUmVmIiwiJHJlZiIsImxlbmd0aCIsImlzRXh0ZXJuYWwkUmVmIiwiaXNBbGxvd2VkJFJlZiIsInN1YnN0cmluZyIsImV4dGVybmFsIiwiaXNFeHRlbmRlZCRSZWYiLCJrZXlzIiwiZGVyZWZlcmVuY2UiLCJyZXNvbHZlZFZhbHVlIiwibWVyZ2VkIiwia2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./util/convert-path-to-posix */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\n/**\n * When you call the resolve method, the value that gets passed to the callback function (or Promise) is a $Refs object. This same object is accessible via the parser.$refs property of $RefParser objects.\n *\n * This object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/refs.html\n */ class $Refs {\n    /**\n     * Returns the paths/URLs of all the files in your schema (including the main schema file).\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes\n     *\n     * @param types (optional) Optionally only return certain types of paths (\"file\", \"http\", etc.)\n     */ paths(...types) {\n        const paths = getPaths(this._$refs, types);\n        return paths.map((path)=>{\n            return (0, convert_path_to_posix_1.default)(path.decoded);\n        });\n    }\n    /**\n     * Returns a map of paths/URLs and their correspond values.\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes\n     *\n     * @param types (optional) Optionally only return values from certain locations (\"file\", \"http\", etc.)\n     */ values(...types) {\n        const $refs = this._$refs;\n        const paths = getPaths($refs, types);\n        return paths.reduce((obj, path)=>{\n            obj[(0, convert_path_to_posix_1.default)(path.decoded)] = $refs[path.encoded].value;\n            return obj;\n        }, {});\n    }\n    /**\n     * Returns `true` if the given path exists in the schema; otherwise, returns `false`\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref\n     *\n     * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n     */ /**\n     * Determines whether the given JSON reference exists.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param [options]\n     * @returns\n     */ exists(path, options) {\n        try {\n            this._resolve(path, \"\", options);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference and returns the resolved value.\n     *\n     * @param path - The path being resolved, with a JSON pointer in the hash\n     * @param [options]\n     * @returns - Returns the resolved value\n     */ get(path, options) {\n        return this._resolve(path, \"\", options).value;\n    }\n    /**\n     * Sets the value at the given path in the schema. If the property, or any of its parents, don't exist, they will be created.\n     *\n     * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n     * @param value The value to assign. Can be anything (object, string, number, etc.)\n     */ set(path, value) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        $ref.set(absPath, value);\n    }\n    /**\n     * Returns the specified {@link $Ref} object, or undefined.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @returns\n     * @protected\n     */ _get$Ref(path) {\n        path = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(path);\n        return this._$refs[withoutHash];\n    }\n    /**\n     * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n     *\n     * @param path  - The file path or URL of the referenced file\n     */ _add(path) {\n        const withoutHash = url.stripHash(path);\n        const $ref = new ref_js_1.default(this);\n        $ref.path = withoutHash;\n        this._$refs[withoutHash] = $ref;\n        this._root$Ref = this._root$Ref || $ref;\n        return $ref;\n    }\n    /**\n     * Resolves the given JSON reference.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @param [options]\n     * @returns\n     * @protected\n     */ _resolve(path, pathFromRoot, options) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        return $ref.resolve(absPath, options, path, pathFromRoot);\n    }\n    constructor(){\n        /**\n         * A map of paths/urls to {@link $Ref} objects\n         *\n         * @type {object}\n         * @protected\n         */ this._$refs = {};\n        /**\n         * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n         * including the schema itself.\n         *\n         * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */ /**\n         * Returns the map of JSON references and their resolved values.\n         *\n         * @param [types] - Only return references of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */ /**\n         * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n         *\n         * @returns {object}\n         */ this.toJSON = this.values;\n        /**\n         * Indicates whether the schema contains any circular references.\n         *\n         * @type {boolean}\n         */ this.circular = false;\n        this._$refs = {};\n        // @ts-ignore\n        this._root$Ref = null;\n    }\n}\nexports[\"default\"] = $Refs;\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param $refs - The object whose keys are URL-encoded paths\n * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns\n */ function getPaths($refs, types) {\n    let paths = Object.keys($refs);\n    // Filter the paths by type\n    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n    if (types.length > 0 && types[0]) {\n        paths = paths.filter((key)=>{\n            return types.includes($refs[key].pathType);\n        });\n    }\n    // Decode local filesystem paths\n    return paths.map((path)=>{\n        return {\n            encoded: path,\n            decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n        };\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFBSUUsZUFBZSxDQUFD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QUksQ0FBQ3JCLE1BQU07UUFDekI7Ozs7U0FJQyxHQUNELElBQUksQ0FBQ3NCLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUMzQixNQUFNLEdBQUcsQ0FBQztRQUNmLGFBQWE7UUFDYixJQUFJLENBQUNpQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBM0Isa0JBQWUsR0FBR007QUFDbEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0csU0FBU08sS0FBSyxFQUFFUixLQUFLO0lBQzFCLElBQUlELFFBQVFoQyxPQUFPK0QsSUFBSSxDQUFDdEI7SUFDeEIsMkJBQTJCO0lBQzNCUixRQUFRK0IsTUFBTUMsT0FBTyxDQUFDaEMsS0FBSyxDQUFDLEVBQUUsSUFBSUEsS0FBSyxDQUFDLEVBQUUsR0FBRytCLE1BQU0zQyxTQUFTLENBQUM2QyxLQUFLLENBQUMzQyxJQUFJLENBQUNVO0lBQ3hFLElBQUlBLE1BQU1rQyxNQUFNLEdBQUcsS0FBS2xDLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDOUJELFFBQVFBLE1BQU1vQyxNQUFNLENBQUMsQ0FBQ0M7WUFDbEIsT0FBT3BDLE1BQU1xQyxRQUFRLENBQUM3QixLQUFLLENBQUM0QixJQUFJLENBQUNFLFFBQVE7UUFDN0M7SUFDSjtJQUNBLGdDQUFnQztJQUNoQyxPQUFPdkMsTUFBTUksR0FBRyxDQUFDLENBQUNDO1FBQ2QsT0FBTztZQUNITyxTQUFTUDtZQUNURSxTQUFTRSxLQUFLLENBQUNKLEtBQUssQ0FBQ2tDLFFBQVEsS0FBSyxTQUFTMUMsSUFBSTJDLGdCQUFnQixDQUFDbkMsTUFBTSxRQUFRQTtRQUNsRjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3JlZnMuanM/MGMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2NvbnZlcnQtcGF0aC10by1wb3NpeFwiKSk7XG4vKipcbiAqIFdoZW4geW91IGNhbGwgdGhlIHJlc29sdmUgbWV0aG9kLCB0aGUgdmFsdWUgdGhhdCBnZXRzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKG9yIFByb21pc2UpIGlzIGEgJFJlZnMgb2JqZWN0LiBUaGlzIHNhbWUgb2JqZWN0IGlzIGFjY2Vzc2libGUgdmlhIHRoZSBwYXJzZXIuJHJlZnMgcHJvcGVydHkgb2YgJFJlZlBhcnNlciBvYmplY3RzLlxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIGEgbWFwIG9mIEpTT04gUmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLiBJdCBhbHNvIGhhcyBzZXZlcmFsIGNvbnZlbmllbnQgaGVscGVyIG1ldGhvZHMgdGhhdCBtYWtlIGl0IGVhc3kgZm9yIHlvdSB0byBuYXZpZ2F0ZSBhbmQgbWFuaXB1bGF0ZSB0aGUgSlNPTiBSZWZlcmVuY2VzLlxuICpcbiAqIFNlZSBodHRwczovL2FwaXRvb2xzLmRldi9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2RvY3MvcmVmcy5odG1sXG4gKi9cbmNsYXNzICRSZWZzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXRocy9VUkxzIG9mIGFsbCB0aGUgZmlsZXMgaW4geW91ciBzY2hlbWEgKGluY2x1ZGluZyB0aGUgbWFpbiBzY2hlbWEgZmlsZSkuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCNwYXRoc3R5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZXMgKG9wdGlvbmFsKSBPcHRpb25hbGx5IG9ubHkgcmV0dXJuIGNlcnRhaW4gdHlwZXMgb2YgcGF0aHMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgKi9cbiAgICBwYXRocyguLi50eXBlcykge1xuICAgICAgICBjb25zdCBwYXRocyA9IGdldFBhdGhzKHRoaXMuXyRyZWZzLCB0eXBlcyk7XG4gICAgICAgIHJldHVybiBwYXRocy5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY29udmVydF9wYXRoX3RvX3Bvc2l4XzEuZGVmYXVsdCkocGF0aC5kZWNvZGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgcGF0aHMvVVJMcyBhbmQgdGhlaXIgY29ycmVzcG9uZCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCN2YWx1ZXN0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVzIChvcHRpb25hbCkgT3B0aW9uYWxseSBvbmx5IHJldHVybiB2YWx1ZXMgZnJvbSBjZXJ0YWluIGxvY2F0aW9ucyAoXCJmaWxlXCIsIFwiaHR0cFwiLCBldGMuKVxuICAgICAqL1xuICAgIHZhbHVlcyguLi50eXBlcykge1xuICAgICAgICBjb25zdCAkcmVmcyA9IHRoaXMuXyRyZWZzO1xuICAgICAgICBjb25zdCBwYXRocyA9IGdldFBhdGhzKCRyZWZzLCB0eXBlcyk7XG4gICAgICAgIHJldHVybiBwYXRocy5yZWR1Y2UoKG9iaiwgcGF0aCkgPT4ge1xuICAgICAgICAgICAgb2JqWygwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KShwYXRoLmRlY29kZWQpXSA9ICRyZWZzW3BhdGguZW5jb2RlZF0udmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBpbiB0aGUgc2NoZW1hOyBvdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYFxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vYXBpdG9vbHMuZGV2L2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZG9jcy9yZWZzLmh0bWwjZXhpc3RzcmVmXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHJlZiBUaGUgSlNPTiBSZWZlcmVuY2UgcGF0aCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBleGlzdHMocGF0aCwgb3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZShwYXRoLCBcIlwiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIGFuZCByZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgICAqL1xuICAgIGdldChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHBhdGgsIFwiXCIsIG9wdGlvbnMpLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBpbiB0aGUgc2NoZW1hLiBJZiB0aGUgcHJvcGVydHksIG9yIGFueSBvZiBpdHMgcGFyZW50cywgZG9uJ3QgZXhpc3QsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICRyZWYgVGhlIEpTT04gUmVmZXJlbmNlIHBhdGgsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLiBDYW4gYmUgYW55dGhpbmcgKG9iamVjdCwgc3RyaW5nLCBudW1iZXIsIGV0Yy4pXG4gICAgICovXG4gICAgc2V0KHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFic1BhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKGFic1BhdGgpO1xuICAgICAgICBjb25zdCAkcmVmID0gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgICAgICBpZiAoISRyZWYpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBvbm9fMS5vbm8pKGBFcnJvciByZXNvbHZpbmcgJHJlZiBwb2ludGVyIFwiJHtwYXRofVwiLiBcXG5cIiR7d2l0aG91dEhhc2h9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgICRyZWYuc2V0KGFic1BhdGgsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIHtAbGluayAkUmVmfSBvYmplY3QsIG9yIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEByZXR1cm5zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9nZXQkUmVmKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IHVybC5yZXNvbHZlKHRoaXMuX3Jvb3QkUmVmLnBhdGgsIHBhdGgpO1xuICAgICAgICBjb25zdCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2gocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rICRSZWZ9IG9iamVjdCBhbmQgYWRkcyBpdCB0byB0aGlzIHtAbGluayAkUmVmc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggIC0gVGhlIGZpbGUgcGF0aCBvciBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgICAqL1xuICAgIF9hZGQocGF0aCkge1xuICAgICAgICBjb25zdCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2gocGF0aCk7XG4gICAgICAgIGNvbnN0ICRyZWYgPSBuZXcgcmVmX2pzXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgJHJlZi5wYXRoID0gd2l0aG91dEhhc2g7XG4gICAgICAgIHRoaXMuXyRyZWZzW3dpdGhvdXRIYXNoXSA9ICRyZWY7XG4gICAgICAgIHRoaXMuX3Jvb3QkUmVmID0gdGhpcy5fcm9vdCRSZWYgfHwgJHJlZjtcbiAgICAgICAgcmV0dXJuICRyZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiBgb2JqYCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICAgICAqIEBwYXJhbSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVzb2x2ZShwYXRoLCBwYXRoRnJvbVJvb3QsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWJzUGF0aCA9IHVybC5yZXNvbHZlKHRoaXMuX3Jvb3QkUmVmLnBhdGgsIHBhdGgpO1xuICAgICAgICBjb25zdCB3aXRob3V0SGFzaCA9IHVybC5zdHJpcEhhc2goYWJzUGF0aCk7XG4gICAgICAgIGNvbnN0ICRyZWYgPSB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF07XG4gICAgICAgIGlmICghJHJlZikge1xuICAgICAgICAgICAgdGhyb3cgKDAsIG9ub18xLm9ubykoYEVycm9yIHJlc29sdmluZyAkcmVmIHBvaW50ZXIgXCIke3BhdGh9XCIuIFxcblwiJHt3aXRob3V0SGFzaH1cIiBub3QgZm91bmQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICRyZWYucmVzb2x2ZShhYnNQYXRoLCBvcHRpb25zLCBwYXRoLCBwYXRoRnJvbVJvb3QpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHBhdGhzL3VybHMgdG8ge0BsaW5rICRSZWZ9IG9iamVjdHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fJHJlZnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHBhdGhzIG9mIGFsbCB0aGUgZmlsZXMvVVJMcyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IHRoZSBKU09OIHNjaGVtYSxcbiAgICAgICAgICogaW5jbHVkaW5nIHRoZSBzY2hlbWEgaXRzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gW3R5cGVzXSAtIE9ubHkgcmV0dXJuIHBhdGhzIG9mIHRoZSBnaXZlbiB0eXBlcyAoXCJmaWxlXCIsIFwiaHR0cFwiLCBldGMuKVxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1hcCBvZiBKU09OIHJlZmVyZW5jZXMgYW5kIHRoZWlyIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIFt0eXBlc10gLSBPbmx5IHJldHVybiByZWZlcmVuY2VzIG9mIHRoZSBnaXZlbiB0eXBlcyAoXCJmaWxlXCIsIFwiaHR0cFwiLCBldGMuKVxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBQT0pPIChwbGFpbiBvbGQgSmF2YVNjcmlwdCBvYmplY3QpIGZvciBzZXJpYWxpemF0aW9uIGFzIEpTT04uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvSlNPTiA9IHRoaXMudmFsdWVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNjaGVtYSBjb250YWlucyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuXyRyZWZzID0ge307XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5fcm9vdCRSZWYgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICRSZWZzO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbmNvZGVkIGFuZCBkZWNvZGVkIHBhdGhzIGtleXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gJHJlZnMgLSBUaGUgb2JqZWN0IHdob3NlIGtleXMgYXJlIFVSTC1lbmNvZGVkIHBhdGhzXG4gKiBAcGFyYW0gW3R5cGVzXSAtIE9ubHkgcmV0dXJuIHBhdGhzIG9mIHRoZSBnaXZlbiB0eXBlcyAoXCJmaWxlXCIsIFwiaHR0cFwiLCBldGMuKVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aHMoJHJlZnMsIHR5cGVzKSB7XG4gICAgbGV0IHBhdGhzID0gT2JqZWN0LmtleXMoJHJlZnMpO1xuICAgIC8vIEZpbHRlciB0aGUgcGF0aHMgYnkgdHlwZVxuICAgIHR5cGVzID0gQXJyYXkuaXNBcnJheSh0eXBlc1swXSkgPyB0eXBlc1swXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHR5cGVzKTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID4gMCAmJiB0eXBlc1swXSkge1xuICAgICAgICBwYXRocyA9IHBhdGhzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZXMuaW5jbHVkZXMoJHJlZnNba2V5XS5wYXRoVHlwZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgbG9jYWwgZmlsZXN5c3RlbSBwYXRoc1xuICAgIHJldHVybiBwYXRocy5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuY29kZWQ6IHBhdGgsXG4gICAgICAgICAgICBkZWNvZGVkOiAkcmVmc1twYXRoXS5wYXRoVHlwZSA9PT0gXCJmaWxlXCIgPyB1cmwudG9GaWxlU3lzdGVtUGF0aChwYXRoLCB0cnVlKSA6IHBhdGgsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsIm9ub18xIiwicmVxdWlyZSIsInJlZl9qc18xIiwidXJsIiwiY29udmVydF9wYXRoX3RvX3Bvc2l4XzEiLCIkUmVmcyIsInBhdGhzIiwidHlwZXMiLCJnZXRQYXRocyIsIl8kcmVmcyIsIm1hcCIsInBhdGgiLCJkZWZhdWx0IiwiZGVjb2RlZCIsInZhbHVlcyIsIiRyZWZzIiwicmVkdWNlIiwib2JqIiwiZW5jb2RlZCIsImV4aXN0cyIsIm9wdGlvbnMiLCJfcmVzb2x2ZSIsImUiLCJzZXQiLCJhYnNQYXRoIiwicmVzb2x2ZSIsIl9yb290JFJlZiIsIndpdGhvdXRIYXNoIiwic3RyaXBIYXNoIiwiJHJlZiIsIm9ubyIsIl9nZXQkUmVmIiwiX2FkZCIsInBhdGhGcm9tUm9vdCIsImNvbnN0cnVjdG9yIiwidG9KU09OIiwiY2lyY3VsYXIiLCJrZXlzIiwiQXJyYXkiLCJpc0FycmF5Iiwic2xpY2UiLCJsZW5ndGgiLCJmaWx0ZXIiLCJrZXkiLCJpbmNsdWRlcyIsInBhdGhUeXBlIiwidG9GaWxlU3lzdGVtUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = resolveExternal;\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @returns\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */ function resolveExternal(parser, options) {\n    if (!options.resolve.external) {\n        // Nothing to resolve, so exit early\n        return Promise.resolve();\n    }\n    try {\n        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n        const promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n        return Promise.all(promises);\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {boolean} external - Whether `obj` was found in an external document.\n * @param $refs\n * @param options\n * @param seen - Internal.\n *\n * @returns\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */ function crawl(obj, path, $refs, options, seen, external) {\n    seen || (seen = new Set());\n    let promises = [];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n        seen.add(obj); // Track previously seen objects to avoid infinite recursion\n        if (ref_js_1.default.isExternal$Ref(obj)) {\n            promises.push(resolve$Ref(obj, path, $refs, options));\n        }\n        const keys = Object.keys(obj);\n        for (const key of keys){\n            const keyPath = pointer_js_1.default.join(path, key);\n            const value = obj[key];\n            promises = promises.concat(crawl(value, keyPath, $refs, options, seen, external));\n        }\n    }\n    return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param $refs\n * @param options\n *\n * @returns\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */ async function resolve$Ref($ref, path, $refs, options) {\n    const shouldResolveOnCwd = options.dereference.externalReferenceResolution === \"root\";\n    const resolvedPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const withoutHash = url.stripHash(resolvedPath);\n    // $ref.$ref = url.relative($refs._root$Ref.path, resolvedPath);\n    // Do we already have this $ref?\n    $ref = $refs._$refs[withoutHash];\n    if ($ref) {\n        // We've already parsed this $ref, so use the existing value\n        return Promise.resolve($ref.value);\n    }\n    // Parse the $referenced file/url\n    try {\n        const result = await (0, parse_js_1.default)(resolvedPath, $refs, options);\n        // Crawl the parsed value\n        // console.log('Resolving $ref pointers in %s', withoutHash);\n        const promises = crawl(result, withoutHash + \"#\", $refs, options, new Set(), true);\n        return Promise.all(promises);\n    } catch (err) {\n        if (!options?.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n            throw err;\n        }\n        if ($refs._$refs[withoutHash]) {\n            err.source = decodeURI(url.stripHash(path));\n            err.path = url.safePointerToPath(url.getHash(path));\n        }\n        return [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0IsSUFBSUcsT0FBT1AsT0FBT1Esd0JBQXdCLENBQUNMLEdBQUdDO0lBQzlDLElBQUksQ0FBQ0csUUFBUyxVQUFTQSxPQUFPLENBQUNKLEVBQUVNLFVBQVUsR0FBR0YsS0FBS0csUUFBUSxJQUFJSCxLQUFLSSxZQUFZLEdBQUc7UUFDakZKLE9BQU87WUFBRUssWUFBWTtZQUFNQyxLQUFLO2dCQUFhLE9BQU9WLENBQUMsQ0FBQ0MsRUFBRTtZQUFFO1FBQUU7SUFDOUQ7SUFDQUosT0FBT2MsY0FBYyxDQUFDWixHQUFHRyxJQUFJRTtBQUNqQyxJQUFNLFNBQVNMLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDdEIsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JGLENBQUMsQ0FBQ0csR0FBRyxHQUFHRixDQUFDLENBQUNDLEVBQUU7QUFDaEIsQ0FBQztBQUNELElBQUlXLHFCQUFxQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGtCQUFrQixJQUFNZixDQUFBQSxPQUFPQyxNQUFNLEdBQUksU0FBU0MsQ0FBQyxFQUFFYyxDQUFDO0lBQ3pGaEIsT0FBT2MsY0FBYyxDQUFDWixHQUFHLFdBQVc7UUFBRVUsWUFBWTtRQUFNSyxPQUFPRDtJQUFFO0FBQ3JFLElBQUssU0FBU2QsQ0FBQyxFQUFFYyxDQUFDO0lBQ2RkLENBQUMsQ0FBQyxVQUFVLEdBQUdjO0FBQ25CO0FBQ0EsSUFB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Q0FBQ0MsMkJBQTJCLEtBQUs7SUFDL0UsTUFBTUMsZUFBZXJDLElBQUlNLE9BQU8sQ0FBQzRCLHFCQUFxQmxDLElBQUlzQyxHQUFHLEtBQUt4QixNQUFNbUIsS0FBS0EsSUFBSTtJQUNqRixNQUFNTSxjQUFjdkMsSUFBSXdDLFNBQVMsQ0FBQ0g7SUFDbEMsZ0VBQWdFO0lBQ2hFLGdDQUFnQztJQUNoQ0osT0FBT3JCLE1BQU02QixNQUFNLENBQUNGLFlBQVk7SUFDaEMsSUFBSU4sTUFBTTtRQUNOLDREQUE0RDtRQUM1RCxPQUFPekIsUUFBUUYsT0FBTyxDQUFDMkIsS0FBSzlDLEtBQUs7SUFDckM7SUFDQSxpQ0FBaUM7SUFDakMsSUFBSTtRQUNBLE1BQU1HLFNBQVMsTUFBTSxDQUFDLEdBQUdTLFdBQVdHLE9BQU8sRUFBRW1DLGNBQWN6QixPQUFPUDtRQUNsRSx5QkFBeUI7UUFDekIsNkRBQTZEO1FBQzdELE1BQU1JLFdBQVdDLE1BQU1wQixRQUFRaUQsY0FBYyxLQUFLM0IsT0FBT1AsU0FBUyxJQUFJZSxPQUFPO1FBQzdFLE9BQU9aLFFBQVFPLEdBQUcsQ0FBQ047SUFDdkIsRUFDQSxPQUFPaUMsS0FBSztRQUNSLElBQUksQ0FBQ3JDLFNBQVNzQyxtQkFBbUIsQ0FBQyxDQUFDLEdBQUcxQyxZQUFZMkMsY0FBYyxFQUFFRixNQUFNO1lBQ3BFLE1BQU1BO1FBQ1Y7UUFDQSxJQUFJOUIsTUFBTTZCLE1BQU0sQ0FBQ0YsWUFBWSxFQUFFO1lBQzNCRyxJQUFJRyxNQUFNLEdBQUdDLFVBQVU5QyxJQUFJd0MsU0FBUyxDQUFDMUI7WUFDckM0QixJQUFJNUIsSUFBSSxHQUFHZCxJQUFJK0MsaUJBQWlCLENBQUMvQyxJQUFJZ0QsT0FBTyxDQUFDbEM7UUFDakQ7UUFDQSxPQUFPLEVBQUU7SUFDYjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlLWV4dGVybmFsLmpzP2RkYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVzb2x2ZUV4dGVybmFsO1xuLyoqXG4gKiBDcmF3bHMgdGhlIEpTT04gc2NoZW1hLCBmaW5kcyBhbGwgZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2VzLCBhbmQgcmVzb2x2ZXMgdGhlaXIgdmFsdWVzLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgbXV0YXRlIHRoZSBKU09OIHNjaGVtYS4gVGhlIHJlc29sdmVkIHZhbHVlcyBhcmUgYWRkZWQgdG8ge0BsaW5rICRSZWZQYXJzZXIjJHJlZnN9LlxuICpcbiAqIE5PVEU6IFdlIG9ubHkgY2FyZSBhYm91dCBFWFRFUk5BTCByZWZlcmVuY2VzIGhlcmUuIElOVEVSTkFMIHJlZmVyZW5jZXMgYXJlIG9ubHkgcmVsZXZhbnQgd2hlbiBkZXJlZmVyZW5jaW5nLlxuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyBvbmNlIGFsbCBKU09OIHJlZmVyZW5jZXMgaW4gdGhlIHNjaGVtYSBoYXZlIGJlZW4gcmVzb2x2ZWQsXG4gKiBpbmNsdWRpbmcgbmVzdGVkIHJlZmVyZW5jZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUV4dGVybmFsKHBhcnNlciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5yZXNvbHZlLmV4dGVybmFsKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gcmVzb2x2ZSwgc28gZXhpdCBlYXJseVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZXNvbHZpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gY3Jhd2wocGFyc2VyLnNjaGVtYSwgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoICsgXCIjXCIsIHBhcnNlci4kcmVmcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNyYXdscyB0aGUgZ2l2ZW4gdmFsdWUsIGFuZCByZXNvbHZlcyBhbnkgZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2VzLlxuICpcbiAqIEBwYXJhbSBvYmogLSBUaGUgdmFsdWUgdG8gY3Jhd2wuIElmIGl0J3Mgbm90IGFuIG9iamVjdCBvciBhcnJheSwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGBvYmpgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4dGVybmFsIC0gV2hldGhlciBgb2JqYCB3YXMgZm91bmQgaW4gYW4gZXh0ZXJuYWwgZG9jdW1lbnQuXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gc2VlbiAtIEludGVybmFsLlxuICpcbiAqIEByZXR1cm5zXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHByb21pc2VzLiBUaGVyZSB3aWxsIGJlIG9uZSBwcm9taXNlIGZvciBlYWNoIEpTT04gcmVmZXJlbmNlIGluIGBvYmpgLlxuICogSWYgYG9iamAgZG9lcyBub3QgY29udGFpbiBhbnkgSlNPTiByZWZlcmVuY2VzLCB0aGVuIHRoZSBhcnJheSB3aWxsIGJlIGVtcHR5LlxuICogSWYgYW55IG9mIHRoZSBKU09OIHJlZmVyZW5jZXMgcG9pbnQgdG8gZmlsZXMgdGhhdCBjb250YWluIGFkZGl0aW9uYWwgSlNPTiByZWZlcmVuY2VzLFxuICogdGhlbiB0aGUgY29ycmVzcG9uZGluZyBwcm9taXNlIHdpbGwgaW50ZXJuYWxseSByZWZlcmVuY2UgYW4gYXJyYXkgb2YgcHJvbWlzZXMuXG4gKi9cbmZ1bmN0aW9uIGNyYXdsKG9iaiwgcGF0aCwgJHJlZnMsIG9wdGlvbnMsIHNlZW4sIGV4dGVybmFsKSB7XG4gICAgc2VlbiB8fCAoc2VlbiA9IG5ldyBTZXQoKSk7XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSAmJiAhc2Vlbi5oYXMob2JqKSkge1xuICAgICAgICBzZWVuLmFkZChvYmopOyAvLyBUcmFjayBwcmV2aW91c2x5IHNlZW4gb2JqZWN0cyB0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgaWYgKHJlZl9qc18xLmRlZmF1bHQuaXNFeHRlcm5hbCRSZWYob2JqKSkge1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChyZXNvbHZlJFJlZihvYmosIHBhdGgsICRyZWZzLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVBhdGggPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5qb2luKHBhdGgsIGtleSk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgcHJvbWlzZXMgPSBwcm9taXNlcy5jb25jYXQoY3Jhd2wodmFsdWUsIGtleVBhdGgsICRyZWZzLCBvcHRpb25zLCBzZWVuLCBleHRlcm5hbCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlcztcbn1cbi8qKlxuICogUmVzb2x2ZXMgdGhlIGdpdmVuIEpTT04gUmVmZXJlbmNlLCBhbmQgdGhlbiBjcmF3bHMgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gJHJlZiAtIFRoZSBKU09OIFJlZmVyZW5jZSB0byByZXNvbHZlXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgYCRyZWZgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKlxuICogQHJldHVybnNcbiAqIFRoZSBwcm9taXNlIHJlc29sdmVzIG9uY2UgYWxsIEpTT04gcmVmZXJlbmNlcyBpbiB0aGUgb2JqZWN0IGhhdmUgYmVlbiByZXNvbHZlZCxcbiAqIGluY2x1ZGluZyBuZXN0ZWQgcmVmZXJlbmNlcyB0aGF0IGFyZSBjb250YWluZWQgaW4gZXh0ZXJuYWxseS1yZWZlcmVuY2VkIGZpbGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlJFJlZigkcmVmLCBwYXRoLCAkcmVmcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNob3VsZFJlc29sdmVPbkN3ZCA9IG9wdGlvbnMuZGVyZWZlcmVuY2UuZXh0ZXJuYWxSZWZlcmVuY2VSZXNvbHV0aW9uID09PSBcInJvb3RcIjtcbiAgICBjb25zdCByZXNvbHZlZFBhdGggPSB1cmwucmVzb2x2ZShzaG91bGRSZXNvbHZlT25Dd2QgPyB1cmwuY3dkKCkgOiBwYXRoLCAkcmVmLiRyZWYpO1xuICAgIGNvbnN0IHdpdGhvdXRIYXNoID0gdXJsLnN0cmlwSGFzaChyZXNvbHZlZFBhdGgpO1xuICAgIC8vICRyZWYuJHJlZiA9IHVybC5yZWxhdGl2ZSgkcmVmcy5fcm9vdCRSZWYucGF0aCwgcmVzb2x2ZWRQYXRoKTtcbiAgICAvLyBEbyB3ZSBhbHJlYWR5IGhhdmUgdGhpcyAkcmVmP1xuICAgICRyZWYgPSAkcmVmcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgIGlmICgkcmVmKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcGFyc2VkIHRoaXMgJHJlZiwgc28gdXNlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCRyZWYudmFsdWUpO1xuICAgIH1cbiAgICAvLyBQYXJzZSB0aGUgJHJlZmVyZW5jZWQgZmlsZS91cmxcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KShyZXNvbHZlZFBhdGgsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgLy8gQ3Jhd2wgdGhlIHBhcnNlZCB2YWx1ZVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUmVzb2x2aW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCB3aXRob3V0SGFzaCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gY3Jhd2wocmVzdWx0LCB3aXRob3V0SGFzaCArIFwiI1wiLCAkcmVmcywgb3B0aW9ucywgbmV3IFNldCgpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIW9wdGlvbnM/LmNvbnRpbnVlT25FcnJvciB8fCAhKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRyZWZzLl8kcmVmc1t3aXRob3V0SGFzaF0pIHtcbiAgICAgICAgICAgIGVyci5zb3VyY2UgPSBkZWNvZGVVUkkodXJsLnN0cmlwSGFzaChwYXRoKSk7XG4gICAgICAgICAgICBlcnIucGF0aCA9IHVybC5zYWZlUG9pbnRlclRvUGF0aCh1cmwuZ2V0SGFzaChwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmVmX2pzXzEiLCJyZXF1aXJlIiwicG9pbnRlcl9qc18xIiwicGFyc2VfanNfMSIsInVybCIsImVycm9yc19qc18xIiwiZGVmYXVsdCIsInJlc29sdmVFeHRlcm5hbCIsInBhcnNlciIsIm9wdGlvbnMiLCJyZXNvbHZlIiwiZXh0ZXJuYWwiLCJQcm9taXNlIiwicHJvbWlzZXMiLCJjcmF3bCIsInNjaGVtYSIsIiRyZWZzIiwiX3Jvb3QkUmVmIiwicGF0aCIsImFsbCIsImUiLCJyZWplY3QiLCJvYmoiLCJzZWVuIiwiU2V0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJoYXMiLCJhZGQiLCJpc0V4dGVybmFsJFJlZiIsInB1c2giLCJyZXNvbHZlJFJlZiIsImtleXMiLCJrZXkiLCJrZXlQYXRoIiwiam9pbiIsImNvbmNhdCIsIiRyZWYiLCJzaG91bGRSZXNvbHZlT25Dd2QiLCJkZXJlZmVyZW5jZSIsImV4dGVybmFsUmVmZXJlbmNlUmVzb2x1dGlvbiIsInJlc29sdmVkUGF0aCIsImN3ZCIsIndpdGhvdXRIYXNoIiwic3RyaXBIYXNoIiwiXyRyZWZzIiwiZXJyIiwiY29udGludWVPbkVycm9yIiwiaXNIYW5kbGVkRXJyb3IiLCJzb3VyY2UiLCJkZWNvZGVVUkkiLCJzYWZlUG9pbnRlclRvUGF0aCIsImdldEhhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */ order: 100,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */ canRead (file) {\n        return url.isFileSystemPath(file.url);\n    },\n    /**\n     * Reads the given file and returns its raw contents as a Buffer.\n     */ async read (file) {\n        let path;\n        try {\n            path = url.toFileSystemPath(file.url);\n        } catch (err) {\n            throw new errors_js_1.ResolverError(ono_1.ono.uri(err, `Malformed URI: ${file.url}`), file.url);\n        }\n        try {\n            const data = await fs_1.promises.readFile(path);\n            return data;\n        } catch (err) {\n            throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error opening file \"${path}\"`), path);\n        }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBVUMsR0FBRztJQUMzRCxJQUFJQSxPQUFPQSxJQUFJVixVQUFVLEVBQUUsT0FBT1U7SUFDbEMsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSUQsT0FBTyxNQUFNO1FBQUEsSUFBSyxJQUFJZixLQUFLZSxJQUFLLElBQUlmLE1BQU0sYUFBYUosT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtmLElBQUlMLGdCQUFnQnFCLFFBQVFELEtBQUtmO0lBQUU7SUFDeElXLG1CQUFtQkssUUFBUUQ7SUFDM0IsT0FBT0M7QUFDWDtBQUNBcEIsOENBQTZDO0lBQUVpQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1RLE9BQU9DLG1CQUFPQSxDQUFDLGNBQUk7QUFDekIsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3ZDLE1BQU1FLE1BQU1WLGFBQWFRLG1CQUFPQSxDQUFDLHFHQUFnQjtBQUNqRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQywyR0FBbUI7QUFDL0NGLGtCQUFlLEdBQUc7SUFDZDs7S0FFQyxHQUNETyxPQUFPO0lBQ1A7Ozs7S0FJQyxHQUNEQyxTQUFRQyxJQUFJO1FBQ1IsT0FBT0wsSUFBSU0sZ0JBQWdCLENBQUNELEtBQUtMLEdBQUc7SUFDeEM7SUFDQTs7S0FFQyxHQUNELE1BQU1PLE1BQUtGLElBQUk7UUFDWCxJQUFJRztRQUNKLElBQUk7WUFDQUEsT0FBT1IsSUFBSVMsZ0JBQWdCLENBQUNKLEtBQUtMLEdBQUc7UUFDeEMsRUFDQSxPQUFPVSxLQUFLO1lBQ1IsTUFBTSxJQUFJVCxZQUFZVSxhQUFhLENBQUNaLE1BQU1hLEdBQUcsQ0FBQ0MsR0FBRyxDQUFDSCxLQUFLLENBQUMsZUFBZSxFQUFFTCxLQUFLTCxHQUFHLENBQUMsQ0FBQyxHQUFHSyxLQUFLTCxHQUFHO1FBQ2xHO1FBQ0EsSUFBSTtZQUNBLE1BQU1jLE9BQU8sTUFBTWpCLEtBQUtrQixRQUFRLENBQUNDLFFBQVEsQ0FBQ1I7WUFDMUMsT0FBT007UUFDWCxFQUNBLE9BQU9KLEtBQUs7WUFDUixNQUFNLElBQUlULFlBQVlVLGFBQWEsQ0FBQyxDQUFDLEdBQUdaLE1BQU1hLEdBQUcsRUFBRUYsS0FBSyxDQUFDLG9CQUFvQixFQUFFRixLQUFLLENBQUMsQ0FBQyxHQUFHQTtRQUM3RjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3Jlc29sdmVycy9maWxlLmpzP2JlY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWwvdXJsLmpzXCIpKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvZXJyb3JzLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcmVzb2x2ZXIgd2lsbCBydW4sIGluIHJlbGF0aW9uIHRvIG90aGVyIHJlc29sdmVycy5cbiAgICAgKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHJlc29sdmVyIGNhbiByZWFkIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcmVzb2x2ZXMgdGhlIGZpbGUuXG4gICAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgbm90IGJlIGdpdmVuIGEgY2hhbmNlIHRvIHJlc29sdmUgdGhlIGZpbGUuXG4gICAgICovXG4gICAgY2FuUmVhZChmaWxlKSB7XG4gICAgICAgIHJldHVybiB1cmwuaXNGaWxlU3lzdGVtUGF0aChmaWxlLnVybCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgZ2l2ZW4gZmlsZSBhbmQgcmV0dXJucyBpdHMgcmF3IGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWQoZmlsZSkge1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhdGggPSB1cmwudG9GaWxlU3lzdGVtUGF0aChmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3Iob25vXzEub25vLnVyaShlcnIsIGBNYWxmb3JtZWQgVVJJOiAke2ZpbGUudXJsfWApLCBmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmc18xLnByb21pc2VzLnJlYWRGaWxlKHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoKDAsIG9ub18xLm9ubykoZXJyLCBgRXJyb3Igb3BlbmluZyBmaWxlIFwiJHtwYXRofVwiYCksIHBhdGgpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4iXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsImZzXzEiLCJyZXF1aXJlIiwib25vXzEiLCJ1cmwiLCJlcnJvcnNfanNfMSIsImRlZmF1bHQiLCJvcmRlciIsImNhblJlYWQiLCJmaWxlIiwiaXNGaWxlU3lzdGVtUGF0aCIsInJlYWQiLCJwYXRoIiwidG9GaWxlU3lzdGVtUGF0aCIsImVyciIsIlJlc29sdmVyRXJyb3IiLCJvbm8iLCJ1cmkiLCJkYXRhIiwicHJvbWlzZXMiLCJyZWFkRmlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */ order: 200,\n    /**\n     * HTTP headers to send when downloading files.\n     *\n     * @example:\n     * {\n     *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n     *   Accept: \"application/json\"\n     * }\n     */ headers: null,\n    /**\n     * HTTP request timeout (in milliseconds).\n     */ timeout: 5000,\n    /**\n     * The maximum number of HTTP redirects to follow.\n     * To disable automatic following of redirects, set this to zero.\n     */ redirects: 5,\n    /**\n     * The `withCredentials` option of XMLHttpRequest.\n     * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n     */ withCredentials: false,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */ canRead (file) {\n        return url.isHttp(file.url);\n    },\n    /**\n     * Reads the given URL and returns its raw contents as a Buffer.\n     */ read (file) {\n        const u = url.parse(file.url);\n        if (false) {}\n        return download(u, this);\n    }\n};\n/**\n * Downloads the given file.\n * @returns\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */ async function download(u, httpOptions, _redirects) {\n    u = url.parse(u);\n    const redirects = _redirects || [];\n    redirects.push(u.href);\n    try {\n        const res = await get(u, httpOptions);\n        if (res.status >= 400) {\n            throw (0, ono_1.ono)({\n                status: res.status\n            }, `HTTP ERROR ${res.status}`);\n        } else if (res.status >= 300) {\n            if (!Number.isNaN(httpOptions.redirects) && redirects.length > httpOptions.redirects) {\n                throw new errors_js_1.ResolverError((0, ono_1.ono)({\n                    status: res.status\n                }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`));\n            } else if (!(\"location\" in res.headers) || !res.headers.location) {\n                throw (0, ono_1.ono)({\n                    status: res.status\n                }, `HTTP ${res.status} redirect with no location header`);\n            } else {\n                const redirectTo = url.resolve(u.href, res.headers.location);\n                return download(redirectTo, httpOptions, redirects);\n            }\n        } else {\n            if (res.body) {\n                const buf = await res.arrayBuffer();\n                return Buffer.from(buf);\n            }\n            return Buffer.alloc(0);\n        }\n    } catch (err) {\n        throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error downloading ${u.href}`), u.href);\n    }\n}\n/**\n * Sends an HTTP GET request.\n * The promise resolves with the HTTP Response object.\n */ async function get(u, httpOptions) {\n    let controller;\n    let timeoutId;\n    if (httpOptions.timeout) {\n        controller = new AbortController();\n        timeoutId = setTimeout(()=>controller.abort(), httpOptions.timeout);\n    }\n    if (!global.fetch) {\n        const { default: fetch1, Request, Headers } = await Promise.resolve().then(()=>__importStar(__webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\")));\n        // @ts-ignore\n        global.fetch = fetch1;\n        // @ts-ignore\n        global.Request = Request;\n        // @ts-ignore\n        global.Headers = Headers;\n    }\n    const response = await fetch(u, {\n        method: \"GET\",\n        headers: httpOptions.headers || {},\n        credentials: httpOptions.withCredentials ? \"include\" : \"same-origin\",\n        signal: controller ? controller.signal : null\n    });\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    return response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlF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QWFkO0lBQ2pCO0lBQ0EsT0FBT1U7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2h0dHAuanM/MTBhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKipcbiAgICAgKiBIVFRQIGhlYWRlcnMgdG8gc2VuZCB3aGVuIGRvd25sb2FkaW5nIGZpbGVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGU6XG4gICAgICoge1xuICAgICAqICAgXCJVc2VyLUFnZW50XCI6IFwiSlNPTiBTY2hlbWEgJFJlZiBQYXJzZXJcIixcbiAgICAgKiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICAvKipcbiAgICAgKiBIVFRQIHJlcXVlc3QgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiA1MDAwLFxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBIVFRQIHJlZGlyZWN0cyB0byBmb2xsb3cuXG4gICAgICogVG8gZGlzYWJsZSBhdXRvbWF0aWMgZm9sbG93aW5nIG9mIHJlZGlyZWN0cywgc2V0IHRoaXMgdG8gemVyby5cbiAgICAgKi9cbiAgICByZWRpcmVjdHM6IDUsXG4gICAgLyoqXG4gICAgICogVGhlIGB3aXRoQ3JlZGVudGlhbHNgIG9wdGlvbiBvZiBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKiBTZXQgdGhpcyB0byBgdHJ1ZWAgaWYgeW91J3JlIGRvd25sb2FkaW5nIGZpbGVzIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyIHRoYXQgcmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgICAgKi9cbiAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHJlc29sdmVyIGNhbiByZWFkIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSByZXNvbHZlcyB0aGUgZmlsZS5cbiAgICAgKiBSZXNvbHZlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBub3QgYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gcmVzb2x2ZSB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBjYW5SZWFkKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHVybC5pc0h0dHAoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJucyBpdHMgcmF3IGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgICAqL1xuICAgIHJlYWQoZmlsZSkge1xuICAgICAgICBjb25zdCB1ID0gdXJsLnBhcnNlKGZpbGUudXJsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJvdG9jb2wgb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgdS5wcm90b2NvbCA9IHVybC5wYXJzZShsb2NhdGlvbi5ocmVmKS5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG93bmxvYWQodSwgdGhpcyk7XG4gICAgfSxcbn07XG4vKipcbiAqIERvd25sb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSByYXcgZG93bmxvYWRlZCBkYXRhLCBvciByZWplY3RzIGlmIHRoZXJlIGlzIGFuIEhUVFAgZXJyb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHUsIGh0dHBPcHRpb25zLCBfcmVkaXJlY3RzKSB7XG4gICAgdSA9IHVybC5wYXJzZSh1KTtcbiAgICBjb25zdCByZWRpcmVjdHMgPSBfcmVkaXJlY3RzIHx8IFtdO1xuICAgIHJlZGlyZWN0cy5wdXNoKHUuaHJlZik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHUsIGh0dHBPcHRpb25zKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCBFUlJPUiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGh0dHBPcHRpb25zLnJlZGlyZWN0cykgJiYgcmVkaXJlY3RzLmxlbmd0aCA+IGh0dHBPcHRpb25zLnJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKCgwLCBvbm9fMS5vbm8pKHsgc3RhdHVzOiByZXMuc3RhdHVzIH0sIGBFcnJvciBkb3dubG9hZGluZyAke3JlZGlyZWN0c1swXX0uIFxcblRvbyBtYW55IHJlZGlyZWN0czogXFxuICAke3JlZGlyZWN0cy5qb2luKFwiIFxcbiAgXCIpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoXCJsb2NhdGlvblwiIGluIHJlcy5oZWFkZXJzKSB8fCAhcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCAke3Jlcy5zdGF0dXN9IHJlZGlyZWN0IHdpdGggbm8gbG9jYXRpb24gaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFRvID0gdXJsLnJlc29sdmUodS5ocmVmLCByZXMuaGVhZGVycy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkKHJlZGlyZWN0VG8sIGh0dHBPcHRpb25zLCByZWRpcmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcy5ib2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoKDAsIG9ub18xLm9ubykoZXJyLCBgRXJyb3IgZG93bmxvYWRpbmcgJHt1LmhyZWZ9YCksIHUuaHJlZik7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhbiBIVFRQIEdFVCByZXF1ZXN0LlxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgSFRUUCBSZXNwb25zZSBvYmplY3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldCh1LCBodHRwT3B0aW9ucykge1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBpZiAoIWdsb2JhbC5mZXRjaCkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IGZldGNoLCBSZXF1ZXN0LCBIZWFkZXJzIH0gPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZS1mZXRjaFwiKSkpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGdsb2JhbC5mZXRjaCA9IGZldGNoO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGdsb2JhbC5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnbG9iYWwuSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godSwge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IGh0dHBPcHRpb25zLmhlYWRlcnMgfHwge30sXG4gICAgICAgIGNyZWRlbnRpYWxzOiBodHRwT3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyID8gY29udHJvbGxlci5zaWduYWwgOiBudWxsLFxuICAgIH0pO1xuICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJleHBvcnRzIiwib25vXzEiLCJyZXF1aXJlIiwidXJsIiwiZXJyb3JzX2pzXzEiLCJkZWZhdWx0Iiwib3JkZXIiLCJoZWFkZXJzIiwidGltZW91dCIsInJlZGlyZWN0cyIsIndpdGhDcmVkZW50aWFscyIsImNhblJlYWQiLCJmaWxlIiwiaXNIdHRwIiwicmVhZCIsInUiLCJwYXJzZSIsInByb3RvY29sIiwibG9jYXRpb24iLCJocmVmIiwiZG93bmxvYWQiLCJodHRwT3B0aW9ucyIsIl9yZWRpcmVjdHMiLCJwdXNoIiwicmVzIiwic3RhdHVzIiwib25vIiwiTnVtYmVyIiwiaXNOYU4iLCJsZW5ndGgiLCJSZXNvbHZlckVycm9yIiwiam9pbiIsInJlZGlyZWN0VG8iLCJyZXNvbHZlIiwiYm9keSIsImJ1ZiIsImFycmF5QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImFsbG9jIiwiZXJyIiwiY29udHJvbGxlciIsInRpbWVvdXRJZCIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImdsb2JhbCIsImZldGNoIiwiUmVxdWVzdCIsIkhlYWRlcnMiLCJQcm9taXNlIiwidGhlbiIsInJlc3BvbnNlIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJzaWduYWwiLCJjbGVhclRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nfunction convertPathToPosix(filePath) {\n    const isExtendedLengthPath = filePath.startsWith(\"\\\\\\\\?\\\\\");\n    if (isExtendedLengthPath) {\n        return filePath;\n    }\n    return filePath.split(path_1.default.win32.sep).join(path_1.default.posix.sep);\n}\nexports[\"default\"] = convertPathToPosix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9jb252ZXJ0LXBhdGgtdG8tcG9zaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQUssU0FBVUMsR0FBRztJQUNqRSxPQUFPLE9BQVFBLElBQUlDLFVBQVUsR0FBSUQsTUFBTTtRQUFFLFdBQVdBO0lBQUk7QUFDNUQ7QUFDQUUsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsU0FBU1AsZ0JBQWdCUSxtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QyxTQUFTQyxtQkFBbUJDLFFBQVE7SUFDaEMsTUFBTUMsdUJBQXVCRCxTQUFTRSxVQUFVLENBQUM7SUFDakQsSUFBSUQsc0JBQXNCO1FBQ3RCLE9BQU9EO0lBQ1g7SUFDQSxPQUFPQSxTQUFTRyxLQUFLLENBQUNOLE9BQU9PLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDQyxHQUFHLEVBQUVDLElBQUksQ0FBQ1YsT0FBT08sT0FBTyxDQUFDSSxLQUFLLENBQUNGLEdBQUc7QUFDakY7QUFDQVgsa0JBQWUsR0FBR0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3V0aWwvY29udmVydC1wYXRoLXRvLXBvc2l4LmpzP2NkMWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBhdGhcIikpO1xuZnVuY3Rpb24gY29udmVydFBhdGhUb1Bvc2l4KGZpbGVQYXRoKSB7XG4gICAgY29uc3QgaXNFeHRlbmRlZExlbmd0aFBhdGggPSBmaWxlUGF0aC5zdGFydHNXaXRoKFwiXFxcXFxcXFw/XFxcXFwiKTtcbiAgICBpZiAoaXNFeHRlbmRlZExlbmd0aFBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZVBhdGguc3BsaXQocGF0aF8xLmRlZmF1bHQud2luMzIuc2VwKS5qb2luKHBhdGhfMS5kZWZhdWx0LnBvc2l4LnNlcCk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjb252ZXJ0UGF0aFRvUG9zaXg7XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicGF0aF8xIiwicmVxdWlyZSIsImNvbnZlcnRQYXRoVG9Qb3NpeCIsImZpbGVQYXRoIiwiaXNFeHRlbmRlZExlbmd0aFBhdGgiLCJzdGFydHNXaXRoIiwic3BsaXQiLCJkZWZhdWx0Iiwid2luMzIiLCJzZXAiLCJqb2luIiwicG9zaXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizeError = exports.isHandledError = exports.InvalidPointerError = exports.MissingPointerError = exports.UnmatchedResolverError = exports.ResolverError = exports.UnmatchedParserError = exports.ParserError = exports.JSONParserErrorGroup = exports.JSONParserError = void 0;\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url_js_1 = __webpack_require__(/*! ./url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\nclass JSONParserError extends Error {\n    constructor(message, source){\n        super();\n        this.code = \"EUNKNOWN\";\n        this.name = \"JSONParserError\";\n        this.message = message;\n        this.source = source;\n        this.path = null;\n        ono_1.Ono.extend(this);\n    }\n    get footprint() {\n        return `${this.path}+${this.source}+${this.code}+${this.message}`;\n    }\n}\nexports.JSONParserError = JSONParserError;\nclass JSONParserErrorGroup extends Error {\n    constructor(parser){\n        super();\n        this.files = parser;\n        this.name = \"JSONParserErrorGroup\";\n        this.message = `${this.errors.length} error${this.errors.length > 1 ? \"s\" : \"\"} occurred while reading '${(0, url_js_1.toFileSystemPath)(parser.$refs._root$Ref.path)}'`;\n        ono_1.Ono.extend(this);\n    }\n    static getParserErrors(parser) {\n        const errors = [];\n        for (const $ref of Object.values(parser.$refs._$refs)){\n            // @ts-expect-error TS(2571): Object is of type 'unknown'.\n            if ($ref.errors) {\n                // @ts-expect-error TS(2571): Object is of type 'unknown'.\n                errors.push(...$ref.errors);\n            }\n        }\n        return errors;\n    }\n    get errors() {\n        return JSONParserErrorGroup.getParserErrors(this.files);\n    }\n}\nexports.JSONParserErrorGroup = JSONParserErrorGroup;\nclass ParserError extends JSONParserError {\n    constructor(message, source){\n        super(`Error parsing ${source}: ${message}`, source);\n        this.code = \"EPARSER\";\n        this.name = \"ParserError\";\n    }\n}\nexports.ParserError = ParserError;\nclass UnmatchedParserError extends JSONParserError {\n    constructor(source){\n        super(`Could not find parser for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDPARSER\";\n        this.name = \"UnmatchedParserError\";\n    }\n}\nexports.UnmatchedParserError = UnmatchedParserError;\nclass ResolverError extends JSONParserError {\n    constructor(ex, source){\n        super(ex.message || `Error reading file \"${source}\"`, source);\n        this.code = \"ERESOLVER\";\n        this.name = \"ResolverError\";\n        if (\"code\" in ex) {\n            this.ioErrorCode = String(ex.code);\n        }\n    }\n}\nexports.ResolverError = ResolverError;\nclass UnmatchedResolverError extends JSONParserError {\n    constructor(source){\n        super(`Could not find resolver for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"UnmatchedResolverError\";\n    }\n}\nexports.UnmatchedResolverError = UnmatchedResolverError;\nclass MissingPointerError extends JSONParserError {\n    constructor(token, path){\n        super(`Token \"${token}\" does not exist.`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"MissingPointerError\";\n    }\n}\nexports.MissingPointerError = MissingPointerError;\nclass InvalidPointerError extends JSONParserError {\n    constructor(pointer, path){\n        super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"InvalidPointerError\";\n    }\n}\nexports.InvalidPointerError = InvalidPointerError;\nfunction isHandledError(err) {\n    return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n}\nexports.isHandledError = isHandledError;\nfunction normalizeError(err) {\n    if (err.path === null) {\n        err.path = [];\n    }\n    return err;\n}\nexports.normalizeError = normalizeError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHNCQUFzQixHQUFHQSxzQkFBc0IsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHQSw4QkFBOEIsR0FBR0EscUJBQXFCLEdBQUdBLDRCQUE0QixHQUFHQSxtQkFBbUIsR0FBR0EsNEJBQTRCLEdBQUdBLHVCQUF1QixHQUFHLEtBQUs7QUFDMVIsTUFBTVksUUFBUUMsbUJBQU9BLENBQUMsMEVBQWlCO0FBQ3ZDLE1BQU1DLFdBQVdELG1CQUFPQSxDQUFDLCtGQUFVO0FBQ25DLE1BQU1GLHdCQUF3Qkk7SUFDMUJDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxDQUFFO1FBQ3pCLEtBQUs7UUFDTCxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRyxJQUFJLEdBQUc7UUFDWlQsTUFBTVUsR0FBRyxDQUFDQyxNQUFNLENBQUMsSUFBSTtJQUN6QjtJQUNBLElBQUlDLFlBQVk7UUFDWixPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNILElBQUksQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDSCxNQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsSUFBSSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNGLE9BQU8sQ0FBQyxDQUFDO0lBQ3JFO0FBQ0o7QUFDQWpCLHVCQUF1QixHQUFHVztBQUMxQixNQUFNRCw2QkFBNkJLO0lBQy9CQyxZQUFZUyxNQUFNLENBQUU7UUFDaEIsS0FBSztRQUNMLElBQUksQ0FBQ0MsS0FBSyxHQUFHRDtRQUNiLElBQUksQ0FBQ0wsSUFB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LFNBQVMyQixTQUFTLEVBQUVwQjtRQUNsRyxJQUFJLENBQUNGLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQXBCLDJCQUEyQixHQUFHSTtBQUM5QixTQUFTRCxlQUFld0MsR0FBRztJQUN2QixPQUFPQSxlQUFlaEMsbUJBQW1CZ0MsZUFBZWpDO0FBQzVEO0FBQ0FWLHNCQUFzQixHQUFHRztBQUN6QixTQUFTRCxlQUFleUMsR0FBRztJQUN2QixJQUFJQSxJQUFJdEIsSUFBSSxLQUFLLE1BQU07UUFDbkJzQixJQUFJdEIsSUFBSSxHQUFHLEVBQUU7SUFDakI7SUFDQSxPQUFPc0I7QUFDWDtBQUNBM0Msc0JBQXNCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2Vycm9ycy5qcz83MDg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemVFcnJvciA9IGV4cG9ydHMuaXNIYW5kbGVkRXJyb3IgPSBleHBvcnRzLkludmFsaWRQb2ludGVyRXJyb3IgPSBleHBvcnRzLk1pc3NpbmdQb2ludGVyRXJyb3IgPSBleHBvcnRzLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IgPSBleHBvcnRzLlJlc29sdmVyRXJyb3IgPSBleHBvcnRzLlVubWF0Y2hlZFBhcnNlckVycm9yID0gZXhwb3J0cy5QYXJzZXJFcnJvciA9IGV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBleHBvcnRzLkpTT05QYXJzZXJFcnJvciA9IHZvaWQgMDtcbmNvbnN0IG9ub18xID0gcmVxdWlyZShcIkBqc2RldnRvb2xzL29ub1wiKTtcbmNvbnN0IHVybF9qc18xID0gcmVxdWlyZShcIi4vdXJsLmpzXCIpO1xuY2xhc3MgSlNPTlBhcnNlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNvdXJjZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTktOT1dOXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSlNPTlBhcnNlckVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICBvbm9fMS5Pbm8uZXh0ZW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgZm9vdHByaW50KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5wYXRofSske3RoaXMuc291cmNlfSske3RoaXMuY29kZX0rJHt0aGlzLm1lc3NhZ2V9YDtcbiAgICB9XG59XG5leHBvcnRzLkpTT05QYXJzZXJFcnJvciA9IEpTT05QYXJzZXJFcnJvcjtcbmNsYXNzIEpTT05QYXJzZXJFcnJvckdyb3VwIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbGVzID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkpTT05QYXJzZXJFcnJvckdyb3VwXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGAke3RoaXMuZXJyb3JzLmxlbmd0aH0gZXJyb3Ike3RoaXMuZXJyb3JzLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJ9IG9jY3VycmVkIHdoaWxlIHJlYWRpbmcgJyR7KDAsIHVybF9qc18xLnRvRmlsZVN5c3RlbVBhdGgpKHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCl9J2A7XG4gICAgICAgIG9ub18xLk9uby5leHRlbmQodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQYXJzZXJFcnJvcnMocGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0ICRyZWYgb2YgT2JqZWN0LnZhbHVlcyhwYXJzZXIuJHJlZnMuXyRyZWZzKSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUygyNTcxKTogT2JqZWN0IGlzIG9mIHR5cGUgJ3Vua25vd24nLlxuICAgICAgICAgICAgaWYgKCRyZWYuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUygyNTcxKTogT2JqZWN0IGlzIG9mIHR5cGUgJ3Vua25vd24nLlxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLiRyZWYuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gSlNPTlBhcnNlckVycm9yR3JvdXAuZ2V0UGFyc2VyRXJyb3JzKHRoaXMuZmlsZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBKU09OUGFyc2VyRXJyb3JHcm91cDtcbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoYEVycm9yIHBhcnNpbmcgJHtzb3VyY2V9OiAke21lc3NhZ2V9YCwgc291cmNlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFUEFSU0VSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5jbGFzcyBVbm1hdGNoZWRQYXJzZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKGBDb3VsZCBub3QgZmluZCBwYXJzZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURQQVJTRVJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVbm1hdGNoZWRQYXJzZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBVbm1hdGNoZWRQYXJzZXJFcnJvcjtcbmNsYXNzIFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGV4LCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoZXgubWVzc2FnZSB8fCBgRXJyb3IgcmVhZGluZyBmaWxlIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc29sdmVyRXJyb3JcIjtcbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGV4KSB7XG4gICAgICAgICAgICB0aGlzLmlvRXJyb3JDb2RlID0gU3RyaW5nKGV4LmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlckVycm9yID0gUmVzb2x2ZXJFcnJvcjtcbmNsYXNzIFVubWF0Y2hlZFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihgQ291bGQgbm90IGZpbmQgcmVzb2x2ZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVubWF0Y2hlZFJlc29sdmVyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IgPSBVbm1hdGNoZWRSZXNvbHZlckVycm9yO1xuY2xhc3MgTWlzc2luZ1BvaW50ZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4sIHBhdGgpIHtcbiAgICAgICAgc3VwZXIoYFRva2VuIFwiJHt0b2tlbn1cIiBkb2VzIG5vdCBleGlzdC5gLCAoMCwgdXJsX2pzXzEuc3RyaXBIYXNoKShwYXRoKSk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRVVOTUFUQ0hFRFJFU09MVkVSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWlzc2luZ1BvaW50ZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuTWlzc2luZ1BvaW50ZXJFcnJvciA9IE1pc3NpbmdQb2ludGVyRXJyb3I7XG5jbGFzcyBJbnZhbGlkUG9pbnRlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludGVyLCBwYXRoKSB7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkICRyZWYgcG9pbnRlciBcIiR7cG9pbnRlcn1cIi4gUG9pbnRlcnMgbXVzdCBiZWdpbiB3aXRoIFwiIy9cImAsICgwLCB1cmxfanNfMS5zdHJpcEhhc2gpKHBhdGgpKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFVU5NQVRDSEVEUkVTT0xWRVJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJJbnZhbGlkUG9pbnRlckVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkUG9pbnRlckVycm9yID0gSW52YWxpZFBvaW50ZXJFcnJvcjtcbmZ1bmN0aW9uIGlzSGFuZGxlZEVycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBKU09OUGFyc2VyRXJyb3IgfHwgZXJyIGluc3RhbmNlb2YgSlNPTlBhcnNlckVycm9yR3JvdXA7XG59XG5leHBvcnRzLmlzSGFuZGxlZEVycm9yID0gaXNIYW5kbGVkRXJyb3I7XG5mdW5jdGlvbiBub3JtYWxpemVFcnJvcihlcnIpIHtcbiAgICBpZiAoZXJyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgZXJyLnBhdGggPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbn1cbmV4cG9ydHMubm9ybWFsaXplRXJyb3IgPSBub3JtYWxpemVFcnJvcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5vcm1hbGl6ZUVycm9yIiwiaXNIYW5kbGVkRXJyb3IiLCJJbnZhbGlkUG9pbnRlckVycm9yIiwiTWlzc2luZ1BvaW50ZXJFcnJvciIsIlVubWF0Y2hlZFJlc29sdmVyRXJyb3IiLCJSZXNvbHZlckVycm9yIiwiVW5tYXRjaGVkUGFyc2VyRXJyb3IiLCJQYXJzZXJFcnJvciIsIkpTT05QYXJzZXJFcnJvckdyb3VwIiwiSlNPTlBhcnNlckVycm9yIiwib25vXzEiLCJyZXF1aXJlIiwidXJsX2pzXzEiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsInNvdXJjZSIsImNvZGUiLCJuYW1lIiwicGF0aCIsIk9ubyIsImV4dGVuZCIsImZvb3RwcmludCIsInBhcnNlciIsImZpbGVzIiwiZXJyb3JzIiwibGVuZ3RoIiwidG9GaWxlU3lzdGVtUGF0aCIsIiRyZWZzIiwiX3Jvb3QkUmVmIiwiZ2V0UGFyc2VyRXJyb3JzIiwiJHJlZiIsInZhbHVlcyIsIl8kcmVmcyIsInB1c2giLCJleCIsImlvRXJyb3JDb2RlIiwiU3RyaW5nIiwidG9rZW4iLCJzdHJpcEhhc2giLCJwb2ludGVyIiwiZXJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isWindows = void 0;\nconst isWindowsConst = /^win/.test(globalThis.process ? globalThis.process.platform : \"\");\nconst isWindows = ()=>isWindowsConst;\nexports.isWindows = isWindows;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9pcy13aW5kb3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLGlCQUFpQixPQUFPQyxJQUFJLENBQUNDLFdBQVdDLE9BQU8sR0FBR0QsV0FBV0MsT0FBTyxDQUFDQyxRQUFRLEdBQUc7QUFDdEYsTUFBTUwsWUFBWSxJQUFNQztBQUN4QkgsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2lzLXdpbmRvd3MuanM/MWEzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNXaW5kb3dzID0gdm9pZCAwO1xuY29uc3QgaXNXaW5kb3dzQ29uc3QgPSAvXndpbi8udGVzdChnbG9iYWxUaGlzLnByb2Nlc3MgPyBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gOiBcIlwiKTtcbmNvbnN0IGlzV2luZG93cyA9ICgpID0+IGlzV2luZG93c0NvbnN0O1xuZXhwb3J0cy5pc1dpbmRvd3MgPSBpc1dpbmRvd3M7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc1dpbmRvd3MiLCJpc1dpbmRvd3NDb25zdCIsInRlc3QiLCJnbG9iYWxUaGlzIiwicHJvY2VzcyIsInBsYXRmb3JtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst next_js_1 = __importDefault(__webpack_require__(/*! ./next.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\"));\nfunction maybe(cb, promise) {\n    if (cb) {\n        promise.then(function(result) {\n            (0, next_js_1.default)(function() {\n                cb(null, result);\n            });\n        }, function(err) {\n            (0, next_js_1.default)(function() {\n                cb(err);\n            });\n        });\n        return undefined;\n    } else {\n        return promise;\n    }\n}\nexports[\"default\"] = maybe;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9tYXliZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxZQUFZUCxnQkFBZ0JRLG1CQUFPQSxDQUFDLGlHQUFXO0FBQ3JELFNBQVNDLE1BQU1DLEVBQUUsRUFBRUMsT0FBTztJQUN0QixJQUFJRCxJQUFJO1FBQ0pDLFFBQVFDLElBQUksQ0FBQyxTQUFVQyxNQUFNO1lBQ3hCLElBQUdOLFVBQVVPLE9BQU8sRUFBRTtnQkFDbkJKLEdBQUcsTUFBTUc7WUFDYjtRQUNKLEdBQUcsU0FBVUUsR0FBRztZQUNYLElBQUdSLFVBQVVPLE9BQU8sRUFBRTtnQkFDbkJKLEdBQUdLO1lBQ1A7UUFDSjtRQUNBLE9BQU9DO0lBQ1gsT0FDSztRQUNELE9BQU9MO0lBQ1g7QUFDSjtBQUNBTixrQkFBZSxHQUFHSSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9tYXliZS5qcz9lNDMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbmV4dF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL25leHQuanNcIikpO1xuZnVuY3Rpb24gbWF5YmUoY2IsIHByb21pc2UpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICgwLCBuZXh0X2pzXzEuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgKDAsIG5leHRfanNfMS5kZWZhdWx0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1heWJlO1xuIl0sIm5hbWVzIjpbIl9faW1wb3J0RGVmYXVsdCIsIm1vZCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm5leHRfanNfMSIsInJlcXVpcmUiLCJtYXliZSIsImNiIiwicHJvbWlzZSIsInRoZW4iLCJyZXN1bHQiLCJkZWZhdWx0IiwiZXJyIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction makeNext() {\n    if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n        return process.nextTick;\n    } else if (typeof setImmediate === \"function\") {\n        return setImmediate;\n    } else {\n        return function next(f) {\n            setTimeout(f, 0);\n        };\n    }\n}\nexports[\"default\"] = makeNext();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9uZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELFNBQVNDO0lBQ0wsSUFBSSxPQUFPQyxZQUFZLFlBQVksT0FBT0EsUUFBUUMsUUFBUSxLQUFLLFlBQVk7UUFDdkUsT0FBT0QsUUFBUUMsUUFBUTtJQUMzQixPQUNLLElBQUksT0FBT0MsaUJBQWlCLFlBQVk7UUFDekMsT0FBT0E7SUFDWCxPQUNLO1FBQ0QsT0FBTyxTQUFTQyxLQUFLQyxDQUFDO1lBQ2xCQyxXQUFXRCxHQUFHO1FBQ2xCO0lBQ0o7QUFDSjtBQUNBUCxrQkFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9uZXh0LmpzPzVlZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtYWtlTmV4dCgpIHtcbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljaztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dChmKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGYsIDApO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VOZXh0KCk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtYWtlTmV4dCIsInByb2Nlc3MiLCJuZXh0VGljayIsInNldEltbWVkaWF0ZSIsIm5leHQiLCJmIiwic2V0VGltZW91dCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.run = exports.sort = exports.filter = exports.all = void 0;\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @returns\n */ function all(plugins) {\n    return Object.keys(plugins).filter((key)=>{\n        return typeof plugins[key] === \"object\";\n    }).map((key)=>{\n        plugins[key].name = key;\n        return plugins[key];\n    });\n}\nexports.all = all;\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */ function filter(plugins, method, file) {\n    return plugins.filter((plugin)=>{\n        return !!getResult(plugin, method, file);\n    });\n}\nexports.filter = filter;\n/**\n * Sorts the given plugins, in place, by their `order` property.\n */ function sort(plugins) {\n    for (const plugin of plugins){\n        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n    }\n    return plugins.sort((a, b)=>{\n        return a.order - b.order;\n    });\n}\nexports.sort = sort;\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */ async function run(plugins, method, file, $refs) {\n    let plugin;\n    let lastError;\n    let index = 0;\n    return new Promise((resolve, reject)=>{\n        runNextPlugin();\n        function runNextPlugin() {\n            plugin = plugins[index++];\n            if (!plugin) {\n                // There are no more functions, so re-throw the last error\n                return reject(lastError);\n            }\n            try {\n                // console.log('  %s', plugin.name);\n                const result = getResult(plugin, method, file, callback, $refs);\n                if (result && typeof result.then === \"function\") {\n                    // A promise was returned\n                    result.then(onSuccess, onError);\n                } else if (result !== undefined) {\n                    // A synchronous result was returned\n                    onSuccess(result);\n                } else if (index === plugins.length) {\n                    throw new Error(\"No promise has been returned or callback has been called.\");\n                }\n            } catch (e) {\n                onError(e);\n            }\n        }\n        function callback(err, result) {\n            if (err) {\n                onError(err);\n            } else {\n                onSuccess(result);\n            }\n        }\n        function onSuccess(result) {\n            // console.log('    success');\n            resolve({\n                plugin,\n                result\n            });\n        }\n        function onError(error) {\n            // console.log('    %s', err.message || err);\n            lastError = {\n                plugin,\n                error\n            };\n            runNextPlugin();\n        }\n    });\n}\nexports.run = run;\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an array, then it will be compared against the file extension.\n */ function getResult(obj, prop, file, callback, $refs) {\n    const value = obj[prop];\n    if (typeof value === \"function\") {\n        return value.apply(obj, [\n            file,\n            callback,\n            $refs\n        ]);\n    }\n    if (!callback) {\n        // The synchronous plugin functions (canParse and canRead)\n        // allow a \"shorthand\" syntax, where the user can match\n        // files by RegExp or by file extension.\n        if (value instanceof RegExp) {\n            return value.test(file.url);\n        } else if (typeof value === \"string\") {\n            return value === file.extension;\n        } else if (Array.isArray(value)) {\n            return value.indexOf(file.extension) !== -1;\n        }\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9wbHVnaW5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxXQUFXLEdBQUdBLFlBQVksR0FBR0EsY0FBYyxHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUNqRTs7Ozs7Q0FLQyxHQUNELFNBQVNLLElBQUlDLE9BQU87SUFDaEIsT0FBT1IsT0FBT1MsSUFBSSxDQUFDRCxTQUNkRixNQUFNLENBQUMsQ0FBQ0k7UUFDVCxPQUFPLE9BQU9GLE9BQU8sQ0FBQ0UsSUFBSSxLQUFLO0lBQ25DLEdBQ0tDLEdBQUcsQ0FBQyxDQUFDRDtRQUNORixPQUFPLENBQUNFLElBQUksQ0FBQ0UsSUFBSSxHQUFHRjtRQUNwQixPQUFPRixPQUFPLENBQUNFLElBQUk7SUFDdkI7QUFDSjtBQUNBUixXQUFXLEdBQUdLO0FBQ2Q7O0NBRUMsR0FDRCxTQUFTRCxPQUFPRSxPQUFPLEVBQUVLLE1BQU0sRUFBRUMsSUFBSTtJQUNqQyxPQUFPTixRQUFRRixNQUFNLENBQUMsQ0FBQ1M7UUFDbkIsT0FBTyxDQUFDLENBQUNDLFVBQVVELFFBQVFGLFFBQVFDO0lBQ3ZDO0FBQ0o7QUFDQVosY0FBYyxHQUFHSTtBQUNqQjs7Q0FFQyxHQUNELFNBQVNELEtBQUtHLE9BQU87SUFDakIsS0FBSyxNQUFNTyxVQUFVUCxRQUFTO1FBQzFCTyxPQUFPRSxLQUFLLEdBQUdGLE9BQU9FLEtBQUssSUFBSUMsT0FBT0MsZ0JBQWdCO0lBQzFEO0lBQ0EsT0FBT1gsUUFBUUgsSUFBSSxDQUFDLENBQUNlLEdBQUdDO1FBQ3BCLE9BQU9ELEVBQUVILEtBQUssR0FBR0ksRUFBRUosS0FBSztJQUM1QjtBQUNKO0FBQ0FmLFlBQVksR0FBR0c7QUFDZjs7Ozs7OztDQU9DLEdBQ0QsZUFBZUQsSUFBSUksT0FBTyxFQUFFSyxNQUFNLEVBQUVDLElBQUksRUFBRVEsS0FBSztJQUMzQyxJQUFJUDtJQUNKLElBQUlRO0lBQ0osSUFBSUMsUUFBUTtJQUNaLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUN6QkM7UUFDQSxTQUFTQTtZQUNMYixTQUFTUCxPQUFPLENBQUNnQixRQUFRO1lBQ3pCLElBQUksQ0FBQ1QsUUFBUTtnQkFDVCwwREFBMEQ7Z0JBQzFELE9BQU9ZLE9BQU9KO1lBQ2xCO1lBQ0EsSUFBSTtnQkFDQSxvQ0FBb0M7Z0JBQ3BDLE1BQU1NLFNBQVNiLFVBQVVELFFBQVFGLFFBQVFDLE1BQU1nQixVQUFVUjtnQkFDekQsSUFBSU8sVUFBVSxPQUFPQSxPQUFPRSxJQUFJLEtBQUssWUFBWTtvQkFDN0MseUJBQXlCO29CQUN6QkYsT0FBT0UsSUFBSSxDQUFDQyxXQUFXQztnQkFDM0IsT0FDSyxJQUFJSixXQUFXSyxXQUFXO29CQUMzQixvQ0FBb0M7b0JBQ3BDRixVQUFVSDtnQkFDZCxPQUNLLElBQUlMLFVBQVVoQixRQUFRMkIsTUFBTSxFQUFFO29CQUMvQixNQUFNLElBQUlDLE1BQU07Z0JBQ3BCO1lBQ0osRUFDQSxPQUFPQyxHQUFHO2dCQUNOSixRQUFRSTtZQUNaO1FBQ0o7UUFDQSxTQUFTUCxTQUFTUSxHQUFHLEVBQUVULE1BQU07WUFDekIsSUFBSVMsS0FBSztnQkFDTEwsUUFBUUs7WUFDWixPQUNLO2dCQUNETixVQUFVSDtZQUNkO1FBQ0o7UUFDQSxTQUFTRyxVQUFVSCxNQUFNO1lBQ3JCLDhCQUE4QjtZQUM5QkgsUUFBUTtnQkFDSlg7Z0JBQ0FjO1lBQ0o7UUFDSjtRQUNBLFNBQVNJLFFBQVFNLEtBQUs7WUFDbEIsNkNBQTZDO1lBQzdDaEIsWUFBWTtnQkFDUlI7Z0JBQ0F3QjtZQUNKO1lBQ0FYO1FBQ0o7SUFDSjtBQUNKO0FBQ0ExQixXQUFXLEdBQUdFO0FBQ2Q7Ozs7O0NBS0MsR0FDRCxTQUFTWSxVQUFVd0IsR0FBRyxFQUFFQyxJQUFJLEVBQUUzQixJQUFJLEVBQUVnQixRQUFRLEVBQUVSLEtBQUs7SUFDL0MsTUFBTW5CLFFBQVFxQyxHQUFHLENBQUNDLEtBQUs7SUFDdkIsSUFBSSxPQUFPdEMsVUFBVSxZQUFZO1FBQzdCLE9BQU9BLE1BQU11QyxLQUFLLENBQUNGLEtBQUs7WUFBQzFCO1lBQU1nQjtZQUFVUjtTQUFNO0lBQ25EO0lBQ0EsSUFBSSxDQUFDUSxVQUFVO1FBQ1gsMERBQTBEO1FBQzFELHVEQUF1RDtRQUN2RCx3Q0FBd0M7UUFDeEMsSUFBSTNCLGlCQUFpQndDLFFBQVE7WUFDekIsT0FBT3hDLE1BQU15QyxJQUFJLENBQUM5QixLQUFLK0IsR0FBRztRQUM5QixPQUNLLElBQUksT0FBTzFDLFVBQVUsVUFBVTtZQUNoQyxPQUFPQSxVQUFVVyxLQUFLZ0MsU0FBUztRQUNuQyxPQUNLLElBQUlDLE1BQU1DLE9BQU8sQ0FBQzdDLFFBQVE7WUFDM0IsT0FBT0EsTUFBTThDLE9BQU8sQ0FBQ25DLEtBQUtnQyxTQUFTLE1BQU0sQ0FBQztRQUM5QztJQUNKO0lBQ0EsT0FBTzNDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3V0aWwvcGx1Z2lucy5qcz9mZWU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ydW4gPSBleHBvcnRzLnNvcnQgPSBleHBvcnRzLmZpbHRlciA9IGV4cG9ydHMuYWxsID0gdm9pZCAwO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBwbHVnaW5zIGFzIGFuIGFycmF5LCByYXRoZXIgdGhhbiBhbiBvYmplY3QgbWFwLlxuICogQWxsIG90aGVyIG1ldGhvZHMgaW4gdGhpcyBtb2R1bGUgZXhwZWN0IGFuIGFycmF5IG9mIHBsdWdpbnMgcmF0aGVyIHRoYW4gYW4gb2JqZWN0IG1hcC5cbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhbGwocGx1Z2lucykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwbHVnaW5zKVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW5zW2tleV0gPT09IFwib2JqZWN0XCI7XG4gICAgfSlcbiAgICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIHBsdWdpbnNba2V5XS5uYW1lID0ga2V5O1xuICAgICAgICByZXR1cm4gcGx1Z2luc1trZXldO1xuICAgIH0pO1xufVxuZXhwb3J0cy5hbGwgPSBhbGw7XG4vKipcbiAqIEZpbHRlcnMgdGhlIGdpdmVuIHBsdWdpbnMsIHJldHVybmluZyBvbmx5IHRoZSBvbmVzIHJldHVybiBgdHJ1ZWAgZm9yIHRoZSBnaXZlbiBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwbHVnaW5zLCBtZXRob2QsIGZpbGUpIHtcbiAgICByZXR1cm4gcGx1Z2lucy5maWx0ZXIoKHBsdWdpbikgPT4ge1xuICAgICAgICByZXR1cm4gISFnZXRSZXN1bHQocGx1Z2luLCBtZXRob2QsIGZpbGUpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKipcbiAqIFNvcnRzIHRoZSBnaXZlbiBwbHVnaW5zLCBpbiBwbGFjZSwgYnkgdGhlaXIgYG9yZGVyYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gc29ydChwbHVnaW5zKSB7XG4gICAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgICAgICBwbHVnaW4ub3JkZXIgPSBwbHVnaW4ub3JkZXIgfHwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHJldHVybiBwbHVnaW5zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zb3J0ID0gc29ydDtcbi8qKlxuICogUnVucyB0aGUgc3BlY2lmaWVkIG1ldGhvZCBvZiB0aGUgZ2l2ZW4gcGx1Z2lucywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHJldHVybnMgYSBzdWNjZXNzZnVsIHJlc3VsdC5cbiAqIEVhY2ggbWV0aG9kIGNhbiByZXR1cm4gYSBzeW5jaHJvbm91cyB2YWx1ZSwgYSBQcm9taXNlLCBvciBjYWxsIGFuIGVycm9yLWZpcnN0IGNhbGxiYWNrLlxuICogSWYgdGhlIHByb21pc2UgcmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5LCBvciB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkIHdpdGhvdXQgYW4gZXJyb3IsIHRoZW4gdGhlIHJlc3VsdFxuICogaXMgaW1tZWRpYXRlbHkgcmV0dXJuZWQgYW5kIG5vIGZ1cnRoZXIgcGx1Z2lucyBhcmUgY2FsbGVkLlxuICogSWYgdGhlIHByb21pc2UgcmVqZWN0cywgb3IgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIGFuIGVycm9yLCB0aGVuIHRoZSBuZXh0IHBsdWdpbiBpcyBjYWxsZWQuXG4gKiBJZiBBTEwgcGx1Z2lucyBmYWlsLCB0aGVuIHRoZSBsYXN0IGVycm9yIGlzIHRocm93bi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcnVuKHBsdWdpbnMsIG1ldGhvZCwgZmlsZSwgJHJlZnMpIHtcbiAgICBsZXQgcGx1Z2luO1xuICAgIGxldCBsYXN0RXJyb3I7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBydW5OZXh0UGx1Z2luKCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bk5leHRQbHVnaW4oKSB7XG4gICAgICAgICAgICBwbHVnaW4gPSBwbHVnaW5zW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKCFwbHVnaW4pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gbW9yZSBmdW5jdGlvbnMsIHNvIHJlLXRocm93IHRoZSBsYXN0IGVycm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChsYXN0RXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnICAlcycsIHBsdWdpbi5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZXRSZXN1bHQocGx1Z2luLCBtZXRob2QsIGZpbGUsIGNhbGxiYWNrLCAkcmVmcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHByb21pc2Ugd2FzIHJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgc3luY2hyb25vdXMgcmVzdWx0IHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IHBsdWdpbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb21pc2UgaGFzIGJlZW4gcmV0dXJuZWQgb3IgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3MocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvblN1Y2Nlc3MocmVzdWx0KSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnICAgIHN1Y2Nlc3MnKTtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnICAgICVzJywgZXJyLm1lc3NhZ2UgfHwgZXJyKTtcbiAgICAgICAgICAgIGxhc3RFcnJvciA9IHtcbiAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuTmV4dFBsdWdpbigpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnJ1biA9IHJ1bjtcbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5LlxuICogSWYgdGhlIHByb3BlcnR5IGlzIGEgZnVuY3Rpb24sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gaXMgcmV0dXJuZWQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBSZWdFeHAsIHRoZW4gaXQgd2lsbCBiZSB0ZXN0ZWQgYWdhaW5zdCB0aGUgZmlsZSBVUkwuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gaXQgd2lsbCBiZSBjb21wYXJlZCBhZ2FpbnN0IHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVzdWx0KG9iaiwgcHJvcCwgZmlsZSwgY2FsbGJhY2ssICRyZWZzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShvYmosIFtmaWxlLCBjYWxsYmFjaywgJHJlZnNdKTtcbiAgICB9XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAvLyBUaGUgc3luY2hyb25vdXMgcGx1Z2luIGZ1bmN0aW9ucyAoY2FuUGFyc2UgYW5kIGNhblJlYWQpXG4gICAgICAgIC8vIGFsbG93IGEgXCJzaG9ydGhhbmRcIiBzeW50YXgsIHdoZXJlIHRoZSB1c2VyIGNhbiBtYXRjaFxuICAgICAgICAvLyBmaWxlcyBieSBSZWdFeHAgb3IgYnkgZmlsZSBleHRlbnNpb24uXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRlc3QoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmaWxlLmV4dGVuc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmluZGV4T2YoZmlsZS5leHRlbnNpb24pICE9PSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJydW4iLCJzb3J0IiwiZmlsdGVyIiwiYWxsIiwicGx1Z2lucyIsImtleXMiLCJrZXkiLCJtYXAiLCJuYW1lIiwibWV0aG9kIiwiZmlsZSIsInBsdWdpbiIsImdldFJlc3VsdCIsIm9yZGVyIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsImEiLCJiIiwiJHJlZnMiLCJsYXN0RXJyb3IiLCJpbmRleCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicnVuTmV4dFBsdWdpbiIsInJlc3VsdCIsImNhbGxiYWNrIiwidGhlbiIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJFcnJvciIsImUiLCJlcnIiLCJlcnJvciIsIm9iaiIsInByb3AiLCJhcHBseSIsIlJlZ0V4cCIsInRlc3QiLCJ1cmwiLCJleHRlbnNpb24iLCJBcnJheSIsImlzQXJyYXkiLCJpbmRleE9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.relative = exports.safePointerToPath = exports.toFileSystemPath = exports.fromFileSystemPath = exports.isFileSystemPath = exports.isHttp = exports.stripHash = exports.getHash = exports.stripQuery = exports.getExtension = exports.getProtocol = exports.cwd = exports.resolve = exports.parse = void 0;\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./convert-path-to-posix */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\nconst path_1 = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst is_windows_1 = __webpack_require__(/*! ./is-windows */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\");\nconst projectDir = (0, path_2.join)(__dirname, \"..\", \"..\");\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [\n    /\\?/g,\n    \"%3F\",\n    /#/g,\n    \"%23\"\n];\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [\n    /%23/g,\n    \"#\",\n    /%24/g,\n    \"$\",\n    /%26/g,\n    \"&\",\n    /%2C/g,\n    \",\",\n    /%40/g,\n    \"@\"\n];\nconst parse = (u)=>new URL(u);\nexports.parse = parse;\n/**\n * Returns resolved target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF.\n *\n * @returns\n */ function resolve(from, to) {\n    const fromUrl = new URL((0, convert_path_to_posix_1.default)(from), \"resolve://\");\n    const resolvedUrl = new URL((0, convert_path_to_posix_1.default)(to), fromUrl);\n    if (resolvedUrl.protocol === \"resolve:\") {\n        // `from` is a relative URL.\n        const { pathname, search, hash } = resolvedUrl;\n        return pathname + search + hash;\n    }\n    return resolvedUrl.toString();\n}\nexports.resolve = resolve;\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns\n */ function cwd() {\n    if (false) {}\n    const path = process.cwd();\n    const lastChar = path.slice(-1);\n    if (lastChar === \"/\" || lastChar === \"\\\\\") {\n        return path;\n    } else {\n        return path + \"/\";\n    }\n}\nexports.cwd = cwd;\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param path\n * @returns\n */ function getProtocol(path) {\n    const match = protocolPattern.exec(path || \"\");\n    if (match) {\n        return match[1].toLowerCase();\n    }\n}\nexports.getProtocol = getProtocol;\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param path\n * @returns\n */ function getExtension(path) {\n    const lastDot = path.lastIndexOf(\".\");\n    if (lastDot >= 0) {\n        return stripQuery(path.substr(lastDot).toLowerCase());\n    }\n    return \"\";\n}\nexports.getExtension = getExtension;\n/**\n * Removes the query, if any, from the given path.\n *\n * @param path\n * @returns\n */ function stripQuery(path) {\n    const queryIndex = path.indexOf(\"?\");\n    if (queryIndex >= 0) {\n        path = path.substr(0, queryIndex);\n    }\n    return path;\n}\nexports.stripQuery = stripQuery;\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param path\n * @returns\n */ function getHash(path) {\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        return path.substr(hashIndex);\n    }\n    return \"#\";\n}\nexports.getHash = getHash;\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param path\n * @returns\n */ function stripHash(path) {\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        path = path.substr(0, hashIndex);\n    }\n    return path;\n}\nexports.stripHash = stripHash;\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param path\n * @returns\n */ function isHttp(path) {\n    const protocol = getProtocol(path);\n    if (protocol === \"http\" || protocol === \"https\") {\n        return true;\n    } else if (protocol === undefined) {\n        // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n        return \"undefined\" !== \"undefined\";\n    } else {\n        // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n        return false;\n    }\n}\nexports.isHttp = isHttp;\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param path\n * @returns\n */ function isFileSystemPath(path) {\n    // @ts-ignore\n    if (false) {}\n    const protocol = getProtocol(path);\n    return protocol === undefined || protocol === \"file\";\n}\nexports.isFileSystemPath = isFileSystemPath;\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param path\n * @returns\n */ function fromFileSystemPath(path) {\n    // Step 1: On Windows, replace backslashes with forward slashes,\n    // rather than encoding them as \"%5C\"\n    if ((0, is_windows_1.isWindows)()) {\n        const upperPath = path.toUpperCase();\n        const projectDirPosixPath = (0, convert_path_to_posix_1.default)(projectDir);\n        const posixUpper = projectDirPosixPath.toUpperCase();\n        const hasProjectDir = upperPath.includes(posixUpper);\n        const hasProjectUri = upperPath.includes(posixUpper);\n        const isAbsolutePath = path_1.win32.isAbsolute(path);\n        if (!(hasProjectDir || hasProjectUri || isAbsolutePath)) {\n            path = (0, path_2.join)(projectDir, path);\n        }\n        path = (0, convert_path_to_posix_1.default)(path);\n    }\n    // Step 2: `encodeURI` will take care of MOST characters\n    path = encodeURI(path);\n    // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for(let i = 0; i < urlEncodePatterns.length; i += 2){\n        path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n    }\n    return path;\n}\nexports.fromFileSystemPath = fromFileSystemPath;\n/**\n * Converts a URL to a local filesystem path.\n */ function toFileSystemPath(path, keepFileProtocol) {\n    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n    path = decodeURI(path);\n    // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for(let i = 0; i < urlDecodePatterns.length; i += 2){\n        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n    }\n    // Step 3: If it's a \"file://\" URL, then format it consistently\n    // or convert it to a local filesystem path\n    let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n    if (isFileUrl) {\n        // Strip-off the protocol, and the initial \"/\", if there is one\n        path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n        // insert a colon (\":\") after the drive letter on Windows\n        if ((0, is_windows_1.isWindows)() && path[1] === \"/\") {\n            path = path[0] + \":\" + path.substr(1);\n        }\n        if (keepFileProtocol) {\n            // Return the consistently-formatted \"file://\" URL\n            path = \"file:///\" + path;\n        } else {\n            // Convert the \"file://\" URL to a local filesystem path.\n            // On Windows, it will start with something like \"C:/\".\n            // On Posix, it will start with \"/\"\n            isFileUrl = false;\n            path = (0, is_windows_1.isWindows)() ? path : \"/\" + path;\n        }\n    }\n    // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n    if ((0, is_windows_1.isWindows)() && !isFileUrl) {\n        // Replace forward slashes with backslashes\n        path = path.replace(forwardSlashPattern, \"\\\\\");\n        // Capitalize the drive letter\n        if (path.substr(1, 2) === \":\\\\\") {\n            path = path[0].toUpperCase() + path.substr(1);\n        }\n    }\n    return path;\n}\nexports.toFileSystemPath = toFileSystemPath;\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param pointer\n * @returns\n */ function safePointerToPath(pointer) {\n    if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n        return [];\n    }\n    return pointer.slice(2).split(\"/\").map((value)=>{\n        return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n}\nexports.safePointerToPath = safePointerToPath;\nfunction relative(from, to) {\n    if (!isFileSystemPath(from) || !isFileSystemPath(to)) {\n        return resolve(from, to);\n    }\n    const fromDir = path_1.default.dirname(stripHash(from));\n    const toPath = stripHash(to);\n    const result = path_1.default.relative(fromDir, toPath);\n    return result + getHash(to);\n}\nexports.relative = relative;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC91cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZQUFZLElBQUssU0FBVUMsR0FBRztJQUMzRCxJQUFJQSxPQUFPQSxJQUFJVixVQUFVLEVBQUUsT0FBT1U7SUFDbEMsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSUQsT0FBTyxNQUFNO1FBQUEsSUFBSyxJQUFJZixLQUFLZSxJQUFLLElBQUlmLE1BQU0sYUFBYUosT0FBT3FCLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNKLEtBQUtmLElBQUlMLGdCQUFnQnFCLFFBQVFELEtBQUtmO0lBQUU7SUFDeElXLG1CQUFtQkssUUFBUUQ7SUFDM0IsT0FBT0M7QUFDWDtBQUNBLElBQUlJLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVTCxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSVYsVUFBVSxHQUFJVSxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBbkIsOENBQTZDO0lBQUVpQixPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdEUSxnQkFBZ0IsR0FBR0EseUJBQXlCLEdBQUdBLHdCQUF3QixHQUFHQSwwQkFBMEIsR0FBR0Esd0JBQXdCLEdBQUdBLGNBQWMsR0FBR0EsaUJBQWlCLEdBQUdBLGVBQWUsR0FBR0Esa0JBQWtCLEdBQUdBLG9CQUFvQixHQUFHQSxtQkFBbUIsR0FBR0EsV0FBVyxHQUFHQSxlQUFlLEdBQUdBLGFBQWEsR0FBRyxLQUFLO0FBQ2hULE1BQU1lLDBCQUEwQmhCLGdCQUFnQmlCLG1CQUFPQSxDQUFDLGdJQUF5QjtBQUNqRixNQUFNQyxTQUFTeEIsYUFBYXVCLG1CQUFPQSxDQUFDLGtCQUFNO0FBQzFDLE1BQU1FLHNCQUFzQjtBQUM1QixNQUFNQyxrQkFBa0I7QUFDeEIsTUFBTUMsbUJBQW1CO0FBQ3pCLE1BQU1DLG1CQUFtQjtBQUN6QixNQUFNQyxTQUFTTixtQkFBT0EsQ0FBQyxrQkFBTTtBQUM3QixNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQywwR0FBYztBQUMzQyxNQUFNUSxhQUFhLENBQUMsR0FBR0YsT0FBT0csSUFBSSxFQUFFQyxXQUFXLE1BQU07QUFDckQsNkVBQTZFO0FBQzdFLE1BQU1DLG9CQUFvQjtJQUFDO0lBQU87SUFBTztJQUFNO0NBQU07QUFDckQsOEVBQThFO0FBQzlFLE1BQU1DLG9CQUFvQjtJQUFDO0lBQVE7SUFBSztJQUFRO0lBQUs7SUFBUTtJQUFLO0lBQVE7SUFBSztJQUFRO0NBQUk7QUFDM0YsTUFBTWQsUUFBUSxDQUFDZSxJQUFNLElBQUlDLElBQUlEO0FBQzdCN0IsYUFBYSxHQUFHYztBQUNoQjs7OztDQUlDLEdBQ0QsU0FBU0QsUUFBUWtCLElBQUksRUFBRUMsRUFBRTtJQUNyQixNQUFNQyxVQUFVLElBQUlILElBQUksQ0FBQyxHQUFHZix3QkFBd0JtQixPQUFPLEVBQUVILE9BQU87SUFDcEUsTUFBTUksY0FBYyxJQUFJTCxJQUFJLENBQUMsR0FBR2Ysd0JBQXdCbUIsT0FBTyxFQUFFRixLQUFLQztJQUN0RSxJQUFJRSxZQUFZQyxRQUFRLEtBQUssWUFBWTtRQUNyQyw0QkFBNEI7UUFDNUIsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUdKO1FBQ25DLE9BQU9FLFdBQVdDLFNBQVNDO0lBQy9CO0lBQ0EsT0FBT0osWUFBWUssUUFBUTtBQUMvQjtBQUNBeEMsZUFBZSxHQUFHYTtBQUNsQjs7OztDQUlDLEdBQ0QsU0FBU0Q7SUFDTCxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7SUFDRCxNQUFNK0IsT0FBT0MsUUFBUWhDLEdBQUc7SUFDeEIsTUFBTWlDLFdBQVdGLEtBQUtHLEtBQUssQ0FBQyxDQUFDO0lBQzdCLElBQUlELGFBQWEsT0FBT0EsYUFBYSxNQUFNO1FBQ3ZDLE9BQU9GO0lBQ1gsT0FDSztRQUNELE9BQU9BLE9BQU87SUFDbEI7QUFDSjtBQUNBM0MsV0FBVyxHQUFHWTtBQUNkOzs7OztDQUtDLEdBQ0QsU0FBU0QsWUFBWWdDLElBQUk7SUFDckIsTUFBTUksUUFBUTVCLGdCQUFnQjZCLElBQUksQ0FBQ0wsUUFBUTtJQUMzQyxJQUFJSSxPQUFPO1FBQ1AsT0FBT0EsS0FBSyxDQUFDLEVBQUUsQ0FBQ0UsV0FBVztJQUMvQjtBQUNKO0FBQ0FqRCxtQkFBbUIsR0FBR1c7QUFDdEI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsYUFBYWlDLElBQUk7SUFDdEIsTUFBTU8sVUFBVVAsS0FBS1EsV0FBVyxDQUFDO0lBQ2pDLElBQUlELFdBQVcsR0FBRztRQUNkLE9BQU96QyxXQUFXa0MsS0FBS1MsTUFBTSxDQUFDRixTQUFTRCxXQUFXO0lBQ3REO0lBQ0EsT0FBTztBQUNYO0FBQ0FqRCxvQkFBb0IsR0FBR1U7QUFDdkI7Ozs7O0NBS0MsR0FDRCxTQUFTRCxXQUFXa0MsSUFBSTtJQUNwQixNQUFNVSxhQUFhVixLQUFLVyxPQUFPLENBQUM7SUFDaEMsSUFBSUQsY0FBYyxHQUFHO1FBQ2pCVixPQUFPQSxLQUFLUyxNQUFNLENBQUMsR0FBR0M7SUFDMUI7SUFDQSxPQUFPVjtBQUNYO0FBQ0EzQyxrQkFBa0IsR0FBR1M7QUFDckI7Ozs7OztDQU1DLEdBQ0QsU0FBU0QsUUFBUW1DLElBQUk7SUFDakIsTUFBTVksWUFBWVosS0FBS1csT0FBTyxDQUFDO0lBQy9CLElBQUlDLGFBQWEsR0FBRztRQUNoQixPQUFPWixLQUFLUyxNQUFNLENBQUNHO0lBQ3ZCO0lBQ0EsT0FBTztBQUNYO0FBQ0F2RCxlQUFlLEdBQUdRO0FBQ2xCOzs7OztDQUtDLEdBQ0QsU0FBU0QsVUFBVW9DLElBQUk7SUFDbkIsTUFBTVksWUFBWVosS0FBS1csT0FBTyxDQUFDO0lBQy9CLElBQUlDLGFBQWEsR0FBRztRQUNoQlosT0FBT0EsS0FBS1MsTUFBTSxDQUFDLEdBQUdHO0lBQzFCO0lBQ0EsT0FBT1o7QUFDWDtBQUNBM0MsaUJBQWlCLEdBQUdPO0FBQ3BCOzs7OztDQUtDLEdBQ0QsU0FBU0QsT0FBT3FDLElBQUk7SUFDaEIsTUFBTVAsV0FBV3pCLFlBQVlnQztJQUM3QixJQUFJUCxhQUFhLFVBQVVBLGFBQWEsU0FBUztRQUM3QyxPQUFPO0lBQ1gsT0FDSyxJQUFJQSxhQUFhdkQsV0FBVztRQUM3QiwrRUFBK0U7UUFDL0UsT0FBTyxnQkFBa0I7SUFDN0IsT0FDSztRQUNELGlFQUFpRTtRQUNqRSxPQUFPO0lBQ1g7QUFDSjtBQUNBbUIsY0FBYyxHQUFHTTtBQUNqQjs7Ozs7O0NBTUMsR0FDRCxTQUFTRCxpQkFBaUJzQyxJQUFJO0lBQzFCLGFBQWE7SUFDYixJQUFJLEtBQWdELEVBQUUsRUFJckQ7SUFDRCxNQUFNUCxXQUFXekIsWUFBWWdDO0lBQzdCLE9BQU9QLGFBQWF2RCxhQUFhdUQsYUFBYTtBQUNsRDtBQUNBcEMsd0JBQXdCLEdBQUdLO0FBQzNCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELFNBQVNELG1CQUFtQnVDLElBQUk7SUFDNUIsZ0VBQWdFO0lBQ2hFLHFDQUFxQztJQUNyQyxJQUFJLENBQUMsR0FBR3BCLGFBQWFrQyxTQUFTLEtBQUs7UUFDL0IsTUFBTUMsWUFBWWYsS0FBS2dCLFdBQVc7UUFDbEMsTUFBTUMsc0JBQXNCLENBQUMsR0FBRzdDLHdCQUF3Qm1CLE9BQU8sRUFBRVY7UUFDakUsTUFBTXFDLGFBQWFELG9CQUFvQkQsV0FBVztRQUNsRCxNQUFNRyxnQkFBZ0JKLFVBQVVLLFFBQVEsQ0FBQ0Y7UUFDekMsTUFBTUcsZ0JBQWdCTixVQUFVSyxRQUFRLENBQUNGO1FBQ3pDLE1BQU1JLGlCQUFpQmhELE9BQU9pRCxLQUFLLENBQUNDLFVBQVUsQ0FBQ3hCO1FBQy9DLElBQUksQ0FBRW1CLENBQUFBLGlCQUFpQkUsaUJBQWlCQyxjQUFhLEdBQUk7WUFDckR0QixPQUFPLENBQUMsR0FBR3JCLE9BQU9HLElBQUksRUFBRUQsWUFBWW1CO1FBQ3hDO1FBQ0FBLE9BQU8sQ0FBQyxHQUFHNUIsd0JBQXdCbUIsT0FBTyxFQUFFUztJQUNoRDtJQUNBLHdEQUF3RDtJQUN4REEsT0FBT3lCLFVBQVV6QjtJQUNqQiwwRUFBMEU7SUFDMUUsb0ZBQW9GO0lBQ3BGLHVEQUF1RDtJQUN2RCxJQUFLLElBQUkwQixJQUFJLEdBQUdBLElBQUkxQyxrQkFBa0IyQyxNQUFNLEVBQUVELEtBQUssRUFBRztRQUNsRDFCLE9BQU9BLEtBQUs0QixPQUFPLENBQUM1QyxpQkFBaUIsQ0FBQzBDLEVBQUUsRUFBRTFDLGlCQUFpQixDQUFDMEMsSUFBSSxFQUFFO0lBQ3RFO0lBQ0EsT0FBTzFCO0FBQ1g7QUFDQTNDLDBCQUEwQixHQUFHSTtBQUM3Qjs7Q0FFQyxHQUNELFNBQVNELGlCQUFpQndDLElBQUksRUFBRTZCLGdCQUFnQjtJQUM1Qyx1RkFBdUY7SUFDdkY3QixPQUFPOEIsVUFBVTlCO0lBQ2pCLDBFQUEwRTtJQUMxRSxvRkFBb0Y7SUFDcEYsdURBQXVEO0lBQ3ZELElBQUssSUFBSTBCLElBQUksR0FBR0EsSUFBSXpDLGtCQUFrQjBDLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ2xEMUIsT0FBT0EsS0FBSzRCLE9BQU8sQ0FBQzNDLGlCQUFpQixDQUFDeUMsRUFBRSxFQUFFekMsaUJBQWlCLENBQUN5QyxJQUFJLEVBQUU7SUFDdEU7SUFDQSwrREFBK0Q7SUFDL0QsMkNBQTJDO0lBQzNDLElBQUlLLFlBQVkvQixLQUFLUyxNQUFNLENBQUMsR0FBRyxHQUFHSCxXQUFXLE9BQU87SUFDcEQsSUFBSXlCLFdBQVc7UUFDWCwrREFBK0Q7UUFDL0QvQixPQUFPQSxJQUFJLENBQUMsRUFBRSxLQUFLLE1BQU1BLEtBQUtTLE1BQU0sQ0FBQyxLQUFLVCxLQUFLUyxNQUFNLENBQUM7UUFDdEQseURBQXlEO1FBQ3pELElBQUksQ0FBQyxHQUFHN0IsYUFBYWtDLFNBQVMsT0FBT2QsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLO1lBQ2xEQSxPQUFPQSxJQUFJLENBQUMsRUFBRSxHQUFHLE1BQU1BLEtBQUtTLE1BQU0sQ0FBQztRQUN2QztRQUNBLElBQUlvQixrQkFBa0I7WUFDbEIsa0RBQWtEO1lBQ2xEN0IsT0FBTyxhQUFhQTtRQUN4QixPQUNLO1lBQ0Qsd0RBQXdEO1lBQ3hELHVEQUF1RDtZQUN2RCxtQ0FBbUM7WUFDbkMrQixZQUFZO1lBQ1ovQixPQUFPLENBQUMsR0FBR3BCLGFBQWFrQyxTQUFTLE1BQU1kLE9BQU8sTUFBTUE7UUFDeEQ7SUFDSjtJQUNBLGdFQUFnRTtJQUNoRSxJQUFJLENBQUMsR0FBR3BCLGFBQWFrQyxTQUFTLE9BQU8sQ0FBQ2lCLFdBQVc7UUFDN0MsMkNBQTJDO1FBQzNDL0IsT0FBT0EsS0FBSzRCLE9BQU8sQ0FBQ3JELHFCQUFxQjtRQUN6Qyw4QkFBOEI7UUFDOUIsSUFBSXlCLEtBQUtTLE1BQU0sQ0FBQyxHQUFHLE9BQU8sT0FBTztZQUM3QlQsT0FBT0EsSUFBSSxDQUFDLEVBQUUsQ0FBQ2dCLFdBQVcsS0FBS2hCLEtBQUtTLE1BQU0sQ0FBQztRQUMvQztJQUNKO0lBQ0EsT0FBT1Q7QUFDWDtBQUNBM0Msd0JBQXdCLEdBQUdHO0FBQzNCOzs7OztDQUtDLEdBQ0QsU0FBU0Qsa0JBQWtCeUUsT0FBTztJQUM5QixJQUFJQSxRQUFRTCxNQUFNLElBQUksS0FBS0ssT0FBTyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxPQUFPLENBQUMsRUFBRSxLQUFLLEtBQUs7UUFDakUsT0FBTyxFQUFFO0lBQ2I7SUFDQSxPQUFPQSxRQUNGN0IsS0FBSyxDQUFDLEdBQ044QixLQUFLLENBQUMsS0FDTkMsR0FBRyxDQUFDLENBQUNyRjtRQUNOLE9BQU9zRixtQkFBbUJ0RixPQUFPK0UsT0FBTyxDQUFDbkQsa0JBQWtCLEtBQUttRCxPQUFPLENBQUNsRCxrQkFBa0I7SUFDOUY7QUFDSjtBQUNBckIseUJBQXlCLEdBQUdFO0FBQzVCLFNBQVNELFNBQVM4QixJQUFJLEVBQUVDLEVBQUU7SUFDdEIsSUFBSSxDQUFDM0IsaUJBQWlCMEIsU0FBUyxDQUFDMUIsaUJBQWlCMkIsS0FBSztRQUNsRCxPQUFPbkIsUUFBUWtCLE1BQU1DO0lBQ3pCO0lBQ0EsTUFBTStDLFVBQVU5RCxPQUFPaUIsT0FBTyxDQUFDOEMsT0FBTyxDQUFDekUsVUFBVXdCO0lBQ2pELE1BQU1rRCxTQUFTMUUsVUFBVXlCO0lBQ3pCLE1BQU1yQyxTQUFTc0IsT0FBT2lCLE9BQU8sQ0FBQ2pDLFFBQVEsQ0FBQzhFLFNBQVNFO0lBQ2hELE9BQU90RixTQUFTYSxRQUFRd0I7QUFDNUI7QUFDQWhDLGdCQUFnQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC91cmwuanM/NTBhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWxhdGl2ZSA9IGV4cG9ydHMuc2FmZVBvaW50ZXJUb1BhdGggPSBleHBvcnRzLnRvRmlsZVN5c3RlbVBhdGggPSBleHBvcnRzLmZyb21GaWxlU3lzdGVtUGF0aCA9IGV4cG9ydHMuaXNGaWxlU3lzdGVtUGF0aCA9IGV4cG9ydHMuaXNIdHRwID0gZXhwb3J0cy5zdHJpcEhhc2ggPSBleHBvcnRzLmdldEhhc2ggPSBleHBvcnRzLnN0cmlwUXVlcnkgPSBleHBvcnRzLmdldEV4dGVuc2lvbiA9IGV4cG9ydHMuZ2V0UHJvdG9jb2wgPSBleHBvcnRzLmN3ZCA9IGV4cG9ydHMucmVzb2x2ZSA9IGV4cG9ydHMucGFyc2UgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb252ZXJ0LXBhdGgtdG8tcG9zaXhcIikpO1xuY29uc3QgcGF0aF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJwYXRoXCIpKTtcbmNvbnN0IGZvcndhcmRTbGFzaFBhdHRlcm4gPSAvXFwvL2c7XG5jb25zdCBwcm90b2NvbFBhdHRlcm4gPSAvXihcXHd7Mix9KTpcXC9cXC8vaTtcbmNvbnN0IGpzb25Qb2ludGVyU2xhc2ggPSAvfjEvZztcbmNvbnN0IGpzb25Qb2ludGVyVGlsZGUgPSAvfjAvZztcbmNvbnN0IHBhdGhfMiA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgaXNfd2luZG93c18xID0gcmVxdWlyZShcIi4vaXMtd2luZG93c1wiKTtcbmNvbnN0IHByb2plY3REaXIgPSAoMCwgcGF0aF8yLmpvaW4pKF9fZGlybmFtZSwgXCIuLlwiLCBcIi4uXCIpO1xuLy8gUmVnRXhwIHBhdHRlcm5zIHRvIFVSTC1lbmNvZGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmNvbnN0IHVybEVuY29kZVBhdHRlcm5zID0gWy9cXD8vZywgXCIlM0ZcIiwgLyMvZywgXCIlMjNcIl07XG4vLyBSZWdFeHAgcGF0dGVybnMgdG8gVVJMLWRlY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmNvbnN0IHVybERlY29kZVBhdHRlcm5zID0gWy8lMjMvZywgXCIjXCIsIC8lMjQvZywgXCIkXCIsIC8lMjYvZywgXCImXCIsIC8lMkMvZywgXCIsXCIsIC8lNDAvZywgXCJAXCJdO1xuY29uc3QgcGFyc2UgPSAodSkgPT4gbmV3IFVSTCh1KTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKlxuICogUmV0dXJucyByZXNvbHZlZCB0YXJnZXQgVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwgaW4gYSBtYW5uZXIgc2ltaWxhciB0byB0aGF0IG9mIGEgV2ViIGJyb3dzZXIgcmVzb2x2aW5nIGFuIGFuY2hvciB0YWcgSFJFRi5cbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgY29uc3QgZnJvbVVybCA9IG5ldyBVUkwoKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKGZyb20pLCBcInJlc29sdmU6Ly9cIik7XG4gICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKCgwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KSh0byksIGZyb21VcmwpO1xuICAgIGlmIChyZXNvbHZlZFVybC5wcm90b2NvbCA9PT0gXCJyZXNvbHZlOlwiKSB7XG4gICAgICAgIC8vIGBmcm9tYCBpcyBhIHJlbGF0aXZlIFVSTC5cbiAgICAgICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSByZXNvbHZlZFVybDtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkVXJsLnRvU3RyaW5nKCk7XG59XG5leHBvcnRzLnJlc29sdmUgPSByZXNvbHZlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IChpbiBOb2RlKSBvciB0aGUgY3VycmVudCBwYWdlIFVSTCAoaW4gYnJvd3NlcnMpLlxuICpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGN3ZCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaHJlZjtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgY29uc3QgbGFzdENoYXIgPSBwYXRoLnNsaWNlKC0xKTtcbiAgICBpZiAobGFzdENoYXIgPT09IFwiL1wiIHx8IGxhc3RDaGFyID09PSBcIlxcXFxcIikge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoICsgXCIvXCI7XG4gICAgfVxufVxuZXhwb3J0cy5jd2QgPSBjd2Q7XG4vKipcbiAqIFJldHVybnMgdGhlIHByb3RvY29sIG9mIHRoZSBnaXZlbiBVUkwsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGhhcyBubyBwcm90b2NvbC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG9jb2wocGF0aCkge1xuICAgIGNvbnN0IG1hdGNoID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocGF0aCB8fCBcIlwiKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRQcm90b2NvbCA9IGdldFByb3RvY29sO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIG9mIHRoZSBnaXZlbiBVUkwsXG4gKiBvciBhbiBlbXB0eSBzdHJpbmcgaWYgaXQgaGFzIG5vIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHBhdGgpIHtcbiAgICBjb25zdCBsYXN0RG90ID0gcGF0aC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGxhc3REb3QgPj0gMCkge1xuICAgICAgICByZXR1cm4gc3RyaXBRdWVyeShwYXRoLnN1YnN0cihsYXN0RG90KS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLmdldEV4dGVuc2lvbiA9IGdldEV4dGVuc2lvbjtcbi8qKlxuICogUmVtb3ZlcyB0aGUgcXVlcnksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gc3RyaXBRdWVyeShwYXRoKSB7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5zdHJpcFF1ZXJ5ID0gc3RyaXBRdWVyeTtcbi8qKlxuICogUmV0dXJucyB0aGUgaGFzaCAoVVJMIGZyYWdtZW50KSwgb2YgdGhlIGdpdmVuIHBhdGguXG4gKiBJZiB0aGVyZSBpcyBubyBoYXNoLCB0aGVuIHRoZSByb290IGhhc2ggKFwiI1wiKSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0SGFzaChwYXRoKSB7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKFwiI1wiKTtcbiAgICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyKGhhc2hJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBcIiNcIjtcbn1cbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG4vKipcbiAqIFJlbW92ZXMgdGhlIGhhc2ggKFVSTCBmcmFnbWVudCksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gc3RyaXBIYXNoKHBhdGgpIHtcbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLnN0cmlwSGFzaCA9IHN0cmlwSGFzaDtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBwYXRoIGlzIGFuIEhUVFAoUykgVVJMLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0h0dHAocGF0aCkge1xuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocGF0aCk7XG4gICAgaWYgKHByb3RvY29sID09PSBcImh0dHBcIiB8fCBwcm90b2NvbCA9PT0gXCJodHRwc1wiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm90b2NvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIHByb3RvY29sLiAgSWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIHRoZW4gYXNzdW1lIGl0J3MgSFRUUC5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdCdzIHNvbWUgb3RoZXIgcHJvdG9jb2wsIHN1Y2ggYXMgXCJmdHA6Ly9cIiwgXCJtb25nb2RiOi8vXCIsIGV0Yy5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNIdHRwID0gaXNIdHRwO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHBhdGggaXMgYSBmaWxlc3lzdGVtIHBhdGguXG4gKiBUaGlzIGluY2x1ZGVzIFwiZmlsZTovL1wiIFVSTHMuXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZVN5c3RlbVBhdGgocGF0aCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIsIHNvIGFzc3VtZSB0aGF0IGFsbCBwYXRocyBhcmUgVVJMcy5cbiAgICAgICAgLy8gVGhpcyB3YXksIGV2ZW4gcmVsYXRpdmUgcGF0aHMgd2lsbCBiZSB0cmVhdGVkIGFzIFVSTHMgcmF0aGVyIHRoYW4gYXMgZmlsZXN5c3RlbSBwYXRoc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvY29sID0gZ2V0UHJvdG9jb2wocGF0aCk7XG4gICAgcmV0dXJuIHByb3RvY29sID09PSB1bmRlZmluZWQgfHwgcHJvdG9jb2wgPT09IFwiZmlsZVwiO1xufVxuZXhwb3J0cy5pc0ZpbGVTeXN0ZW1QYXRoID0gaXNGaWxlU3lzdGVtUGF0aDtcbi8qKlxuICogQ29udmVydHMgYSBmaWxlc3lzdGVtIHBhdGggdG8gYSBwcm9wZXJseS1lbmNvZGVkIFVSTC5cbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGhhbmRsZSBzaXR1YXRpb25zIHdoZXJlIEpTT04gU2NoZW1hICRSZWYgUGFyc2VyIGlzIGNhbGxlZFxuICogd2l0aCBhIGZpbGVzeXN0ZW0gcGF0aCB0aGF0IGNvbnRhaW5zIGNoYXJhY3RlcnMgd2hpY2ggYXJlIG5vdCBhbGxvd2VkIGluIFVSTHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBmb2xsb3dpbmcgZmlsZXN5c3RlbSBwYXRocyB3b3VsZCBiZSBjb252ZXJ0ZWQgdG8gdGhlIGZvbGxvd2luZyBVUkxzOlxuICpcbiAqICAgIDxcIiFAIyQlXiYqKz0/Jz4uanNvbiAgICAgICAgICAgICAgPT0+ICAgJTNDJTIyIUAlMjMkJTI1JTVFJiorPSUzRlxcJyUzRS5qc29uXG4gKiAgICBDOlxcXFxNeSBEb2N1bWVudHNcXFxcRmlsZSAoMSkuanNvbiAgID09PiAgIEM6L015JTIwRG9jdW1lbnRzL0ZpbGUlMjAoMSkuanNvblxuICogICAgZmlsZTovL1Byb2plY3QgIzQyL2ZpbGUuanNvbiAgICAgID09PiAgIGZpbGU6Ly9Qcm9qZWN0JTIwJTIzNDIvZmlsZS5qc29uXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGZyb21GaWxlU3lzdGVtUGF0aChwYXRoKSB7XG4gICAgLy8gU3RlcCAxOiBPbiBXaW5kb3dzLCByZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLFxuICAgIC8vIHJhdGhlciB0aGFuIGVuY29kaW5nIHRoZW0gYXMgXCIlNUNcIlxuICAgIGlmICgoMCwgaXNfd2luZG93c18xLmlzV2luZG93cykoKSkge1xuICAgICAgICBjb25zdCB1cHBlclBhdGggPSBwYXRoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHByb2plY3REaXJQb3NpeFBhdGggPSAoMCwgY29udmVydF9wYXRoX3RvX3Bvc2l4XzEuZGVmYXVsdCkocHJvamVjdERpcik7XG4gICAgICAgIGNvbnN0IHBvc2l4VXBwZXIgPSBwcm9qZWN0RGlyUG9zaXhQYXRoLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGhhc1Byb2plY3REaXIgPSB1cHBlclBhdGguaW5jbHVkZXMocG9zaXhVcHBlcik7XG4gICAgICAgIGNvbnN0IGhhc1Byb2plY3RVcmkgPSB1cHBlclBhdGguaW5jbHVkZXMocG9zaXhVcHBlcik7XG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGVQYXRoID0gcGF0aF8xLndpbjMyLmlzQWJzb2x1dGUocGF0aCk7XG4gICAgICAgIGlmICghKGhhc1Byb2plY3REaXIgfHwgaGFzUHJvamVjdFVyaSB8fCBpc0Fic29sdXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHBhdGggPSAoMCwgcGF0aF8yLmpvaW4pKHByb2plY3REaXIsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSAoMCwgY29udmVydF9wYXRoX3RvX3Bvc2l4XzEuZGVmYXVsdCkocGF0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXAgMjogYGVuY29kZVVSSWAgd2lsbCB0YWtlIGNhcmUgb2YgTU9TVCBjaGFyYWN0ZXJzXG4gICAgcGF0aCA9IGVuY29kZVVSSShwYXRoKTtcbiAgICAvLyBTdGVwIDM6IE1hbnVhbGx5IGVuY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBlbmNvZGVkIGJ5IGBlbmNvZGVVUklgLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyBzdWNoIGFzIFwiI1wiIGFuZCBcIj9cIiwgd2hpY2ggaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gVVJMcyxcbiAgICAvLyBidXQgYXJlIGp1c3Qgbm9ybWFsIGNoYXJhY3RlcnMgaW4gYSBmaWxlc3lzdGVtIHBhdGguXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxFbmNvZGVQYXR0ZXJucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHVybEVuY29kZVBhdHRlcm5zW2ldLCB1cmxFbmNvZGVQYXR0ZXJuc1tpICsgMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMuZnJvbUZpbGVTeXN0ZW1QYXRoID0gZnJvbUZpbGVTeXN0ZW1QYXRoO1xuLyoqXG4gKiBDb252ZXJ0cyBhIFVSTCB0byBhIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aC5cbiAqL1xuZnVuY3Rpb24gdG9GaWxlU3lzdGVtUGF0aChwYXRoLCBrZWVwRmlsZVByb3RvY29sKSB7XG4gICAgLy8gU3RlcCAxOiBgZGVjb2RlVVJJYCB3aWxsIGRlY29kZSBjaGFyYWN0ZXJzIHN1Y2ggYXMgQ3lyaWxsaWMgY2hhcmFjdGVycywgc3BhY2VzLCBldGMuXG4gICAgcGF0aCA9IGRlY29kZVVSSShwYXRoKTtcbiAgICAvLyBTdGVwIDI6IE1hbnVhbGx5IGRlY29kZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBkZWNvZGVkIGJ5IGBkZWNvZGVVUklgLlxuICAgIC8vIFRoaXMgaW5jbHVkZXMgY2hhcmFjdGVycyBzdWNoIGFzIFwiI1wiIGFuZCBcIj9cIiwgd2hpY2ggaGF2ZSBzcGVjaWFsIG1lYW5pbmcgaW4gVVJMcyxcbiAgICAvLyBidXQgYXJlIGp1c3Qgbm9ybWFsIGNoYXJhY3RlcnMgaW4gYSBmaWxlc3lzdGVtIHBhdGguXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmxEZWNvZGVQYXR0ZXJucy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHVybERlY29kZVBhdHRlcm5zW2ldLCB1cmxEZWNvZGVQYXR0ZXJuc1tpICsgMV0pO1xuICAgIH1cbiAgICAvLyBTdGVwIDM6IElmIGl0J3MgYSBcImZpbGU6Ly9cIiBVUkwsIHRoZW4gZm9ybWF0IGl0IGNvbnNpc3RlbnRseVxuICAgIC8vIG9yIGNvbnZlcnQgaXQgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGhcbiAgICBsZXQgaXNGaWxlVXJsID0gcGF0aC5zdWJzdHIoMCwgNykudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWxlOi8vXCI7XG4gICAgaWYgKGlzRmlsZVVybCkge1xuICAgICAgICAvLyBTdHJpcC1vZmYgdGhlIHByb3RvY29sLCBhbmQgdGhlIGluaXRpYWwgXCIvXCIsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBwYXRoID0gcGF0aFs3XSA9PT0gXCIvXCIgPyBwYXRoLnN1YnN0cig4KSA6IHBhdGguc3Vic3RyKDcpO1xuICAgICAgICAvLyBpbnNlcnQgYSBjb2xvbiAoXCI6XCIpIGFmdGVyIHRoZSBkcml2ZSBsZXR0ZXIgb24gV2luZG93c1xuICAgICAgICBpZiAoKDAsIGlzX3dpbmRvd3NfMS5pc1dpbmRvd3MpKCkgJiYgcGF0aFsxXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoWzBdICsgXCI6XCIgKyBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcEZpbGVQcm90b2NvbCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBjb25zaXN0ZW50bHktZm9ybWF0dGVkIFwiZmlsZTovL1wiIFVSTFxuICAgICAgICAgICAgcGF0aCA9IFwiZmlsZTovLy9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBcImZpbGU6Ly9cIiBVUkwgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGguXG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCBpdCB3aWxsIHN0YXJ0IHdpdGggc29tZXRoaW5nIGxpa2UgXCJDOi9cIi5cbiAgICAgICAgICAgIC8vIE9uIFBvc2l4LCBpdCB3aWxsIHN0YXJ0IHdpdGggXCIvXCJcbiAgICAgICAgICAgIGlzRmlsZVVybCA9IGZhbHNlO1xuICAgICAgICAgICAgcGF0aCA9ICgwLCBpc193aW5kb3dzXzEuaXNXaW5kb3dzKSgpID8gcGF0aCA6IFwiL1wiICsgcGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGVwIDQ6IE5vcm1hbGl6ZSBXaW5kb3dzIHBhdGhzICh1bmxlc3MgaXQncyBhIFwiZmlsZTovL1wiIFVSTClcbiAgICBpZiAoKDAsIGlzX3dpbmRvd3NfMS5pc1dpbmRvd3MpKCkgJiYgIWlzRmlsZVVybCkge1xuICAgICAgICAvLyBSZXBsYWNlIGZvcndhcmQgc2xhc2hlcyB3aXRoIGJhY2tzbGFzaGVzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoZm9yd2FyZFNsYXNoUGF0dGVybiwgXCJcXFxcXCIpO1xuICAgICAgICAvLyBDYXBpdGFsaXplIHRoZSBkcml2ZSBsZXR0ZXJcbiAgICAgICAgaWYgKHBhdGguc3Vic3RyKDEsIDIpID09PSBcIjpcXFxcXCIpIHtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoWzBdLnRvVXBwZXJDYXNlKCkgKyBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMudG9GaWxlU3lzdGVtUGF0aCA9IHRvRmlsZVN5c3RlbVBhdGg7XG4vKipcbiAqIENvbnZlcnRzIGEgJHJlZiBwb2ludGVyIHRvIGEgdmFsaWQgSlNPTiBQYXRoLlxuICpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzYWZlUG9pbnRlclRvUGF0aChwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIubGVuZ3RoIDw9IDEgfHwgcG9pbnRlclswXSAhPT0gXCIjXCIgfHwgcG9pbnRlclsxXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICAgICAgICAuc2xpY2UoMilcbiAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKGpzb25Qb2ludGVyU2xhc2gsIFwiL1wiKS5yZXBsYWNlKGpzb25Qb2ludGVyVGlsZGUsIFwiflwiKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuc2FmZVBvaW50ZXJUb1BhdGggPSBzYWZlUG9pbnRlclRvUGF0aDtcbmZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgaWYgKCFpc0ZpbGVTeXN0ZW1QYXRoKGZyb20pIHx8ICFpc0ZpbGVTeXN0ZW1QYXRoKHRvKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXIgPSBwYXRoXzEuZGVmYXVsdC5kaXJuYW1lKHN0cmlwSGFzaChmcm9tKSk7XG4gICAgY29uc3QgdG9QYXRoID0gc3RyaXBIYXNoKHRvKTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoXzEuZGVmYXVsdC5yZWxhdGl2ZShmcm9tRGlyLCB0b1BhdGgpO1xuICAgIHJldHVybiByZXN1bHQgKyBnZXRIYXNoKHRvKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGVmaW5lUHJvcGVydHkiLCJfX3NldE1vZHVsZURlZmF1bHQiLCJ2IiwidmFsdWUiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJyZXN1bHQiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJfX2ltcG9ydERlZmF1bHQiLCJleHBvcnRzIiwicmVsYXRpdmUiLCJzYWZlUG9pbnRlclRvUGF0aCIsInRvRmlsZVN5c3RlbVBhdGgiLCJmcm9tRmlsZVN5c3RlbVBhdGgiLCJpc0ZpbGVTeXN0ZW1QYXRoIiwiaXNIdHRwIiwic3RyaXBIYXNoIiwiZ2V0SGFzaCIsInN0cmlwUXVlcnkiLCJnZXRFeHRlbnNpb24iLCJnZXRQcm90b2NvbCIsImN3ZCIsInJlc29sdmUiLCJwYXJzZSIsImNvbnZlcnRfcGF0aF90b19wb3NpeF8xIiwicmVxdWlyZSIsInBhdGhfMSIsImZvcndhcmRTbGFzaFBhdHRlcm4iLCJwcm90b2NvbFBhdHRlcm4iLCJqc29uUG9pbnRlclNsYXNoIiwianNvblBvaW50ZXJUaWxkZSIsInBhdGhfMiIsImlzX3dpbmRvd3NfMSIsInByb2plY3REaXIiLCJqb2luIiwiX19kaXJuYW1lIiwidXJsRW5jb2RlUGF0dGVybnMiLCJ1cmxEZWNvZGVQYXR0ZXJucyIsInUiLCJVUkwiLCJmcm9tIiwidG8iLCJmcm9tVXJsIiwiZGVmYXVsdCIsInJlc29sdmVkVXJsIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJ0b1N0cmluZyIsImxvY2F0aW9uIiwiaHJlZiIsInBhdGgiLCJwcm9jZXNzIiwibGFzdENoYXIiLCJzbGljZSIsIm1hdGNoIiwiZXhlYyIsInRvTG93ZXJDYXNlIiwibGFzdERvdCIsImxhc3RJbmRleE9mIiwic3Vic3RyIiwicXVlcnlJbmRleCIsImluZGV4T2YiLCJoYXNoSW5kZXgiLCJicm93c2VyIiwiaXNXaW5kb3dzIiwidXBwZXJQYXRoIiwidG9VcHBlckNhc2UiLCJwcm9qZWN0RGlyUG9zaXhQYXRoIiwicG9zaXhVcHBlciIsImhhc1Byb2plY3REaXIiLCJpbmNsdWRlcyIsImhhc1Byb2plY3RVcmkiLCJpc0Fic29sdXRlUGF0aCIsIndpbjMyIiwiaXNBYnNvbHV0ZSIsImVuY29kZVVSSSIsImkiLCJsZW5ndGgiLCJyZXBsYWNlIiwia2VlcEZpbGVQcm90b2NvbCIsImRlY29kZVVSSSIsImlzRmlsZVVybCIsInBvaW50ZXIiLCJzcGxpdCIsIm1hcCIsImRlY29kZVVSSUNvbXBvbmVudCIsImZyb21EaXIiLCJkaXJuYW1lIiwidG9QYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\n");

/***/ })

};
;