"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/./node_modules/@vercel/edge-config/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@vercel/edge-config/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   digest: () => (/* binding */ digest),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAll: () => (/* binding */ getAll),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   parseConnectionString: () => (/* binding */ parseConnectionString)\n/* harmony export */ });\n/* harmony import */ var _vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/edge-config-fs */ \"node:fs/promises\");\n// src/index.ts\n\n// package.json\nvar name = \"@vercel/edge-config\";\nvar version = \"0.4.1\";\n// src/utils/index.ts\nvar ERRORS = {\n    UNEXPECTED: \"@vercel/edge-config: Unexpected error\",\n    UNAUTHORIZED: \"@vercel/edge-config: Unauthorized\",\n    NETWORK: \"@vercel/edge-config: Network error\",\n    EDGE_CONFIG_NOT_FOUND: \"@vercel/edge-config: Edge Config not found\"\n};\nfunction hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction pick(obj, keys) {\n    const ret = {};\n    keys.forEach((key)=>{\n        ret[key] = obj[key];\n    });\n    return ret;\n}\nfunction assertIsKey(key) {\n    if (typeof key !== \"string\") {\n        throw new Error(\"@vercel/edge-config: Expected key to be a string\");\n    }\n}\nfunction assertIsKeys(keys) {\n    if (!Array.isArray(keys) || keys.some((key)=>typeof key !== \"string\")) {\n        throw new Error(\"@vercel/edge-config: Expected keys to be an array of string\");\n    }\n}\nfunction clone(value) {\n    if (typeof structuredClone === \"function\") return structuredClone(value);\n    if (value === void 0) return value;\n    return JSON.parse(JSON.stringify(value));\n}\nfunction parseVercelConnectionString(text) {\n    try {\n        const url = new URL(text);\n        if (url.host !== \"edge-config.vercel.com\") return null;\n        if (url.protocol !== \"https:\") return null;\n        if (!url.pathname.startsWith(\"/ecfg\")) return null;\n        const id = url.pathname.split(\"/\")[1];\n        if (!id) return null;\n        const token = url.searchParams.get(\"token\");\n        if (!token || token === \"\") return null;\n        return {\n            type: \"vercel\",\n            baseUrl: `https://edge-config.vercel.com/${id}`,\n            id,\n            version: \"1\",\n            token\n        };\n    } catch  {\n        return null;\n    }\n}\nfunction parseExternalConnectionString(connectionString) {\n    try {\n        const url = new URL(connectionString);\n        let id = url.searchParams.get(\"id\");\n        const token = url.searchParams.get(\"token\");\n        const version2 = url.searchParams.get(\"version\") || \"1\";\n        if (!id || url.pathname.startsWith(\"/ecfg_\")) {\n            id = url.pathname.split(\"/\")[1] || null;\n        }\n        if (!id || !token) return null;\n        url.search = \"\";\n        return {\n            type: \"external\",\n            baseUrl: url.toString(),\n            id,\n            token,\n            version: version2\n        };\n    } catch  {\n        return null;\n    }\n}\nfunction parseConnectionString(connectionString) {\n    const connection = parseVercelConnectionString(connectionString);\n    if (connection) return connection;\n    return parseExternalConnectionString(connectionString);\n}\nvar isDynamicServerError = (error)=>error instanceof Error && hasOwnProperty(error, \"digest\") && error.digest === \"DYNAMIC_SERVER_USAGE\";\n// src/utils/fetch-with-cached-response.ts\nfunction createResponse(cachedResponseEntry) {\n    return new Response(cachedResponseEntry.response, {\n        headers: {\n            ...cachedResponseEntry.headers,\n            Age: String(// age header may not be 0 when serving stale content, must be >= 1\n            Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3)))\n        },\n        status: cachedResponseEntry.status\n    });\n}\nfunction createHandleStaleIfError(cachedResponseEntry, staleIfError) {\n    return function handleStaleIfError(response) {\n        switch(response.status){\n            case 500:\n            case 502:\n            case 503:\n            case 504:\n                return typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;\n            default:\n                return response;\n        }\n    };\n}\nfunction createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {\n    return function handleStaleIfError(reason) {\n        if (typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {\n            return createResponse(cachedResponseEntry);\n        }\n        throw reason;\n    };\n}\nvar cache = /* @__PURE__ */ new Map();\nfunction extractStaleIfError(cacheControlHeader) {\n    if (!cacheControlHeader) return null;\n    const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(cacheControlHeader);\n    return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;\n}\nasync function fetchWithCachedResponse(url, options = {}) {\n    const { headers: customHeaders = new Headers(), ...customOptions } = options;\n    const authHeader = customHeaders.get(\"Authorization\");\n    const cacheKey = `${url},${authHeader || \"\"}`;\n    const cachedResponseEntry = cache.get(cacheKey);\n    if (cachedResponseEntry) {\n        const { etag: etag2, response: cachedResponse } = cachedResponseEntry;\n        const headers = new Headers(customHeaders);\n        headers.set(\"If-None-Match\", etag2);\n        const staleIfError = extractStaleIfError(headers.get(\"Cache-Control\"));\n        const res2 = await fetch(url, {\n            ...customOptions,\n            headers\n        }).then(createHandleStaleIfError(cachedResponseEntry, staleIfError), createHandleStaleIfErrorException(cachedResponseEntry, staleIfError));\n        if (res2.status === 304) {\n            res2.cachedResponseBody = JSON.parse(cachedResponse);\n            return res2;\n        }\n        const newETag = res2.headers.get(\"ETag\");\n        if (res2.ok && newETag) cache.set(cacheKey, {\n            etag: newETag,\n            response: await res2.clone().text(),\n            headers: Object.fromEntries(res2.headers.entries()),\n            status: res2.status,\n            time: Date.now()\n        });\n        return res2;\n    }\n    const res = await fetch(url, options);\n    const etag = res.headers.get(\"ETag\");\n    if (res.ok && etag) {\n        cache.set(cacheKey, {\n            etag,\n            response: await res.clone().text(),\n            headers: Object.fromEntries(res.headers.entries()),\n            status: res.status,\n            time: Date.now()\n        });\n    }\n    return res;\n}\n// src/index.ts\nasync function getFileSystemEdgeConfig(connection) {\n    if (connection.type !== \"vercel\") return null;\n    if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n    try {\n        const content = await (0,_vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__.readFile)(`/opt/edge-config/${connection.id}.json`, \"utf-8\");\n        return JSON.parse(content);\n    } catch  {\n        return null;\n    }\n}\nasync function consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res) {\n    if (typeof EdgeRuntime !== \"undefined\") return;\n    await res.arrayBuffer();\n}\nfunction createClient(connectionString, options = {\n    staleIfError: 604800\n}) {\n    if (!connectionString) throw new Error(\"@vercel/edge-config: No connection string provided\");\n    const connection = parseConnectionString(connectionString);\n    if (!connection) throw new Error(\"@vercel/edge-config: Invalid connection string provided\");\n    const baseUrl = connection.baseUrl;\n    const version2 = connection.version;\n    const headers = {\n        Authorization: `Bearer ${connection.token}`\n    };\n    if (typeof process !== \"undefined\" && process.env.VERCEL_ENV) headers[\"x-edge-config-vercel-env\"] = process.env.VERCEL_ENV;\n    if (typeof name === \"string\" && typeof version === \"string\") headers[\"x-edge-config-sdk\"] = `${name}@${version}`;\n    if (typeof options.staleIfError === \"number\" && options.staleIfError > 0) headers[\"cache-control\"] = `stale-if-error=${options.staleIfError}`;\n    return {\n        connection,\n        async get (key) {\n            const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n            if (localEdgeConfig) {\n                assertIsKey(key);\n                return Promise.resolve(clone(localEdgeConfig.items[key]));\n            }\n            assertIsKey(key);\n            return fetchWithCachedResponse(`${baseUrl}/item/${key}?version=${version2}`, {\n                headers: new Headers(headers),\n                cache: \"no-store\"\n            }).then(async (res)=>{\n                if (res.ok) return res.json();\n                await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n                if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n                if (res.status === 404) {\n                    if (res.headers.has(\"x-edge-config-digest\")) return void 0;\n                    throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n                }\n                if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n                throw new Error(ERRORS.UNEXPECTED);\n            }, (error)=>{\n                if (isDynamicServerError(error)) throw error;\n                throw new Error(ERRORS.NETWORK);\n            });\n        },\n        async has (key) {\n            const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n            if (localEdgeConfig) {\n                assertIsKey(key);\n                return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n            }\n            assertIsKey(key);\n            return fetch(`${baseUrl}/item/${key}?version=${version2}`, {\n                method: \"HEAD\",\n                headers: new Headers(headers),\n                cache: \"no-store\"\n            }).then((res)=>{\n                if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n                if (res.status === 404) {\n                    if (res.headers.has(\"x-edge-config-digest\")) return false;\n                    throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n                }\n                if (res.ok) return true;\n                throw new Error(ERRORS.UNEXPECTED);\n            }, (error)=>{\n                if (isDynamicServerError(error)) throw error;\n                throw new Error(ERRORS.NETWORK);\n            });\n        },\n        async getAll (keys) {\n            const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n            if (localEdgeConfig) {\n                if (keys === void 0) {\n                    return Promise.resolve(clone(localEdgeConfig.items));\n                }\n                assertIsKeys(keys);\n                return Promise.resolve(clone(pick(localEdgeConfig.items, keys)));\n            }\n            if (Array.isArray(keys)) assertIsKeys(keys);\n            const search = Array.isArray(keys) ? new URLSearchParams(keys.map((key)=>[\n                    \"key\",\n                    key\n                ])).toString() : null;\n            if (search === \"\") return Promise.resolve({});\n            return fetchWithCachedResponse(`${baseUrl}/items?version=${version2}${search === null ? \"\" : `&${search}`}`, {\n                headers: new Headers(headers),\n                cache: \"no-store\"\n            }).then(async (res)=>{\n                if (res.ok) return res.json();\n                await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n                if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n                if (res.status === 404) throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n                if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n                throw new Error(ERRORS.UNEXPECTED);\n            }, (error)=>{\n                if (isDynamicServerError(error)) throw error;\n                throw new Error(ERRORS.NETWORK);\n            });\n        },\n        async digest () {\n            const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n            if (localEdgeConfig) {\n                return Promise.resolve(localEdgeConfig.digest);\n            }\n            return fetchWithCachedResponse(`${baseUrl}/digest?version=${version2}`, {\n                headers: new Headers(headers),\n                cache: \"no-store\"\n            }).then(async (res)=>{\n                if (res.ok) return res.json();\n                await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n                if (res.cachedResponseBody !== void 0) return res.cachedResponseBody;\n                throw new Error(ERRORS.UNEXPECTED);\n            }, (error)=>{\n                if (isDynamicServerError(error)) throw error;\n                throw new Error(ERRORS.NETWORK);\n            });\n        }\n    };\n}\nvar defaultEdgeConfigClient;\nfunction init() {\n    if (!defaultEdgeConfigClient) {\n        defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n    }\n}\nvar get = (...args)=>{\n    init();\n    return defaultEdgeConfigClient.get(...args);\n};\nvar getAll = (...args)=>{\n    init();\n    return defaultEdgeConfigClient.getAll(...args);\n};\nvar has = (...args)=>{\n    init();\n    return defaultEdgeConfigClient.has(...args);\n};\nvar digest = (...args)=>{\n    init();\n    return defaultEdgeConfigClient.digest(...args);\n};\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9lZGdlLWNvbmZpZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ21DO0FBRWxELGVBQWU7QUFDZixJQUFJQyxPQUFPO0FBQ1gsSUFBSUMsVUFBVTtBQUVkLHFCQUFxQjtBQUNyQixJQUFJQyxTQUFTO0lBQ1hDLFlBQVk7SUFDWkMsY0FBYztJQUNkQyxTQUFTO0lBQ1RDLHVCQUF1QjtBQUN6QjtBQUNBLFNBQVNDLGVBQWVDLEdBQUcsRUFBRUMsSUFBSTtJQUMvQixPQUFPQyxPQUFPQyxTQUFTLENBQUNKLGNBQWMsQ0FBQ0ssSUFBSSxDQUFDSixLQUFLQztBQUNuRDtBQUNBLFNBQVNJLEtBQUtMLEdBQUcsRUFBRU0sSUFBSTtJQUNyQixNQUFNQyxNQUFNLENBQUM7SUFDYkQsS0FBS0UsT0FBTyxDQUFDLENBQUNDO1FBQ1pGLEdBQUcsQ0FBQ0UsSUFBSSxHQUFHVCxHQUFHLENBQUNTLElBQUk7SUFDckI7SUFDQSxPQUFPRjtBQUNUO0FBQ0EsU0FBU0csWUFBWUQsR0FBRztJQUN0QixJQUFJLE9BQU9BLFFBQVEsVUFBVTtRQUMzQixNQUFNLElBQUlFLE1BQU07SUFDbEI7QUFDRjtBQUNBLFNBQVNDLGFBQWFOLElBQUk7SUFDeEIsSUFBSSxDQUFDTyxNQUFNQyxPQUFPLENBQUNSLFNBQVNBLEtBQUtTLElBQUksQ0FBQyxDQUFDTixNQUFRLE9BQU9BLFFBQVEsV0FBVztRQUN2RSxNQUFNLElBQUlFLE1BQ1I7SUFFSjtBQUNGO0FBQ0EsU0FBU0ssTUFBTUMsS0FBSztJQUNsQixJQUFJLE9BQU9DLG9CQUFvQixZQUM3QixPQUFPQSxnQkFBZ0JEO0lBQ3pCLElBQUlBLFVBQVUsS0FBSyxHQUNqQixPQUFPQTtJQUNULE9BQU9FLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsU0FBUyxDQUFDSjtBQUNuQztBQUNBLFNBQVNLLDRCQUE0QkMsSUFBSTtJQUN2QyxJQUFJO1FBQ0YsTUFBTUMs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c0ROO2dCQUM1RCxJQUFJQSxJQUFJTCxrQkFBa0IsS0FBSyxLQUFLLEdBQ2xDLE9BQU9LLElBQUlMLGtCQUFrQjtnQkFDL0IsTUFBTSxJQUFJN0UsTUFBTWpCLE9BQU9DLFVBQVU7WUFDbkMsR0FDQSxDQUFDa0Q7Z0JBQ0MsSUFBSUQscUJBQXFCQyxRQUN2QixNQUFNQTtnQkFDUixNQUFNLElBQUlsQyxNQUFNakIsT0FBT0csT0FBTztZQUNoQztRQUVKO0lBQ0Y7QUFDRjtBQUNBLElBQUlzSDtBQUNKLFNBQVNDO0lBQ1AsSUFBSSxDQUFDRCx5QkFBeUI7UUFDNUJBLDBCQUEwQmIsYUFBYVAsUUFBUUMsR0FBRyxDQUFDcUIsV0FBVztJQUNoRTtBQUNGO0FBQ0EsSUFBSW5GLE1BQU0sQ0FBQyxHQUFHb0Y7SUFDWkY7SUFDQSxPQUFPRCx3QkFBd0JqRixHQUFHLElBQUlvRjtBQUN4QztBQUNBLElBQUlOLFNBQVMsQ0FBQyxHQUFHTTtJQUNmRjtJQUNBLE9BQU9ELHdCQUF3QkgsTUFBTSxJQUFJTTtBQUMzQztBQUNBLElBQUlSLE1BQU0sQ0FBQyxHQUFHUTtJQUNaRjtJQUNBLE9BQU9ELHdCQUF3QkwsR0FBRyxJQUFJUTtBQUN4QztBQUNBLElBQUl4RSxTQUFTLENBQUMsR0FBR3dFO0lBQ2ZGO0lBQ0EsT0FBT0Qsd0JBQXdCckUsTUFBTSxJQUFJd0U7QUFDM0M7QUFRRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9lZGdlLWNvbmZpZy9kaXN0L2luZGV4LmpzP2UwN2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gXCJAdmVyY2VsL2VkZ2UtY29uZmlnLWZzXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIG5hbWUgPSBcIkB2ZXJjZWwvZWRnZS1jb25maWdcIjtcbnZhciB2ZXJzaW9uID0gXCIwLjQuMVwiO1xuXG4vLyBzcmMvdXRpbHMvaW5kZXgudHNcbnZhciBFUlJPUlMgPSB7XG4gIFVORVhQRUNURUQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogVW5leHBlY3RlZCBlcnJvclwiLFxuICBVTkFVVEhPUklaRUQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogVW5hdXRob3JpemVkXCIsXG4gIE5FVFdPUks6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogTmV0d29yayBlcnJvclwiLFxuICBFREdFX0NPTkZJR19OT1RfRk9VTkQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogRWRnZSBDb25maWcgbm90IGZvdW5kXCJcbn07XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0tleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJAdmVyY2VsL2VkZ2UtY29uZmlnOiBFeHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmdcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzS2V5cyhrZXlzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSB8fCBrZXlzLnNvbWUoKGtleSkgPT4gdHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkB2ZXJjZWwvZWRnZS1jb25maWc6IEV4cGVjdGVkIGtleXMgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5nXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBwYXJzZVZlcmNlbENvbm5lY3Rpb25TdHJpbmcodGV4dCkge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGV4dCk7XG4gICAgaWYgKHVybC5ob3N0ICE9PSBcImVkZ2UtY29uZmlnLnZlcmNlbC5jb21cIilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh1cmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXVybC5wYXRobmFtZS5zdGFydHNXaXRoKFwiL2VjZmdcIikpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpZCA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIilbMV07XG4gICAgaWYgKCFpZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSBcIlwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmVyY2VsXCIsXG4gICAgICBiYXNlVXJsOiBgaHR0cHM6Ly9lZGdlLWNvbmZpZy52ZXJjZWwuY29tLyR7aWR9YCxcbiAgICAgIGlkLFxuICAgICAgdmVyc2lvbjogXCIxXCIsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChjb25uZWN0aW9uU3RyaW5nKTtcbiAgICBsZXQgaWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImlkXCIpO1xuICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgICBjb25zdCB2ZXJzaW9uMiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmVyc2lvblwiKSB8fCBcIjFcIjtcbiAgICBpZiAoIWlkIHx8IHVybC5wYXRobmFtZS5zdGFydHNXaXRoKFwiL2VjZmdfXCIpKSB7XG4gICAgICBpZCA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIilbMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpZCB8fCAhdG9rZW4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB1cmwuc2VhcmNoID0gXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJleHRlcm5hbFwiLFxuICAgICAgYmFzZVVybDogdXJsLnRvU3RyaW5nKCksXG4gICAgICBpZCxcbiAgICAgIHRva2VuLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbjJcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgY29ubmVjdGlvbiA9IHBhcnNlVmVyY2VsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKTtcbiAgaWYgKGNvbm5lY3Rpb24pXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIHJldHVybiBwYXJzZUV4dGVybmFsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKTtcbn1cbnZhciBpc0R5bmFtaWNTZXJ2ZXJFcnJvciA9IChlcnJvcikgPT4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBoYXNPd25Qcm9wZXJ0eShlcnJvciwgXCJkaWdlc3RcIikgJiYgZXJyb3IuZGlnZXN0ID09PSBcIkRZTkFNSUNfU0VSVkVSX1VTQUdFXCI7XG5cbi8vIHNyYy91dGlscy9mZXRjaC13aXRoLWNhY2hlZC1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKGNhY2hlZFJlc3BvbnNlRW50cnkucmVzcG9uc2UsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5jYWNoZWRSZXNwb25zZUVudHJ5LmhlYWRlcnMsXG4gICAgICBBZ2U6IFN0cmluZyhcbiAgICAgICAgLy8gYWdlIGhlYWRlciBtYXkgbm90IGJlIDAgd2hlbiBzZXJ2aW5nIHN0YWxlIGNvbnRlbnQsIG11c3QgYmUgPj0gMVxuICAgICAgICBNYXRoLm1heCgxLCBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gY2FjaGVkUmVzcG9uc2VFbnRyeS50aW1lKSAvIDFlMykpXG4gICAgICApXG4gICAgfSxcbiAgICBzdGF0dXM6IGNhY2hlZFJlc3BvbnNlRW50cnkuc3RhdHVzXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFuZGxlU3RhbGVJZkVycm9yKGNhY2hlZFJlc3BvbnNlRW50cnksIHN0YWxlSWZFcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlU3RhbGVJZkVycm9yKHJlc3BvbnNlKSB7XG4gICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgIGNhc2UgNTAwOlxuICAgICAgY2FzZSA1MDI6XG4gICAgICBjYXNlIDUwMzpcbiAgICAgIGNhc2UgNTA0OlxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YWxlSWZFcnJvciA9PT0gXCJudW1iZXJcIiAmJiBjYWNoZWRSZXNwb25zZUVudHJ5LnRpbWUgPCBEYXRlLm5vdygpICsgc3RhbGVJZkVycm9yICogMWUzID8gY3JlYXRlUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeSkgOiByZXNwb25zZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3JFeGNlcHRpb24oY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVTdGFsZUlmRXJyb3IocmVhc29uKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFsZUlmRXJyb3IgPT09IFwibnVtYmVyXCIgJiYgY2FjaGVkUmVzcG9uc2VFbnRyeS50aW1lIDwgRGF0ZS5ub3coKSArIHN0YWxlSWZFcnJvciAqIDFlMykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3BvbnNlKGNhY2hlZFJlc3BvbnNlRW50cnkpO1xuICAgIH1cbiAgICB0aHJvdyByZWFzb247XG4gIH07XG59XG52YXIgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YWxlSWZFcnJvcihjYWNoZUNvbnRyb2xIZWFkZXIpIHtcbiAgaWYgKCFjYWNoZUNvbnRyb2xIZWFkZXIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG1hdGNoZWQgPSAvc3RhbGUtaWYtZXJyb3I9KD88c3RhbGVJZkVycm9yPlxcZCspL2kuZXhlYyhcbiAgICBjYWNoZUNvbnRyb2xIZWFkZXJcbiAgKTtcbiAgcmV0dXJuIChtYXRjaGVkID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaGVkLmdyb3VwcykgPyBOdW1iZXIobWF0Y2hlZC5ncm91cHMuc3RhbGVJZkVycm9yKSA6IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZSh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGhlYWRlcnM6IGN1c3RvbUhlYWRlcnMgPSBuZXcgSGVhZGVycygpLCAuLi5jdXN0b21PcHRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCBhdXRoSGVhZGVyID0gY3VzdG9tSGVhZGVycy5nZXQoXCJBdXRob3JpemF0aW9uXCIpO1xuICBjb25zdCBjYWNoZUtleSA9IGAke3VybH0sJHthdXRoSGVhZGVyIHx8IFwiXCJ9YDtcbiAgY29uc3QgY2FjaGVkUmVzcG9uc2VFbnRyeSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChjYWNoZWRSZXNwb25zZUVudHJ5KSB7XG4gICAgY29uc3QgeyBldGFnOiBldGFnMiwgcmVzcG9uc2U6IGNhY2hlZFJlc3BvbnNlIH0gPSBjYWNoZWRSZXNwb25zZUVudHJ5O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhjdXN0b21IZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldChcIklmLU5vbmUtTWF0Y2hcIiwgZXRhZzIpO1xuICAgIGNvbnN0IHN0YWxlSWZFcnJvciA9IGV4dHJhY3RTdGFsZUlmRXJyb3IoaGVhZGVycy5nZXQoXCJDYWNoZS1Db250cm9sXCIpKTtcbiAgICBjb25zdCByZXMyID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgaGVhZGVyc1xuICAgIH0pLnRoZW4oXG4gICAgICBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3IoY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSxcbiAgICAgIGNyZWF0ZUhhbmRsZVN0YWxlSWZFcnJvckV4Y2VwdGlvbihjYWNoZWRSZXNwb25zZUVudHJ5LCBzdGFsZUlmRXJyb3IpXG4gICAgKTtcbiAgICBpZiAocmVzMi5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgcmVzMi5jYWNoZWRSZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXMyO1xuICAgIH1cbiAgICBjb25zdCBuZXdFVGFnID0gcmVzMi5oZWFkZXJzLmdldChcIkVUYWdcIik7XG4gICAgaWYgKHJlczIub2sgJiYgbmV3RVRhZylcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwge1xuICAgICAgICBldGFnOiBuZXdFVGFnLFxuICAgICAgICByZXNwb25zZTogYXdhaXQgcmVzMi5jbG9uZSgpLnRleHQoKSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlczIuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBzdGF0dXM6IHJlczIuc3RhdHVzLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICByZXR1cm4gcmVzMjtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICBjb25zdCBldGFnID0gcmVzLmhlYWRlcnMuZ2V0KFwiRVRhZ1wiKTtcbiAgaWYgKHJlcy5vayAmJiBldGFnKSB7XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICBldGFnLFxuICAgICAgcmVzcG9uc2U6IGF3YWl0IHJlcy5jbG9uZSgpLnRleHQoKSxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXMuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcoY29ubmVjdGlvbikge1xuICBpZiAoY29ubmVjdGlvbi50eXBlICE9PSBcInZlcmNlbFwiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoIXByb2Nlc3MuZW52LkFXU19MQU1CREFfRlVOQ1RJT05fTkFNRSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoXG4gICAgICBgL29wdC9lZGdlLWNvbmZpZy8ke2Nvbm5lY3Rpb24uaWR9Lmpzb25gLFxuICAgICAgXCJ1dGYtOFwiXG4gICAgKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVSZXNwb25zZUJvZHlJbk5vZGVKc1J1bnRpbWVUb1ByZXZlbnRNZW1vcnlMZWFrKHJlcykge1xuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoY29ubmVjdGlvblN0cmluZywgb3B0aW9ucyA9IHtcbiAgc3RhbGVJZkVycm9yOiA2MDQ4MDBcbiAgLyogb25lIHdlZWsgKi9cbn0pIHtcbiAgaWYgKCFjb25uZWN0aW9uU3RyaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkB2ZXJjZWwvZWRnZS1jb25maWc6IE5vIGNvbm5lY3Rpb24gc3RyaW5nIHByb3ZpZGVkXCIpO1xuICBjb25zdCBjb25uZWN0aW9uID0gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBpZiAoIWNvbm5lY3Rpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogSW52YWxpZCBjb25uZWN0aW9uIHN0cmluZyBwcm92aWRlZFwiKTtcbiAgY29uc3QgYmFzZVVybCA9IGNvbm5lY3Rpb24uYmFzZVVybDtcbiAgY29uc3QgdmVyc2lvbjIgPSBjb25uZWN0aW9uLnZlcnNpb247XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2Nvbm5lY3Rpb24udG9rZW59YFxuICB9O1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX0VOVilcbiAgICBoZWFkZXJzW1wieC1lZGdlLWNvbmZpZy12ZXJjZWwtZW52XCJdID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0VOVjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgIGhlYWRlcnNbXCJ4LWVkZ2UtY29uZmlnLXNka1wiXSA9IGAke25hbWV9QCR7dmVyc2lvbn1gO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuc3RhbGVJZkVycm9yID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMuc3RhbGVJZkVycm9yID4gMClcbiAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBzdGFsZS1pZi1lcnJvcj0ke29wdGlvbnMuc3RhbGVJZkVycm9yfWA7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdGlvbixcbiAgICBhc3luYyBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbG9uZShsb2NhbEVkZ2VDb25maWcuaXRlbXNba2V5XSkpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgYCR7YmFzZVVybH0vaXRlbS8ke2tleX0/dmVyc2lvbj0ke3ZlcnNpb24yfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICAgIH1cbiAgICAgICkudGhlbihcbiAgICAgICAgYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgIGlmIChyZXMub2spXG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICBhd2FpdCBjb25zdW1lUmVzcG9uc2VCb2R5SW5Ob2RlSnNSdW50aW1lVG9QcmV2ZW50TWVtb3J5TGVhayhyZXMpO1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVOQVVUSE9SSVpFRCk7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmhhcyhcIngtZWRnZS1jb25maWctZGlnZXN0XCIpKVxuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5FREdFX0NPTkZJR19OT1RfRk9VTkQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzLmNhY2hlZFJlc3BvbnNlQm9keSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5jYWNoZWRSZXNwb25zZUJvZHk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkVYUEVDVEVEKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGlzRHluYW1pY1NlcnZlckVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuTkVUV09SSyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBhc3luYyBoYXMoa2V5KSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYXNPd25Qcm9wZXJ0eShsb2NhbEVkZ2VDb25maWcuaXRlbXMsIGtleSkpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgIHJldHVybiBmZXRjaChgJHtiYXNlVXJsfS9pdGVtLyR7a2V5fT92ZXJzaW9uPSR7dmVyc2lvbjJ9YCwge1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgfSkudGhlbihcbiAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVOQVVUSE9SSVpFRCk7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmhhcyhcIngtZWRnZS1jb25maWctZGlnZXN0XCIpKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLkVER0VfQ09ORklHX05PVF9GT1VORCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMub2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVORVhQRUNURUQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoaXNEeW5hbWljU2VydmVyRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5ORVRXT1JLKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGdldEFsbChrZXlzKSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2xvbmUobG9jYWxFZGdlQ29uZmlnLml0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SXNLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsb25lKHBpY2sobG9jYWxFZGdlQ29uZmlnLml0ZW1zLCBrZXlzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpXG4gICAgICAgIGFzc2VydElzS2V5cyhrZXlzKTtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IEFycmF5LmlzQXJyYXkoa2V5cykgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgICAgICBrZXlzLm1hcCgoa2V5KSA9PiBbXCJrZXlcIiwga2V5XSlcbiAgICAgICkudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgICBpZiAoc2VhcmNoID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgYCR7YmFzZVVybH0vaXRlbXM/dmVyc2lvbj0ke3ZlcnNpb24yfSR7c2VhcmNoID09PSBudWxsID8gXCJcIiA6IGAmJHtzZWFyY2h9YH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgICB9XG4gICAgICApLnRoZW4oXG4gICAgICAgIGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICBpZiAocmVzLm9rKVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgYXdhaXQgY29uc3VtZVJlc3BvbnNlQm9keUluTm9kZUpzUnVudGltZVRvUHJldmVudE1lbW9yeUxlYWsocmVzKTtcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkFVVEhPUklaRUQpO1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLkVER0VfQ09ORklHX05PVF9GT1VORCk7XG4gICAgICAgICAgaWYgKHJlcy5jYWNoZWRSZXNwb25zZUJvZHkgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuVU5FWFBFQ1RFRCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5FVFdPUkspO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgYXN5bmMgZGlnZXN0KCkge1xuICAgICAgY29uc3QgbG9jYWxFZGdlQ29uZmlnID0gYXdhaXQgZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcoY29ubmVjdGlvbik7XG4gICAgICBpZiAobG9jYWxFZGdlQ29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxFZGdlQ29uZmlnLmRpZ2VzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hXaXRoQ2FjaGVkUmVzcG9uc2UoYCR7YmFzZVVybH0vZGlnZXN0P3ZlcnNpb249JHt2ZXJzaW9uMn1gLCB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICB9KS50aGVuKFxuICAgICAgICBhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKHJlcy5vaylcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgIGF3YWl0IGNvbnN1bWVSZXNwb25zZUJvZHlJbk5vZGVKc1J1bnRpbWVUb1ByZXZlbnRNZW1vcnlMZWFrKHJlcyk7XG4gICAgICAgICAgaWYgKHJlcy5jYWNoZWRSZXNwb25zZUJvZHkgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuVU5FWFBFQ1RFRCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5FVFdPUkspO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudDtcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmICghZGVmYXVsdEVkZ2VDb25maWdDbGllbnQpIHtcbiAgICBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudCA9IGNyZWF0ZUNsaWVudChwcm9jZXNzLmVudi5FREdFX0NPTkZJRyk7XG4gIH1cbn1cbnZhciBnZXQgPSAoLi4uYXJncykgPT4ge1xuICBpbml0KCk7XG4gIHJldHVybiBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudC5nZXQoLi4uYXJncyk7XG59O1xudmFyIGdldEFsbCA9ICguLi5hcmdzKSA9PiB7XG4gIGluaXQoKTtcbiAgcmV0dXJuIGRlZmF1bHRFZGdlQ29uZmlnQ2xpZW50LmdldEFsbCguLi5hcmdzKTtcbn07XG52YXIgaGFzID0gKC4uLmFyZ3MpID0+IHtcbiAgaW5pdCgpO1xuICByZXR1cm4gZGVmYXVsdEVkZ2VDb25maWdDbGllbnQuaGFzKC4uLmFyZ3MpO1xufTtcbnZhciBkaWdlc3QgPSAoLi4uYXJncykgPT4ge1xuICBpbml0KCk7XG4gIHJldHVybiBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudC5kaWdlc3QoLi4uYXJncyk7XG59O1xuZXhwb3J0IHtcbiAgY3JlYXRlQ2xpZW50LFxuICBkaWdlc3QsXG4gIGdldCxcbiAgZ2V0QWxsLFxuICBoYXMsXG4gIHBhcnNlQ29ubmVjdGlvblN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJyZWFkRmlsZSIsIm5hbWUiLCJ2ZXJzaW9uIiwiRVJST1JTIiwiVU5FWFBFQ1RFRCIsIlVOQVVUSE9SSVpFRCIsIk5FVFdPUksiLCJFREdFX0NPTkZJR19OT1RfRk9VTkQiLCJoYXNPd25Qcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJjYWxsIiwicGljayIsImtleXMiLCJyZXQiLCJmb3JFYWNoIiwia2V5IiwiYXNzZXJ0SXNLZXkiLCJFcnJvciIsImFzc2VydElzS2V5cyIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJjbG9uZSIsInZhbHVlIiwic3RydWN0dXJlZENsb25lIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwicGFyc2VWZXJjZWxDb25uZWN0aW9uU3RyaW5nIiwidGV4dCIsInVybCIsIlVSTCIsImhvc3QiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwic3RhcnRzV2l0aCIsImlkIiwic3BsaXQiLCJ0b2tlbiIsInNlYXJjaFBhcmFtcyIsImdldCIsInR5cGUiLCJiYXNlVXJsIiwicGFyc2VFeHRlcm5hbENvbm5lY3Rpb25TdHJpbmciLCJjb25uZWN0aW9uU3RyaW5nIiwidmVyc2lvbjIiLCJzZWFyY2giLCJ0b1N0cmluZyIsInBhcnNlQ29ubmVjdGlvblN0cmluZyIsImNvbm5lY3Rpb24iLCJpc0R5bmFtaWNTZXJ2ZXJFcnJvciIsImVycm9yIiwiZGlnZXN0IiwiY3JlYXRlUmVzcG9uc2UiLCJjYWNoZWRSZXNwb25zZUVudHJ5IiwiUmVzcG9uc2UiLCJyZXNwb25zZSIsImhlYWRlcnMiLCJBZ2UiLCJTdHJpbmciLCJNYXRoIiwibWF4IiwiZmxvb3IiLCJEYXRlIiwibm93IiwidGltZSIsInN0YXR1cyIsImNyZWF0ZUhhbmRsZVN0YWxlSWZFcnJvciIsInN0YWxlSWZFcnJvciIsImhhbmRsZVN0YWxlSWZFcnJvciIsImNyZWF0ZUhhbmRsZVN0YWxlSWZFcnJvckV4Y2VwdGlvbiIsInJlYXNvbiIsImNhY2hlIiwiTWFwIiwiZXh0cmFjdFN0YWxlSWZFcnJvciIsImNhY2hlQ29udHJvbEhlYWRlciIsIm1hdGNoZWQiLCJleGVjIiwiZ3JvdXBzIiwiTnVtYmVyIiwiZmV0Y2hXaXRoQ2FjaGVkUmVzcG9uc2UiLCJvcHRpb25zIiwiY3VzdG9tSGVhZGVycyIsIkhlYWRlcnMiLCJjdXN0b21PcHRpb25zIiwiYXV0aEhlYWRlciIsImNhY2hlS2V5IiwiZXRhZyIsImV0YWcyIiwiY2FjaGVkUmVzcG9uc2UiLCJzZXQiLCJyZXMyIiwiZmV0Y2giLCJ0aGVuIiwiY2FjaGVkUmVzcG9uc2VCb2R5IiwibmV3RVRhZyIsIm9rIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwicmVzIiwiZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWciLCJwcm9jZXNzIiwiZW52IiwiQVdTX0xBTUJEQV9GVU5DVElPTl9OQU1FIiwiY29udGVudCIsImNvbnN1bWVSZXNwb25zZUJvZHlJbk5vZGVKc1J1bnRpbWVUb1ByZXZlbnRNZW1vcnlMZWFrIiwiRWRnZVJ1bnRpbWUiLCJhcnJheUJ1ZmZlciIsImNyZWF0ZUNsaWVudCIsIkF1dGhvcml6YXRpb24iLCJWRVJDRUxfRU5WIiwibG9jYWxFZGdlQ29uZmlnIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpdGVtcyIsImpzb24iLCJoYXMiLCJtZXRob2QiLCJnZXRBbGwiLCJVUkxTZWFyY2hQYXJhbXMiLCJtYXAiLCJkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudCIsImluaXQiLCJFREdFX0NPTkZJRyIsImFyZ3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/edge-config/dist/index.js\n");

/***/ })

};
;